

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="nginx数据结构 整型数据类型ngx_int_t123typedef intptr_t        ngx_int_t;typedef uintptr_t       ngx_uint_t;typedef intptr_t        ngx_flag_t;  其中，intptr_t 和 uintptr_t 是标准库 stdint.h 中定义的整数类型，它们用于存储指针值。它们的定义如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx数据结构">
<meta property="og:url" content="http://example.com/2023/03/07/Nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="nginx数据结构 整型数据类型ngx_int_t123typedef intptr_t        ngx_int_t;typedef uintptr_t       ngx_uint_t;typedef intptr_t        ngx_flag_t;  其中，intptr_t 和 uintptr_t 是标准库 stdint.h 中定义的整数类型，它们用于存储指针值。它们的定义如下：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/qrI7kPjaR5mlwKu.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/sk9HIyUFvebqcP8.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/wdyTRUqcJVDAibK.webp">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/V9XjNOhx6avRmez.webp">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/qtUulxvAwfbhRz2.webp">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/x5qdZ1vDyGVt37J.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/xl8P7vMTdfLkWJO.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/A1FD3mMUQvSaGCi.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/F7UquTgPlARjeX5.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/ADgYxOuqIMfl2nJ.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/ZbEYmN4V7nW9cJH.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/jXQoYbiV8NpS7s1.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/6STaUCZkpLjY1IR.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/ezxEjR6AU8utkWT.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/gt5cvWXzsrhHKYm.png">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/wt4UXuV2s6z7v51.png">
<meta property="article:published_time" content="2023-03-07T11:18:14.000Z">
<meta property="article:modified_time" content="2025-02-04T02:29:20.413Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/05/25/qrI7kPjaR5mlwKu.png">
  
  
  
  <title>Nginx数据结构 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Nginx数据结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-07 19:18" pubdate>
          2023年3月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          95 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Nginx数据结构</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="nginx数据结构"><a href="#nginx数据结构" class="headerlink" title="nginx数据结构"></a>nginx数据结构</h1><p><img src="https://s2.loli.net/2024/05/25/qrI7kPjaR5mlwKu.png" srcset="/img/loading.gif" lazyload alt="20210709173511720"></p>
<h3 id="整型数据类型ngx-int-t"><a href="#整型数据类型ngx-int-t" class="headerlink" title="整型数据类型ngx_int_t"></a>整型数据类型ngx_int_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_int_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uintptr_t</span>       <span class="hljs-type">ngx_uint_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_flag_t</span>;<br></code></pre></td></tr></table></figure>

<p>其中，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库 <code>stdint.h</code> 中定义的整数类型，它们用于存储指针值。它们的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span>   <span class="hljs-type">intptr_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">uintptr_t</span>;<br></code></pre></td></tr></table></figure>

<ol>
<li><ul>
<li>**<code>intptr_t</code>**：这是一个有符号整数类型，能够存储一个指针。它的大小与指针相同，可以安全地存储和操作指针值。</li>
<li>**<code>uintptr_t</code>**：这是一个无符号整数类型，能够存储一个指针。与 <code>intptr_t</code> 类似，它的大小也与指针相同。</li>
</ul>
</li>
</ol>
<h4 id="基础巩固"><a href="#基础巩固" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><p><strong>什么是有符号整数类型和无符号整数类型？</strong></p>
<blockquote>
<h4 id="有符号整数类型"><a href="#有符号整数类型" class="headerlink" title="有符号整数类型"></a>有符号整数类型</h4><p>有符号整数类型（Signed Integer Type）是可以表示正数、负数和零的整数类型。它的最高位通常用作符号位（0 表示正，1 表示负）。在 C 语言中，常见的有符号整数类型包括 <code>int</code>、<code>short</code>、<code>long</code> 等。</p>
<p>例如，在一个 8 位（1 字节）的有符号整数中：</p>
<ul>
<li>最高位是符号位。</li>
<li>值范围是从 -128 到 127。</li>
</ul>
<p>二进制表示：</p>
<ul>
<li><code>01111111</code> (127)</li>
<li><code>10000000</code> (-128)</li>
</ul>
<h4 id="无符号整数类型"><a href="#无符号整数类型" class="headerlink" title="无符号整数类型"></a>无符号整数类型</h4><p>无符号整数类型（Unsigned Integer Type）只能表示非负整数（正数和零）。所有位都用于表示数值，因此可以表示更大的正数范围。常见的无符号整数类型包括 <code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code> 等。</p>
<p>例如，在一个 8 位（1 字节）的无符号整数中：</p>
<ul>
<li>没有符号位，所有位都用于表示数值。</li>
<li>值范围是从 0 到 255。</li>
</ul>
<p>二进制表示：</p>
<ul>
<li><code>00000000</code> (0)</li>
<li><code>11111111</code> (255)</li>
</ul>
</blockquote>
<p><strong>为什么是<code>intptr_t</code>和uintptr_t 而不是  int ？</strong></p>
<p>对于 C 语言的实现，<code>intptr_t</code> 和 <code>uintptr_t</code> 是定义为与平台的指针大小相同的有符号和无符号整数类型。这意味着在 32 位平台上，它们通常是 32 位整数，而在 64 位平台上，它们通常是 64 位整数。</p>
<p>这种类型的定义是为了确保在不同平台上具有相同的大小，从而使得代码在不同平台上具有可移植性</p>
<p><strong>整数类型与指针的关系？</strong></p>
<blockquote>
<ul>
<li><strong>指针类型</strong>：指针类型用于存储内存地址，表示变量或数据在内存中的位置。指针的大小取决于系统架构（例如，32 位系统上的指针为 4 字节，64 位系统上的指针为 8 字节）。</li>
<li><strong>整数类型与指针</strong>：在某些情况下，可以使用整数类型来存储或操作指针值。例如，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库中定义的类型，用于存储可以容纳指针值的有符号和无符号整数。这在需要将指针转化为整数或将整数转化为指针的操作中很有用。</li>
</ul>
</blockquote>
<p><strong>整数类型在不同的系统架构（如 32 位和 64 位）有何区别？</strong></p>
<blockquote>
<h4 id="32-位系统"><a href="#32-位系统" class="headerlink" title="32 位系统"></a>32 位系统</h4><ul>
<li><strong>整数类型</strong>：典型地，<code>int</code> 为 4 字节，<code>long</code> 为 4 字节，<code>pointer</code> 为 4 字节。</li>
<li><strong>指针类型</strong>：指针占用 4 字节，能够表示的地址范围是 0 到 2^32 - 1（4 GB）。</li>
</ul>
<h4 id="64-位系统"><a href="#64-位系统" class="headerlink" title="64 位系统"></a>64 位系统</h4><ul>
<li><strong>整数类型</strong>：<code>int</code> 仍然通常为 4 字节，<code>long</code> 和 <code>pointer</code> 为 8 字节。</li>
<li><strong>指针类型</strong>：指针占用 8 字节，能够表示的地址范围是 0 到 2^64 - 1（16 EB）。</li>
</ul>
</blockquote>
<h3 id="字符串数据类型ngx-str-t"><a href="#字符串数据类型ngx-str-t" class="headerlink" title="字符串数据类型ngx_str_t"></a>字符串数据类型ngx_str_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">size_t</span>      len;    <span class="hljs-comment">/* 字符串的长度 */</span><br>    u_char     *data;   <span class="hljs-comment">/* 指向字符串的第一个字符 */</span><br>&#125; <span class="hljs-type">ngx_str_t</span>;<br></code></pre></td></tr></table></figure>

<h4 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h4><ul>
<li><strong><code>size_t len</code></strong>: 这是一个无符号整数类型，用于存储字符串的长度。<code>size_t</code> 类型通常用于表示对象的大小或数组的长度，它的大小依赖于具体的系统架构（在32位系统上通常是4字节，在64位系统上通常是8字节）。</li>
<li><strong><code>u_char *data</code></strong>: 这是一个指向字符串第一个字符的指针。<code>u_char</code> 通常是 <code>unsigned char</code> 的别名，表示无符号字符类型。这种类型保证了字符的值在 0 到 255 之间。</li>
</ul>
<h4 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h4><p><strong>为什么这里要附加一个字符串长度【len】相比较于传统string的优点？</strong></p>
<p>其实这种字符串处理方式在高性能场景下非常有用，尤其是在需要频繁处理字符串的网络服务器中，例如，再看redis的字符串设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//被使用的长度</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>它不依赖于以 <code>&#39;\0&#39;</code> 结尾来标识字符串的结束，而是明确地记录了字符串的长度。这种设计有几个优势：</p>
<ol>
<li><strong>性能优化</strong>：操作字符串时不需要遍历整个字符串寻找 <code>&#39;\0&#39;</code>，可以直接通过长度进行操作。</li>
<li><strong>支持二进制数据</strong>：能够处理包含 <code>&#39;\0&#39;</code> 字节的字符串或二进制数据，因为长度是显式存储的。</li>
<li><strong>更好的安全性</strong>：避免了因缺少字符串结束符导致的缓冲区溢出等安全问题。</li>
</ol>
<h5 id="基础巩固-1"><a href="#基础巩固-1" class="headerlink" title="基础巩固"></a>基础巩固</h5><p><strong>是否熟悉以下数据类型？</strong></p>
<blockquote>
<p><strong><code>size_t</code></strong> 是一种无符号整数类型，用于表示对象的大小或数组的长度。它的具体大小取决于系统架构，在 32 位系统上通常是 4 字节，在 64 位系统上通常是 8 字节。</p>
<p>**<code>unsigned int</code>**：无符号整型，在大多数平台上为 4 字节。</p>
<p>**<code>unsigned long</code>**：无符号长整型，在 32 位系统上通常为 4 字节，在 64 位系统上通常为 8 字节。</p>
<p><strong><code>u_char</code></strong> 通常是 <code>unsigned char</code> 的别名，用于表示无符号字符类型。它可以存储 0 到 255 之间的整数。大多数情况下，<code>uint8_t</code> 和 <code>unsigned char</code> 可以互换使用。</p>
<p><strong><code>uint8_t</code></strong> 是一种标准整数类型，主要优势在于它的跨平台一致性。无论是在 32 位系统还是 64 位系统上，<code>uint8_t</code> 总是表示 8 位无符号整数</p>
<p>**<code>uint16_t</code>**：表示 16 位无符号整数，取值范围为 0 到 65535。它保证在所有平台上都是 16 位，因此非常适合用于需要明确双字节大小的场合，如某些文件格式和协议字段等。</p>
<p>**<code>unsigned short</code>**：在许多平台上，<code>unsigned short</code> 通常是 16 位无符号整数，取值范围也是 0 到 65535。</p>
<p>**<code>uint_least16_t</code>**：确保至少有 16 位的无符号整数类型。</p>
<p>**<code>uint_fast16_t</code>**：确保至少有 16 位且运算速度最快的无符号整数类型。</p>
</blockquote>
<h3 id="内存池数据类型ngx-pool-s"><a href="#内存池数据类型ngx-pool-s" class="headerlink" title="内存池数据类型ngx_pool_s"></a>内存池数据类型ngx_pool_s</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 分配内存空间的大小</span><br><span class="hljs-comment">// 分配内存空间</span><br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>.......<br><span class="hljs-built_in">free</span>(ptr);<br></code></pre></td></tr></table></figure>

<p>当我们使用malloc为程序申请内存时，会无法避免的出现<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoyl/p/3820852.html">内存碎片</a>问题。</p>
<p><img src="https://s2.loli.net/2024/05/25/sk9HIyUFvebqcP8.png" srcset="/img/loading.gif" lazyload alt="内存碎片"></p>
<p>这对于长时间运行的系统或者需要高性能的系统是致命的。</p>
<blockquote>
<ol>
<li><strong>内存浪费</strong>: 内存碎片导致一些内存无法被有效利用，即使整体上有足够的可用内存，但无法分配给大块连续的内存请求。这种情况下，系统实际可用内存会减少，造成内存资源的浪费。</li>
<li><strong>性能下降</strong>: 内存碎片可能导致内存分配效率下降。当请求大块连续内存时，系统需要搜索并合并碎片化的内存块，这可能会增加内存分配的开销和时间。此外，内存碎片也可能导致页面置换算法的性能下降，因为系统需要更频繁地进行页面换入换出操作。</li>
<li><strong>内存泄漏</strong>: 内存碎片可能导致内存泄漏问题的难以发现和排查。即使系统中存在大量的可用内存，但如果这些内存被分散成了小块碎片，而且这些碎片被长期占用而未被释放，就会导致整体内存资源的浪费和不足。</li>
<li><strong>系统稳定性降低</strong>: 当内存碎片达到一定程度时，可能会导致系统出现内存耗尽的情况，从而导致系统崩溃或者运行异常。特别是在长时间运行的系统中，内存碎片可能会逐渐积累，最终导致系统的稳定性降低。</li>
</ol>
</blockquote>
<p>解决方案之一就是使用<strong>内存池</strong>，这里推荐大家一个手写<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/435427939">内存池项目</a> </p>
<p>简短的来说，内存池通过预先分配一定大小的内存块，并按需分配和释放这些内存块，以减少内存碎片的产生。</p>
<p>现在再回到Nginx的内存池上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 文件 core/ngx_palloc.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span>            <span class="hljs-title">ngx_pool_t</span>;</span><br><span class="hljs-comment">//指向以 void *data 作为参数并且没有返回值的函数的指针。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_pool_cleanup_pt)</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span>  <span class="hljs-title">ngx_pool_cleanup_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span> &#123;</span><br>    ngx_pool_cleanup_pt   handler;  <span class="hljs-comment">// 清理函数指针，用于在释放内存时执行清理操作</span><br>    <span class="hljs-type">void</span>                 *data;     <span class="hljs-comment">// 清理函数的参数</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *next;     <span class="hljs-comment">// 指向下一个清理结构体的指针，构成清理链表</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span>  <span class="hljs-title">ngx_pool_large_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *next;     <span class="hljs-comment">// 指向下一个大块内存结构体的指针，构成大块内存链表</span><br>    <span class="hljs-type">void</span>                 *alloc;    <span class="hljs-comment">// 分配的大块内存的指针</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    u_char               *last;     <span class="hljs-comment">// 当前内存分配的结束位置，下一段可分配内存的起始位置</span><br>    u_char               *end;      <span class="hljs-comment">// 内存池的结束位置</span><br>    <span class="hljs-type">ngx_pool_t</span>           *next;     <span class="hljs-comment">// 指向下一个内存池的指针</span><br>    <span class="hljs-type">ngx_uint_t</span>            failed;   <span class="hljs-comment">// 记录内存池内存分配失败的次数</span><br>&#125; <span class="hljs-type">ngx_pool_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_data_t</span>       d;        <span class="hljs-comment">// 内存池的数据块，包括可分配内存的起始位置、结束位置和下一个内存池的指针等信息</span><br>    <span class="hljs-type">size_t</span>                max;      <span class="hljs-comment">// 内存池数据块的最大值</span><br>    <span class="hljs-type">ngx_pool_t</span>           *current;  <span class="hljs-comment">// 指向当前内存池的指针</span><br>    <span class="hljs-type">ngx_chain_t</span>          *chain;    <span class="hljs-comment">// 指向一个数据链表的指针</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *large;    <span class="hljs-comment">// 指向一个大块内存链表的指针</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *cleanup;  <span class="hljs-comment">// 指向内存池清理结构体的指针，用于执行内存清理操作</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_fd_t</span>              fd;       <span class="hljs-comment">// 文件描述符</span><br>    u_char               *name;     <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125; <span class="hljs-type">ngx_pool_cleanup_file_t</span>;<br><br></code></pre></td></tr></table></figure>

<p>内存池各组件结构之间的关系：</p>
<p><img src="https://s2.loli.net/2024/05/25/wdyTRUqcJVDAibK.webp" srcset="/img/loading.gif" lazyload alt="nginx内存池">其中这里的ngx_pool_cleanup_pt是一个比较好的设计，通过定义这种类型的函数指针，可以将不同的清理函数关联到内存池中，以便在内存池销毁时调用。比如说：处理内存池销毁时需要执行的清理任务。例如，关闭打开的文件，释放分配的资源等。</p>
<p>关于内存池相关的函数，可能以后会具体开一章讲解。这里先附上执行流程图</p>
<p><img src="https://s2.loli.net/2024/05/25/V9XjNOhx6avRmez.webp" srcset="/img/loading.gif" lazyload alt="nginx内存池函数流程"></p>
<p>这里说一个在内存池设计中，常见的方法：以特定对齐方式分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//调用 posix_memalign 函数，该函数会尝试以特定的对齐方式 alignment 分配指定大小 size 的内存块，并将分配的内存地址存储在 p 中。</span><br>posix_memalign(&amp;p, alignment, size)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/05/25/qtUulxvAwfbhRz2.webp" srcset="/img/loading.gif" lazyload alt="内存对齐"></p>
<blockquote>
<p>在内存中我们一般读取数据不是按内存来读取，一般都是按内存块来读取。</p>
<p>未对齐的情况下，当需要访问int类型的数据时，需要CPU访问2次内存块（内存块1和内存块2）</p>
<p>对齐的情况下，当访问int类型的数据时，只需要CPU访问1次内存块（内存块2）即可</p>
<p>是一种空间换时间的做法 </p>
</blockquote>
<h3 id="缓冲区数据类型ngx-buf-s"><a href="#缓冲区数据类型ngx-buf-s" class="headerlink" title="缓冲区数据类型ngx_buf_s"></a>缓冲区数据类型ngx_buf_s</h3><p><img src="https://s2.loli.net/2024/05/25/x5qdZ1vDyGVt37J.png" srcset="/img/loading.gif" lazyload alt="nginx缓冲区"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *            <span class="hljs-type">ngx_buf_tag_t</span>;  <span class="hljs-comment">// 缓冲区标签类型，用于标识缓冲区的特定类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span>  <span class="hljs-title">ngx_buf_t</span>;</span>  <span class="hljs-comment">// Nginx 缓冲区结构体</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span> &#123;</span><br>    u_char          *pos;            <span class="hljs-comment">// 缓冲区数据在内存的起始位置</span><br>    u_char          *last;           <span class="hljs-comment">// 缓冲区数据在内存的结束位置</span><br>    <span class="hljs-type">off_t</span>            file_pos;       <span class="hljs-comment">// 文件读取偏移量</span><br>    <span class="hljs-type">off_t</span>            file_last;      <span class="hljs-comment">// 文件读取结束位置</span><br><br>    u_char          *start;          <span class="hljs-comment">/* 缓冲区的起始地址 */</span><br>    u_char          *end;            <span class="hljs-comment">/* 缓冲区的结束地址 */</span><br>    <span class="hljs-type">ngx_buf_tag_t</span>    tag;            <span class="hljs-comment">// 缓冲区的标签</span><br>    <span class="hljs-type">ngx_file_t</span>      *file;           <span class="hljs-comment">// 缓冲区关联的文件对象</span><br>    <span class="hljs-type">ngx_buf_t</span>       *shadow;         <span class="hljs-comment">// 当前缓冲区的影子缓冲区</span><br>    <span class="hljs-type">unsigned</span>         temporary:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 缓冲区数据可以被修改的标志</span><br>    <span class="hljs-type">unsigned</span>         memory:<span class="hljs-number">1</span>;       <span class="hljs-comment">// 缓冲区数据在内存中的标志，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         mmap:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区数据是通过 mmap 映射的，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         recycled:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否已经被回收</span><br>    <span class="hljs-type">unsigned</span>         in_file:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 缓冲区的数据是否在文件中</span><br>    <span class="hljs-type">unsigned</span>         flush:<span class="hljs-number">1</span>;        <span class="hljs-comment">// 缓冲区是否需要刷新</span><br>    <span class="hljs-type">unsigned</span>         sync:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区是否需要同步</span><br>    <span class="hljs-type">unsigned</span>         last_buf:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否为最后一个缓冲区</span><br>    <span class="hljs-type">unsigned</span>         last_in_chain:<span class="hljs-number">1</span>; <span class="hljs-comment">// 缓冲区是否是链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         last_shadow:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 缓冲区是否是影子缓冲区链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         temp_file:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否是临时文件</span><br>    <span class="hljs-comment">/* STUB */</span> <span class="hljs-type">int</span>   num;             <span class="hljs-comment">// 缓冲区编号（占位符）</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;               <span class="hljs-comment">// 缓冲区指针</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next;              <span class="hljs-comment">// 下一个链表节点指针</span><br>&#125; <span class="hljs-type">ngx_chain_t</span>;                        <span class="hljs-comment">// Nginx 链表节点结构体</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_int_t</span>    num;                <span class="hljs-comment">// 缓冲区数量</span><br>    <span class="hljs-type">size_t</span>       size;               <span class="hljs-comment">// 缓冲区大小</span><br>&#125; <span class="hljs-type">ngx_bufs_t</span>;                        <span class="hljs-comment">// 缓冲区参数结构体</span><br><br></code></pre></td></tr></table></figure>

<p>其中，ngx_chain_t 数据类型是与缓冲区类型 ngx_buf_t 相关的链表结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;  <span class="hljs-comment">/* 指向当前缓冲区 */</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next; <span class="hljs-comment">/* 指向下一个chain，形成chain链表 */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/05/25/xl8P7vMTdfLkWJO.png" srcset="/img/loading.gif" lazyload alt="chain链表"></p>
<h3 id="动态数组数据结构ngx-array-t"><a href="#动态数组数据结构ngx-array-t" class="headerlink" title="动态数组数据结构ngx_array_t"></a>动态数组数据结构ngx_array_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>        *elts;  <span class="hljs-comment">/* 指向数组数据区域的首地址 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nelts; <span class="hljs-comment">/* 数组实际数据的个数 */</span><br>    <span class="hljs-type">size_t</span>       size;  <span class="hljs-comment">/* 单个元素所占据的字节大小 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nalloc;<span class="hljs-comment">/* 数组容量 */</span><br>    <span class="hljs-type">ngx_pool_t</span>  *pool;  <span class="hljs-comment">/* 数组对象所在的内存池 */</span><br>&#125; <span class="hljs-type">ngx_array_t</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/05/25/A1FD3mMUQvSaGCi.png" srcset="/img/loading.gif" lazyload alt="动态数组"></p>
<p>整个动态数组的创建，使用，销毁过程中都是基于上文的内存池数据类型进行的。</p>
<h4 id="设计优点-1"><a href="#设计优点-1" class="headerlink" title="设计优点"></a>设计优点</h4><p>1，<strong>动态扩容</strong></p>
<ul>
<li><code>ngx_array_t</code> 是动态分配内存的，它的大小可以根据需要自动增长，而普通的数组在定义时就需要确定大小，无法动态改变大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_array_push(<span class="hljs-type">ngx_array_t</span> *a)<br>&#123;<br>    <span class="hljs-type">void</span>        *elt, *new;<br>    <span class="hljs-type">size_t</span>       size;<br>    <span class="hljs-type">ngx_pool_t</span>  *p;<br>    <br>    <span class="hljs-comment">//函数会检查数组是否已满（即已存储的元素个数 nelts 是否等于数组的容量 nalloc）。如果数组已满，则需要进行扩容操作：</span><br>    <span class="hljs-keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;<br><br>        <span class="hljs-comment">//计算当前数组的总大小（size = a-&gt;size * a-&gt;nalloc）</span><br>        size = a-&gt;size * a-&gt;nalloc;<br><br>        p = a-&gt;pool;<br>        <br>        <span class="hljs-comment">//检查内存池是否有足够的空间用于扩容，如果内存池的末尾可以容纳新的数组分配，并且内存池的末尾加上新的数组分配大小不会超出内存池的结束位置，则在内存池的末尾直接分配新的数组空间。</span><br>        <span class="hljs-keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last<br>            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)<br>        &#123;<br>            p-&gt;d.last += a-&gt;size;<br>            a-&gt;nalloc++;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果内存池无法容纳新的数组分配，则需要重新分配一个新的数组空间，大小是当前数组大小的两倍，并将原数组数据复制到新数组中。</span><br>            new = ngx_palloc(p, <span class="hljs-number">2</span> * size);<br>            <span class="hljs-keyword">if</span> (new == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            ngx_memcpy(new, a-&gt;elts, size);<br>            a-&gt;elts = new;<br>            a-&gt;nalloc *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后，将新元素添加到数组末尾，并更新已存储的元素个数 nelts。</span><br>    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;<br>    a-&gt;nelts++;<br><br>    <span class="hljs-keyword">return</span> elt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2，<strong>内存管理</strong></p>
<ul>
<li><code>ngx_array_t</code> 使用内存池进行内存分配，而不是直接调用系统的 <code>malloc()</code> 函数，这样可以减少内存碎片的产生，提高内存管理的效率。可以在内存池的生命周期内进行动态的内存分配和释放，而普通的数组需要手动管理内存的分配和释放。</li>
</ul>
<p>3，<strong>数组元数据</strong></p>
<ul>
<li><code>ngx_array_t</code> 中的 <code>nelts</code> 表示当前数组中实际存储的元素个数，<code>nalloc</code> 表示数组的容量（即分配的内存空间可以容纳的元素个数），通过这两个值可以确定数组的使用情况，从而进行动态的内存管理。</li>
</ul>
<h4 id="扩展视野"><a href="#扩展视野" class="headerlink" title="扩展视野"></a>扩展视野</h4><p>类似的自动扩容设计在redis上的动态字符串(sds)也有出现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br>    <span class="hljs-comment">//char数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/05/25/F7UquTgPlARjeX5.png" srcset="/img/loading.gif" lazyload alt="sds"></p>
<p>自动扩容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">sds _sdsMakeRoomFor(sds s, <span class="hljs-type">size_t</span> addlen, <span class="hljs-type">int</span> greedy) &#123;<br>    <span class="hljs-type">void</span> *sh, *newsh; <span class="hljs-comment">// 分别为原始字符串头部和新字符串头部的指针</span><br>    <span class="hljs-type">size_t</span> avail = sdsavail(s); <span class="hljs-comment">// 可用空间大小</span><br>    <span class="hljs-type">size_t</span> len, newlen, reqlen; <span class="hljs-comment">// 分别为字符串当前长度、新长度、所需长度</span><br>    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK; <span class="hljs-comment">// 分别为新类型和旧类型</span><br>    <span class="hljs-type">int</span> hdrlen; <span class="hljs-comment">// 头部长度</span><br>    <span class="hljs-type">size_t</span> usable; <span class="hljs-comment">// 实际可用空间大小</span><br><br>    <span class="hljs-comment">/* Return ASAP if there is enough space left. */</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 如果可用空间大于等于所需空间，则直接返回原字符串</span><br><br>    len = sdslen(s); <span class="hljs-comment">// 获取当前字符串长度</span><br>    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype); <span class="hljs-comment">// 计算原字符串头部位置</span><br>    reqlen = newlen = (len+addlen); <span class="hljs-comment">// 计算所需长度为当前长度加上新增长度</span><br>    assert(newlen &gt; len);   <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (greedy == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="hljs-comment">// 如果新长度小于最大预分配长度，则将新长度翻倍</span><br>            newlen *= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            newlen += SDS_MAX_PREALLOC; <span class="hljs-comment">// 否则直接增加最大预分配长度</span><br>    &#125;<br><br>    type = sdsReqType(newlen); <span class="hljs-comment">// 获取新类型</span><br><br>    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><br><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><br><span class="hljs-comment">     * at every appending operation. */</span><br>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8; <span class="hljs-comment">// 如果新类型为 5，则改为 8，因为 5 类型无法记录空闲空间</span><br><br>    hdrlen = sdsHdrSize(type); <span class="hljs-comment">// 计算新头部长度</span><br>    assert(hdrlen + newlen + <span class="hljs-number">1</span> &gt; reqlen);  <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (oldtype==type) &#123; <span class="hljs-comment">// 如果新旧类型相同</span><br>        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 重新分配空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><br><span class="hljs-comment">         * and can&#x27;t use realloc */</span><br>        newsh = s_malloc_usable(hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 分配新空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>); <span class="hljs-comment">// 将原字符串拷贝到新空间</span><br>        s_free(sh); <span class="hljs-comment">// 释放原空间</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>        s[<span class="hljs-number">-1</span>] = type; <span class="hljs-comment">// 更新新类型</span><br>        sdssetlen(s, len); <span class="hljs-comment">// 更新字符串长度</span><br>    &#125;<br>    usable = usable-hdrlen<span class="hljs-number">-1</span>; <span class="hljs-comment">// 计算实际可用空间</span><br>    <span class="hljs-keyword">if</span> (usable &gt; sdsTypeMaxSize(type)) <span class="hljs-comment">// 如果实际可用空间大于类型最大限制，则设置为类型最大限制</span><br>        usable = sdsTypeMaxSize(type);<br>    sdssetalloc(s, usable); <span class="hljs-comment">// 设置字符串实际分配空间大小</span><br>    <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 返回更新后的字符串</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="链表数据结构-ngx-list-t"><a href="#链表数据结构-ngx-list-t" class="headerlink" title="链表数据结构 ngx_list_t"></a>链表数据结构 ngx_list_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_list_part_s，并将其别名定义为 ngx_list_part_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span>  <span class="hljs-title">ngx_list_part_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_list_part_s。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span> &#123;</span><br>    <span class="hljs-type">void</span>             *elts;   <span class="hljs-comment">// 指向元素的指针，每个元素的类型未指定。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nelts;  <span class="hljs-comment">// 当前存储的元素个数。</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *next;   <span class="hljs-comment">// 指向下一个链表部分的指针。</span><br>&#125;;<br><br><span class="hljs-comment">// 定义一个链表结构 ngx_list_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *last;    <span class="hljs-comment">// 指向链表的最后一个部分的指针。</span><br>    <span class="hljs-type">ngx_list_part_t</span>   part;    <span class="hljs-comment">// 链表的第一个部分，包含元素和指向下一个部分的指针。</span><br>    <span class="hljs-type">size_t</span>            size;    <span class="hljs-comment">// 每个元素的大小。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nalloc;  <span class="hljs-comment">// 每个部分可以存储的元素个数。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;    <span class="hljs-comment">// 指向内存池的指针，用于分配链表部分的内存。</span><br>&#125; <span class="hljs-type">ngx_list_t</span>;<br></code></pre></td></tr></table></figure>

<p>链表数据结构如下图所示：</p>
<p><img src="https://s2.loli.net/2024/05/25/ADgYxOuqIMfl2nJ.png" srcset="/img/loading.gif" lazyload alt="nginx链表"></p>
<p>链表主要函数:</p>
<p><img src="https://s2.loli.net/2024/05/25/ZbEYmN4V7nW9cJH.png" srcset="/img/loading.gif" lazyload alt="image-20240524181000980"></p>
<p>需要注意的是：由于链表的内存分配是基于内存池，所有内存的销毁由内存池进行，即链表没有销毁操作。</p>
<p>其中主要是的内存分配函数就是*<em>ngx_palloc(ngx_pool_t <em>pool, size_t size)</em></em></p>
<h4 id="基础巩固-2"><a href="#基础巩固-2" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><h5 id="什么是static？"><a href="#什么是static？" class="headerlink" title="什么是static？"></a>什么是static？</h5><h4 id="1-static-变量"><a href="#1-static-变量" class="headerlink" title="1.  static 变量"></a>1.  static 变量</h4><ul>
<li><p><strong>在函数内</strong>：</p>
<ul>
<li>当 <code>static</code> 变量在函数内部声明时，它是一个局部变量，但与普通局部变量不同的是，它的生命周期是整个程序运行期间。它只在第一次执行到声明语句时初始化，以后即使函数多次调用也不会重新初始化，并且其值在函数调用之间保持不变。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只在第一次调用时初始化</span><br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>在文件作用域内</strong>：</p>
<ul>
<li>当 <code>static</code> 变量在文件的顶层（即不在任何函数内）声明时，它的作用域仅限于该文件。它不能被其他文件访问，即使在其他文件中有相同名字的变量也不会冲突。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> global_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只能在该文件中访问</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-static-函数"><a href="#2-static-函数" class="headerlink" title="2. static 函数"></a>2. <code>static</code> 函数</h4><ul>
<li><p>在文件作用域内：</p>
<ul>
<li>当 <code>static</code> 函数在文件中定义时，它的作用域也仅限于该文件。其他文件不能调用这个函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">helper_function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只能在该文件中调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="什么是inline"><a href="#什么是inline" class="headerlink" title="什么是inline?"></a>什么是inline?</h5><h4 id="1-inline-函数"><a href="#1-inline-函数" class="headerlink" title="1. inline 函数"></a>1. <code>inline</code> 函数</h4><ul>
<li><p>在函数声明前使用 <code>inline</code>：</p>
<ul>
<li><code>inline</code> 关键字用于建议编译器在调用函数时将函数体内联展开，而不是进行正常的函数调用。这样可以减少函数调用的开销，尤其是在小函数和频繁调用的情况下。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>需要注意的是，<code>inline</code> 只是一个建议，编译器可能会忽略它，特别是当函数体太大或者包含复杂的逻辑时。</li>
</ul>
</li>
</ul>
<h4 id="2-inline-和多重定义"><a href="#2-inline-和多重定义" class="headerlink" title="2. inline 和多重定义"></a>2. <code>inline</code> 和多重定义</h4><ul>
<li><p>在头文件中定义 <code>inline</code> 函数：</p>
<ul>
<li>当 <code>inline</code> 函数在头文件中定义并在多个源文件中包含时，通常不会导致重复定义错误，因为每个源文件的 <code>inline</code> 函数都被认为是独立的。编译器会处理这种情况以避免链接错误。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// header.h</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="队列链表结构ngx-queue-t"><a href="#队列链表结构ngx-queue-t" class="headerlink" title="队列链表结构ngx_queue_t"></a>队列链表结构ngx_queue_t</h3><p><img src="https://s2.loli.net/2024/05/25/jXQoYbiV8NpS7s1.png" srcset="/img/loading.gif" lazyload alt="队列链表"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_queue_s，并将其别名定义为 ngx_queue_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span>  <span class="hljs-title">ngx_queue_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_queue_s，用于实现双向循环链表。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span>  *prev; <span class="hljs-comment">// 指向前一个队列节点的指针</span><br>    <span class="hljs-type">ngx_queue_t</span>  *next; <span class="hljs-comment">// 指向下一个队列节点的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过观察ngx_queue_s结构体可以看出与我们普通的双向链表的区别在于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义双向链表节点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 指向前一个节点的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一个节点的指针</span><br>&#125; Node;<br></code></pre></td></tr></table></figure>

<p>1.这里的双向链表中的节点是没有数据区的，只有两个指向节点的指针</p>
<p>2.同样队列链表时选择不使用内存池管理</p>
<p>个人认为这样的设计主要从这几各方面考虑：</p>
<ol>
<li><strong>节省内存</strong>：在某些情况下，队列节点本身并不需要携带数据，而只需包含指向数据的指针。如果每个节点都分配一定大小的数据区域，将会造成内存浪费。通过不为节点分配数据区域，可以节省内存，并使得队列更加轻量级。</li>
<li><strong>减少数据拷贝</strong>：通过在节点中存储指向数据的指针，而不是存储数据本身，可以减少数据在内存中的拷贝次数。这对于处理大量数据或频繁操作数据的场景下，能够提高性能和效率。</li>
<li><strong>灵活性</strong>：将数据存储在节点外部，允许队列节点更通用。这样设计使得节点可以存储不同类型的数据，从而提高了队列的灵活性。这样的设计适用于 Nginx 中很多情况下需要处理各种类型数据的场景。</li>
<li>内存池适用于大量的、相对固定大小的对象分配，例如 HTTP 请求和响应的内存管理。但对于一些特殊的数据结构，如队列链表，其大小不固定，每个节点的内存消耗可能不同，因此直接使用内存池可能不够灵活。</li>
</ol>
<p>当然，在使用时这种节点通常与实际数据结构结合使用，通过嵌入 <code>ngx_queue_t</code> 结构体来实现链表操作。例如，一个实际的数据结构可能如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">// 嵌入 ngx_queue_t 用于链表操作</span><br>    <span class="hljs-type">int</span> data;          <span class="hljs-comment">// 实际数据</span><br>&#125; <span class="hljs-type">my_data_t</span>;<br><br></code></pre></td></tr></table></figure>

<h3 id="哈希表结构ngx-hash-t"><a href="#哈希表结构ngx-hash-t" class="headerlink" title="哈希表结构ngx_hash_t"></a>哈希表结构ngx_hash_t</h3><h4 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表?"></a>什么是哈希表?</h4><p>哈希表（Hash Table）是一种用于实现关联数组（键值对存储）的数据结构。它利用哈希函数将键映射到表中的位置，从而实现快速的数据存取。哈希表支持高效的插入、删除和查找操作，通常时间复杂度为O(1)。</p>
<p><strong>哈希表的基本概念</strong></p>
<ol>
<li><strong>键（Key）和值（Value）</strong>：哈希表通过键来存储和检索相应的值。</li>
<li><strong>哈希函数（Hash Function）</strong>：将键转换为哈希值（通常是一个整数），然后用这个哈希值确定在表中的位置。</li>
<li><strong>哈希冲突（Hash Collision）</strong>：不同的键可能会映射到同一个位置，这种情况称为冲突。哈希表需要处理冲突以确保每个键值对都能被正确存储和访问。</li>
</ol>
<p><strong>哈希表的结构</strong></p>
<p>哈希表通常由一个数组和一个哈希函数组成。数组的每个位置称为一个桶（bucket）。</p>
<p><strong>哈希冲突解决方法</strong></p>
<ol>
<li><strong>链地址法（Chaining）</strong>：每个桶中存储一个链表，所有映射到同一桶的元素都放入这个链表中。</li>
<li><strong>开放地址法（Open Addressing）</strong>：当冲突发生时，寻找下一个空桶来存储元素。常见的探查方式包括线性探查、二次探查和双重哈希。</li>
</ol>
<p><img src="https://s2.loli.net/2024/05/25/6STaUCZkpLjY1IR.png" srcset="/img/loading.gif" lazyload alt="hashtab"></p>
<p>接着我们来看nginx是如何设计哈希表的。</p>
<p><img src="https://s2.loli.net/2024/05/25/ezxEjR6AU8utkWT.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以看出nginx的哈希表是由三层结构组成而来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在哈希表中的值，可以是任何类型。</span><br>    u_short           len;       <span class="hljs-comment">// name字段的长度。</span><br>    u_char            name[<span class="hljs-number">1</span>];   <span class="hljs-comment">// 键的第一个字符，后续的字符在分配时动态决定，这是一个灵活数组成员。</span><br>&#125; <span class="hljs-type">ngx_hash_elt_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_elt_t</span>  **buckets;   <span class="hljs-comment">// 指向哈希表桶数组的指针，每个桶是一个链表的头节点。</span><br>    <span class="hljs-type">ngx_uint_t</span>        size;      <span class="hljs-comment">// 哈希表中桶的数量。</span><br>&#125; <span class="hljs-type">ngx_hash_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>        hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在通配符哈希表中的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_wildcard_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_str_t</span>         key;       <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_uint_t</span>        key_hash;  <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 与键关联的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_key_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">ngx_uint_t</span> <span class="hljs-params">(*ngx_hash_key_pt)</span> <span class="hljs-params">(u_char *data, <span class="hljs-type">size_t</span> len)</span>;  <span class="hljs-comment">// 函数指针类型，指向一个哈希函数，该函数接受一个字符数组（键）和其长度作为参数，返回一个无符号整数类型的哈希值。</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>            hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_head;   <span class="hljs-comment">// 指向通配符哈希表的头部。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_tail;   <span class="hljs-comment">// 指向通配符哈希表的尾部。</span><br>&#125; <span class="hljs-type">ngx_hash_combined_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>       *hash;         <span class="hljs-comment">// 指向一个ngx_hash_t结构的指针，用于存储初始化后的哈希表。</span><br>    ngx_hash_key_pt   key;          <span class="hljs-comment">// 指向一个哈希函数的指针，用于计算键的哈希值。</span><br><br>    <span class="hljs-type">ngx_uint_t</span>        max_size;     <span class="hljs-comment">// 哈希表允许的最大键数量。</span><br>    <span class="hljs-type">ngx_uint_t</span>        bucket_size;  <span class="hljs-comment">// 每个桶的大小。</span><br><br>    <span class="hljs-type">char</span>             *name;         <span class="hljs-comment">// 哈希表的名称，用于调试或日志记录。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;         <span class="hljs-comment">// 指向一个内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;    <span class="hljs-comment">// 指向一个临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br>&#125; <span class="hljs-type">ngx_hash_init_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hsize;              <span class="hljs-comment">// 哈希表的大小，即桶的数量。</span><br><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;               <span class="hljs-comment">// 内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;          <span class="hljs-comment">// 临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       keys;               <span class="hljs-comment">// 存储普通键的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *keys_hash;          <span class="hljs-comment">// 指向哈希表中的普通键数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_head;        <span class="hljs-comment">// 存储DNS通配符键（头部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_head_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（头部）数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_tail;        <span class="hljs-comment">// 存储DNS通配符键（尾部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_tail_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（尾部）数组。</span><br>&#125; <span class="hljs-type">ngx_hash_keys_arrays_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span>  <span class="hljs-title">ngx_table_elt_t</span>;</span>  <span class="hljs-comment">// 前向声明结构类型ngx_table_elt_t。</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hash;           <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">ngx_str_t</span>         key;            <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_str_t</span>         value;          <span class="hljs-comment">// 与键关联的值，字符串类型。</span><br>    u_char           *lowcase_key;    <span class="hljs-comment">// 存储小写形式的键，用于不区分大小写的查找。</span><br>    <span class="hljs-type">ngx_table_elt_t</span>  *next;           <span class="hljs-comment">// 指向下一个元素的指针，形成链表，用于处理哈希冲突。</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>注意：Nginx 的哈希表设计主要是为了高效地存储和查找键值对。</p>
<h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作:"></a>初始化操作:</h4><p>hash 初始化由 ngx_hash_init() 函数完成，其 names 参数是 ngx_hash_key_t 结构的数组，即键-值对 &lt;key,value&gt; 数组，nelts 表示该数组元素的个数。该函数初始化的结果就是将 names 数组保存的键-值对&lt;key,value&gt;，通过 hash 的方式将其存入相应的一个或多个 hash 桶(即代码中的 buckets )中。hash 桶里面存放的是 ngx_hash_elt_t 结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。该数据区中存放的是经 hash 之后的键-值对&lt;key’,value’&gt;，即 ngx_hash_elt_t 结构中的字段 &lt;name,value&gt;。每一个这样的数据区存放的键-值对&lt;key’,value’&gt;可以是一个或多个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</span><br><span class="hljs-meta">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span><br><br><span class="hljs-comment">/* 初始化hash结构函数 */</span><br><span class="hljs-comment">/* 参数hinit是hash表初始化结构指针；</span><br><span class="hljs-comment"> * name是指向待添加在hash表结构的元素数组；</span><br><span class="hljs-comment"> * nelts是待添加元素数组中元素的个数；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_hash_init</span><span class="hljs-params">(<span class="hljs-type">ngx_hash_init_t</span> *hinit, <span class="hljs-type">ngx_hash_key_t</span> *names, <span class="hljs-type">ngx_uint_t</span> nelts)</span><br>&#123;<br>    u_char          *elts;<br>    <span class="hljs-type">size_t</span>           len;<br>    u_short         *test;<br>    <span class="hljs-type">ngx_uint_t</span>       i, n, key, size, start, bucket_size;<br>    <span class="hljs-type">ngx_hash_elt_t</span>  *elt, **buckets;<br><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-comment">/* 若每个桶bucket的内存空间不足以存储一个关键字元素，则出错返回</span><br><span class="hljs-comment">         * 这里考虑到了每个bucket桶最后的null指针所需的空间，即该语句中的sizeof(void *)，</span><br><span class="hljs-comment">         * 该指针可作为查找过程中的结束标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *))<br>        &#123;<br>            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;could not build the %s, you should &quot;</span><br>                          <span class="hljs-string">&quot;increase %s_bucket_size: %i&quot;</span>,<br>                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 临时分配sizeof(u_short)*max_size的test空间，即test数组总共有max_size个元素，即最大bucket的数量，</span><br><span class="hljs-comment">     * 每个元素会累计落到相应hash表位置的关键字长度，</span><br><span class="hljs-comment">     * 当大于256字节，即u_short所表示的字节大小，</span><br><span class="hljs-comment">     * 则表示bucket较少</span><br><span class="hljs-comment">     */</span><br>    test = ngx_alloc(hinit-&gt;max_size * <span class="hljs-keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>);<br>    <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">/* 每个bucket桶实际容纳的数据大小，</span><br><span class="hljs-comment">     * 由于每个bucket的末尾结束标志是null，</span><br><span class="hljs-comment">     * 所以bucket实际容纳的数据大小必须减去一个指针所占的内存大小</span><br><span class="hljs-comment">     */</span><br>    bucket_size = hinit-&gt;bucket_size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br><br>    <span class="hljs-comment">/* 估计hash表最少bucket数量；</span><br><span class="hljs-comment">     * 每个关键字元素需要的内存空间是 NGX_HASH_ELT_SIZE(&amp;name[n])，至少需要占用两个指针的大小即2*sizeof(void *)</span><br><span class="hljs-comment">     * 这样来估计hash表所需的最小bucket数量</span><br><span class="hljs-comment">     * 因为关键字元素内存越小，则每个bucket所容纳的关键字元素就越多</span><br><span class="hljs-comment">     * 那么hash表的bucket所需的数量就越少，但至少需要一个bucket</span><br><span class="hljs-comment">     */</span><br>    start = nelts / (bucket_size / (<span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)));<br>    start = start ? start : <span class="hljs-number">1</span>;<br><br>    <br>    <span class="hljs-keyword">if</span> (hinit-&gt;max_size &gt; <span class="hljs-number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="hljs-number">100</span>) &#123;<br>        start = hinit-&gt;max_size - <span class="hljs-number">1000</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 以前面估算的最小bucket数量start，通过测试数组test估算hash表容纳 nelts个关键字元素所需的bucket数量</span><br><span class="hljs-comment">     * 根据需求适当扩充bucket的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;<br><br>        ngx_memzero(test, size * <span class="hljs-keyword">sizeof</span>(u_short));<br><br>        <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>            <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 根据关键字元素的hash值计算存在到测试数组test对应的位置中，即计算bucket在hash表中的编号key,key取值为0～size-1 */</span><br>            key = names[n].key_hash % size;<br>            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %ui %ui \&quot;%V\&quot;&quot;</span>,<br>                          size, key, test[key], &amp;names[n].key);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* test数组中对应的内存大于每个桶bucket最大内存，则需扩充bucket的数量</span><br><span class="hljs-comment">             * 即在start的基础上继续增加size的值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;<br>                <span class="hljs-keyword">goto</span> next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 若size个bucket桶可以容纳name数组的所有关键字元素，则表示找到合适的bucket数量大小即为size */</span><br>        <span class="hljs-keyword">goto</span> found;<br><br>    next:<br><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                  <span class="hljs-string">&quot;could not build optimal %s, you should increase &quot;</span><br>                  <span class="hljs-string">&quot;either %s_max_size: %i or %s_bucket_size: %i; &quot;</span><br>                  <span class="hljs-string">&quot;ignoring %s_bucket_size&quot;</span>,<br>                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,<br>                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);<br><br>found:<br><br>    <span class="hljs-comment">/* 到此已经找到合适的bucket数量，即为size</span><br><span class="hljs-comment">     * 重新初始化test数组元素，初始值为一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br>    &#125;<br><br>    <span class="hljs-comment">/* 计算每个bucket中关键字所占的空间，即每个bucket实际所容纳数据的大小，</span><br><span class="hljs-comment">     * 必须注意的是：test[i]中还有一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 根据hash值计算出关键字放在对应的test[key]中，即test[key]的大小增加一个关键字元素的大小 */</span><br>        key = names[n].key_hash % size;<br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 调整成对齐到cacheline的大小，并记录所有元素的总长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));<br><br>        len += test[i];<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 向内存池申请bucket元素所占的内存空间，</span><br><span class="hljs-comment">     * 注意：若前面没有申请hash表头结构，则在这里将和ngx_hash_wildcard_t一起申请</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>)<br>                                             + size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">/* 计算buckets的起始位置 */</span><br>        buckets = (<span class="hljs-type">ngx_hash_elt_t</span> **)<br>                      ((u_char *) hinit-&gt;hash + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>));<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (buckets == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 分配elts，对齐到cacheline大小 */</span><br>    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);<br>    <span class="hljs-keyword">if</span> (elts == <span class="hljs-literal">NULL</span>) &#123;<br>        ngx_free(test);<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    elts = ngx_align_ptr(elts, ngx_cacheline_size);<br><br>    <span class="hljs-comment">/* 将buckets数组与相应的elts对应起来，即设置每个bucket对应实际数据的地址 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        buckets[i] = (<span class="hljs-type">ngx_hash_elt_t</span> *) elts;<br>        elts += test[i];<br><br>    &#125;<br><br>    <span class="hljs-comment">/* 清空test数组，以便用来累计实际数据的长度，这里不计算结尾指针的长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 依次向各个bucket中填充实际数据 */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        key = names[n].key_hash % size;<br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);<br><br>        elt-&gt;value = names[n].value;<br>        elt-&gt;len = (u_short) names[n].key.len;<br><br>        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);<br><br>        <span class="hljs-comment">/* test[key]记录当前bucket内容的填充位置，即下一次填充的起始位置 */</span><br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 设置bucket结束位置的null指针 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);<br><br>        elt-&gt;value = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ngx_free(test);<br><br>    hinit-&gt;hash-&gt;buckets = buckets;<br>    hinit-&gt;hash-&gt;size = size;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-type">ngx_str_t</span>   val;<br>        <span class="hljs-type">ngx_uint_t</span>  key;<br><br>        elt = buckets[i];<br><br>        <span class="hljs-keyword">if</span> (elt == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: NULL&quot;</span>, i);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (elt-&gt;value) &#123;<br>            val.len = elt-&gt;len;<br>            val.data = &amp;elt-&gt;name[<span class="hljs-number">0</span>];<br><br>            key = hinit-&gt;key(val.data, val.len);<br><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %p \&quot;%V\&quot; %ui&quot;</span>, i, elt, &amp;val, key);<br><br>            elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="hljs-number">0</span>] + elt-&gt;len,<br>                                                   <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="查找操作—-ngx-hash-find"><a href="#查找操作—-ngx-hash-find" class="headerlink" title="查找操作—-&gt;ngx_hash_find"></a>查找操作—-&gt;ngx_hash_find</h4><img src="https://s2.loli.net/2024/05/25/gt5cvWXzsrhHKYm.png" srcset="/img/loading.gif" lazyload alt="image-20240525123018812" style="zoom: 33%;" />

<p><strong>处理链表</strong>：在哈希表中，哈希桶可能是通过链表实现的。在遍历链表时，需要确保从正确的位置开始访问下一个元素。由于每个元素的长度不固定（因为键的长度不同），所以不能简单地使用固定的偏移量来访问下一个元素，而需要进行对齐操作以确保指针的正确位置。</p>
<p>其中注意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span><br><span class="hljs-meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>宏的实现逻辑如下：</p>
<p>将指针 p 转换为 uintptr_t 类型，以获取指针的无符号整数表示。<br>将对齐方式 a 减 1，得到比对齐方式小一个单位的值。<br>将指针加上 a - 1 的值，相当于向上取整到最近的对齐倍数。<br>使用按位与操作符 &amp; 将结果与 ~(a - 1) 进行按位与运算，将低位的偏移部分清零，从而实现对齐到指定的对齐方式。<br>最后将结果转换回 u_char * 类型，并返回对齐后的指针。</p>
</blockquote>
<h3 id="红黑树结构-ngx-rbtree-t"><a href="#红黑树结构-ngx-rbtree-t" class="headerlink" title="红黑树结构 ngx_rbtree_t"></a>红黑树结构 ngx_rbtree_t</h3><p><strong>附上红黑树的四条规则：</strong></p>
<ul>
<li>必须为二叉搜索树（左&lt;根&lt;右）</li>
<li>根和叶子结点都是黑色</li>
<li>不存在连续的两个红色结点</li>
<li>任意到根节点路径上的黑色结点数目相同</li>
</ul>
<p><strong>红黑树删除结点流程：</strong></p>
<p><img src="https://s2.loli.net/2024/05/25/wt4UXuV2s6z7v51.png" srcset="/img/loading.gif" lazyload alt="image-20240525151542705"></p>
<h5 id="红黑树结构"><a href="#红黑树结构" class="headerlink" title="红黑树结构"></a>红黑树结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span>  <span class="hljs-title">ngx_rbtree_node_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_key_t</span>       key;     <span class="hljs-comment">/* 节点的键值 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *left;    <span class="hljs-comment">/* 节点的左孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *right;   <span class="hljs-comment">/* 节点的右孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *parent;  <span class="hljs-comment">/* 节点的父亲 */</span><br>    u_char                 color;   <span class="hljs-comment">/* 节点的颜色 */</span><br>    u_char                 data;    <span class="hljs-comment">/* */</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span>  <span class="hljs-title">ngx_rbtree_t</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_rbtree_insert_pt)</span> <span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *root,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span>;<br><br><span class="hljs-comment">/* 红黑树结构 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *root;    <span class="hljs-comment">/* 指向树的根节点 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *sentinel;<span class="hljs-comment">/* 指向树的叶子节点NIL */</span><br>    ngx_rbtree_insert_pt   insert;  <span class="hljs-comment">/* 添加元素节点的函数指针，解决具有相同键值，但不同颜色节点的冲突问题；</span><br><span class="hljs-comment">                                     * 该函数指针决定新节点的行为是新增还是替换原始某个节点*/</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h4><h5 id="初始化操作-1"><a href="#初始化操作-1" class="headerlink" title="初始化操作"></a>初始化操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 给节点着色，1表示红色，0表示黑色  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_red(node)               ((node)-&gt;color = 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_black(node)             ((node)-&gt;color = 0)</span><br><span class="hljs-comment">/* 判断节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_red(node)            ((node)-&gt;color)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_black(node)          (!ngx_rbt_is_red(node))</span><br><span class="hljs-comment">/* 复制某个节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_copy_color(n1, n2)      (n1-&gt;color = n2-&gt;color)</span><br><br><span class="hljs-comment">/* 节点着黑色的宏定义 */</span><br><span class="hljs-comment">/* a sentinel must be black */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_sentinel_init(node)  ngx_rbt_black(node)</span><br><br><span class="hljs-comment">/* 初始化红黑树，即为空的红黑树 */</span><br><span class="hljs-comment">/* tree 是指向红黑树的指针，</span><br><span class="hljs-comment"> * s 是红黑树的一个NIL节点，</span><br><span class="hljs-comment"> * i 表示函数指针，决定节点是新增还是替换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_init(tree, s, i)                                           \</span><br><span class="hljs-meta">    ngx_rbtree_sentinel_init(s);                                              \</span><br><span class="hljs-meta">    (tree)-&gt;root = s;                                                         \</span><br><span class="hljs-meta">    (tree)-&gt;sentinel = s;                                                     \</span><br><span class="hljs-meta">    (tree)-&gt;insert = i</span><br><br></code></pre></td></tr></table></figure>

<h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><p>同平衡二叉树(AVL)的旋转逻辑相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 左旋转操作 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_left_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;right;<span class="hljs-comment">/* temp为node节点的右孩子 */</span><br>    node-&gt;right = temp-&gt;left;<span class="hljs-comment">/* 设置node节点的右孩子为temp的左孩子 */</span><br><br>    <span class="hljs-keyword">if</span> (temp-&gt;left != sentinel) &#123;<br>        temp-&gt;left-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>        node-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    temp-&gt;left = node;<br>    node-&gt;parent = temp;<br>&#125;<br><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_right_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;left;<br>    node-&gt;left = temp-&gt;right;<br><br>    <span class="hljs-keyword">if</span> (temp-&gt;right != sentinel) &#123;<br>        temp-&gt;right-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>        node-&gt;parent-&gt;right = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;left = temp;<br>    &#125;<br><br>    temp-&gt;right = node;<br>    node-&gt;parent = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取红黑树键值最小的节点 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">ngx_rbtree_node_t</span> *<br><span class="hljs-title function_">ngx_rbtree_min</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (node-&gt;left != sentinel) &#123;<br>        node = node-&gt;left;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">/* 插入节点 */</span><br><span class="hljs-comment">/* 插入节点的步骤：</span><br><span class="hljs-comment"> * 1、首先按照二叉查找树的插入操作插入新节点；</span><br><span class="hljs-comment"> * 2、然后把新节点着色为红色（避免破坏红黑树性质5）；</span><br><span class="hljs-comment"> * 3、为维持红黑树的性质，调整红黑树的节点（着色并旋转），使其满足红黑树的性质；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *temp, *sentinel;<br><br>    <span class="hljs-comment">/* a binary tree insert */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 若红黑树为空，则比较简单，把新节点作为根节点，</span><br><span class="hljs-comment">     * 并初始化该节点使其满足红黑树性质</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (*root == sentinel) &#123;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;left = sentinel;<br>        node-&gt;right = sentinel;<br>        ngx_rbt_black(node);<br>        *root = node;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若红黑树不为空，则按照二叉查找树的插入操作进行</span><br><span class="hljs-comment">     * 该操作由函数指针提供</span><br><span class="hljs-comment">     */</span><br>    tree-&gt;insert(*root, node, sentinel);<br><br>    <span class="hljs-comment">/* re-balance tree */</span><br><br>    <span class="hljs-comment">/* 调整红黑树，使其满足性质，</span><br><span class="hljs-comment">     * 其实这里只是破坏了性质4：若一个节点是红色，则孩子节点都为黑色；</span><br><span class="hljs-comment">     * 若破坏了性质4，则新节点 node 及其父亲节点 node-&gt;parent 都为红色；</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (node != *root &amp;&amp; ngx_rbt_is_red(node-&gt;parent)) &#123;<br><br>        <span class="hljs-comment">/* 若node的父亲节点是其祖父节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left) &#123;<br>            temp = node-&gt;parent-&gt;parent-&gt;right;<span class="hljs-comment">/* temp节点为node的叔叔节点 */</span><br><br>            <span class="hljs-comment">/* case1：node的叔叔节点是红色 */</span><br>            <span class="hljs-comment">/* 此时，node的父亲及叔叔节点都为红色；</span><br><span class="hljs-comment">             * 解决办法：将node的父亲及叔叔节点着色为黑色，将node祖父节点着色为红色；</span><br><span class="hljs-comment">             * 然后沿着祖父节点向上判断是否会破会红黑树的性质；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* case2：node的叔叔节点是黑色且node是父亲节点的右孩子 */</span><br>                <span class="hljs-comment">/* 则此时，以node父亲节点进行左旋转，使case2转变为case3；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_left_rotate(root, sentinel, node);<br>                &#125;<br><br>                <span class="hljs-comment">/* case3：node的叔叔节点是黑色且node是父亲节点的左孩子 */</span><br>                <span class="hljs-comment">/* 首先，将node的父亲节点着色为黑色，祖父节点着色为红色；</span><br><span class="hljs-comment">                 * 然后以祖父节点进行一次右旋转；</span><br><span class="hljs-comment">                 */</span><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 若node的父亲节点是其祖父节点的右孩子 */</span><br>            <span class="hljs-comment">/* 这里跟上面的情况是对称的，就不再进行讲解了</span><br><span class="hljs-comment">             */</span><br>            temp = node-&gt;parent-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_right_rotate(root, sentinel, node);<br>                &#125;<br><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根节点必须为黑色 */</span><br>    ngx_rbt_black(*root);<br>&#125;<br><br><span class="hljs-comment">/* 这里只是将节点插入到红黑树中，并没有判断是否满足红黑树的性质；</span><br><span class="hljs-comment"> * 类似于二叉查找树的插入操作，这个函数为红黑树插入操作的函数指针；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/* 判断node节点键值与temp节点键值的大小，以决定node插入到temp节点的左子树还是右子树 */</span><br>        p = (node-&gt;key &lt; temp-&gt;key) ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    <span class="hljs-comment">/* 初始化node节点，并着色为红色 */</span><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_timer_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Timer values</span><br><span class="hljs-comment">         * 1) are spread in small range, usually several minutes,</span><br><span class="hljs-comment">         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.</span><br><span class="hljs-comment">         * The comparison takes into account that overflow.</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*  node-&gt;key &lt; temp-&gt;key */</span><br><br>        p = ((<span class="hljs-type">ngx_rbtree_key_int_t</span>) (node-&gt;key - temp-&gt;key) &lt; <span class="hljs-number">0</span>)<br>            ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 删除节点 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_delete</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_uint_t</span>           red;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *sentinel, *subst, *temp, *w;<br><br>    <span class="hljs-comment">/* a binary tree delete */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 下面是获取temp节点值，temp保存的节点是准备替换节点node ；</span><br><span class="hljs-comment">     * subst是保存要被替换的节点的后继节点；</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* case1：若node节点没有左孩子（这里包含了存在或不存在右孩子的情况）*/</span><br>    <span class="hljs-keyword">if</span> (node-&gt;left == sentinel) &#123;<br>        temp = node-&gt;right;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;right == sentinel) &#123;<span class="hljs-comment">/* case2：node节点存在左孩子，但是不存在右孩子 */</span><br>        temp = node-&gt;left;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case3：node节点既有左孩子，又有右孩子 */</span><br>        subst = ngx_rbtree_min(node-&gt;right, sentinel);<span class="hljs-comment">/* 获取node节点的后续节点 */</span><br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            temp = subst-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp = subst-&gt;right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若被替换的节点subst是根节点，则temp直接替换subst称为根节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == *root) &#123;<br>        *root = temp;<br>        ngx_rbt_black(temp);<br><br>        <span class="hljs-comment">/* DEBUG stuff */</span><br>        node-&gt;left = <span class="hljs-literal">NULL</span>;<br>        node-&gt;right = <span class="hljs-literal">NULL</span>;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;key = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* red记录subst节点的颜色 */</span><br>    red = ngx_rbt_is_red(subst);<br><br>    <span class="hljs-comment">/* temp节点替换subst 节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == subst-&gt;parent-&gt;left) &#123;<br>        subst-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        subst-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根据subst是否为node节点进行处理 */</span><br>    <span class="hljs-keyword">if</span> (subst == node) &#123;<br><br>        temp-&gt;parent = subst-&gt;parent;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;parent == node) &#123;<br>            temp-&gt;parent = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp-&gt;parent = subst-&gt;parent;<br>        &#125;<br><br>        <span class="hljs-comment">/* 复制node节点属性 */</span><br>        subst-&gt;left = node-&gt;left;<br>        subst-&gt;right = node-&gt;right;<br>        subst-&gt;parent = node-&gt;parent;<br>        ngx_rbt_copy_color(subst, node);<br><br>        <span class="hljs-keyword">if</span> (node == *root) &#123;<br>            *root = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                node-&gt;parent-&gt;left = subst;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;parent-&gt;right = subst;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            subst-&gt;left-&gt;parent = subst;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;right != sentinel) &#123;<br>            subst-&gt;right-&gt;parent = subst;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* DEBUG stuff */</span><br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    node-&gt;key = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (red) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 下面开始是调整红黑树的性质 */</span><br>    <span class="hljs-comment">/* a delete fixup */</span><br><br>    <span class="hljs-comment">/* 根据temp节点进行处理 ，若temp不是根节点且为黑色 */</span><br>    <span class="hljs-keyword">while</span> (temp != *root &amp;&amp; ngx_rbt_is_black(temp)) &#123;<br><br>        <span class="hljs-comment">/* 若temp是其父亲节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (temp == temp-&gt;parent-&gt;left) &#123;<br>            w = temp-&gt;parent-&gt;right;<span class="hljs-comment">/* w为temp的兄弟节点 */</span><br><br>            <span class="hljs-comment">/* case A：temp兄弟节点为红色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点及temp父亲节点的颜色；</span><br><span class="hljs-comment">             * 2、对temp父亲节的做一次左旋转，此时，temp的兄弟节点是旋转之前w的某个子节点，该子节点颜色为黑色；</span><br><span class="hljs-comment">             * 3、此时，case A已经转换为case B、case C 或 case D；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;right;<br>            &#125;<br><br>            <span class="hljs-comment">/* case B：temp的兄弟节点w是黑色，且w的两个子节点都是黑色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点的颜色；</span><br><span class="hljs-comment">             * 2、把temp的父亲节点作为新的temp节点；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case C：temp的兄弟节点是黑色，且w的左孩子是红色，右孩子是黑色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将改变w及其左孩子的颜色；</span><br><span class="hljs-comment">                 * 2、对w节点进行一次右旋转；</span><br><span class="hljs-comment">                 * 3、此时，temp新的兄弟节点w有着一个红色右孩子的黑色节点，转为case D；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;right)) &#123;<br>                    ngx_rbt_black(w-&gt;left);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_right_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;right;<br>                &#125;<br><br>                <span class="hljs-comment">/* case D：temp的兄弟节点w为黑色，且w的右孩子为红色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将w节点设置为temp父亲节点的颜色，temp父亲节点设置为黑色；</span><br><span class="hljs-comment">                 * 2、w的右孩子设置为黑色；</span><br><span class="hljs-comment">                 * 3、对temp的父亲节点做一次左旋转；</span><br><span class="hljs-comment">                 * 4、最后把根节点root设置为temp节点；*/</span><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;right);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 这里针对的是temp节点为其父亲节点的左孩子的情况 */</span><br>            w = temp-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;left;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left)) &#123;<br>                    ngx_rbt_black(w-&gt;right);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_left_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;left;<br>                &#125;<br><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;left);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ngx_rbt_black(temp);<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="category-chain-item">源码阅读</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Nginx/" class="category-chain-item">Nginx</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Nginx/" class="print-no-link">#Nginx</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Nginx数据结构</div>
      <div>http://example.com/2023/03/07/Nginx数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/08/Nginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97/" title="事件模块">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">事件模块</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/02/HTTP%E6%A8%A1%E5%9D%97/" title="HTTP模块">
                        <span class="hidden-mobile">HTTP模块</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
