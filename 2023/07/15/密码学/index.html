

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文旨在提供对密码学体系框架的了解，建立相对完善知识体系，对一些细节并没有事无巨细的进行阐述，如有纰漏错误，请多指正。  整体框架 简化版：  对称密码算法 机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”  对称加密算法是一种加密方法，使用相同的密钥进行数据的">
<meta property="og:type" content="article">
<meta property="og:title" content="密码学体系框架">
<meta property="og:url" content="http://example.com/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="本文旨在提供对密码学体系框架的了解，建立相对完善知识体系，对一些细节并没有事无巨细的进行阐述，如有纰漏错误，请多指正。  整体框架 简化版：  对称密码算法 机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”  对称加密算法是一种加密方法，使用相同的密钥进行数据的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1VLid.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1Vjzt.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/W9DUKLNB7dJ38Xj.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/ERrMZa2NTvubAde.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/vzXk1eYaCiBQAct.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/DJ8cU19IoROqPng.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/8MhbPmAsDTtaL5E.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/G1Bd4MJoiSKyfNj.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/5qpuD8Q1In4cUZ3.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/9FNmzsqhVan2OQI.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/MeJvXsjxan6qkQA.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/3cd9fdef1e1047d154a8c11bcfb898fa.png#pic_center">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/7ZtU198y4rswegB.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/XjW4mgapc6UZVGQ.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/jf1Xl6NpGMLJq48.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/YAac6FbnZWVQ8eH.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1VXRI.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/30/uF3ptzxAscLb419.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/30/AoLV8Z3K6BjaN5t.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/30/qZbOoz1IgD2wSsG.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/30/UFCKGxewkjE5VSN.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/30/aMchGDSPjz1pr8y.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/cB6mPfT4FY8opqz.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1VxQP.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/aUc9M5T7Avg46uq.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/22/FUx1TDnlH94KktQ.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1Z9eS.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1ZSL8.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1eT4H.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1eb8A.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1eqgI.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1mSUg.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1mp5Q.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1mCCj.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1mP8s.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/09/28/pA1mi2n.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/HyfBTmEteP3s1h6.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/2MSCtv1HZTLQg4o.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/5ed7f15772e4ddc5d23f140f85027b53.gif">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/23a5f8b290dde5116088d13bad292457.gif">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/21ld5pgQmVKWs3t.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/xurShl8HjsMXFZN.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/PG2V5SeEJ4IvfxH.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/p4hcDSjUk9e3YG2.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/2XDcgNFAbvwBxmG.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/wTA6OfE2Yb4lJ5H.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/SYcCjgi3HDQW2pN.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/xBK6a4djoQMH5tV.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/1Ao9rcevbuyjOtM.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/PH7kIDdAfOyKMSc.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/09/29/DafG4M9qZjzh1LC.png">
<meta property="article:published_time" content="2023-07-15T01:18:02.000Z">
<meta property="article:modified_time" content="2025-03-09T09:14:50.724Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="密码学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg">
  
  
  
  <title>密码学体系框架 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="密码学体系框架"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-15 09:18" pubdate>
          2023年7月15日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          152 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">密码学体系框架</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本文旨在提供对密码学体系框架的了解，建立相对完善知识体系，对一些细节并没有事无巨细的进行阐述，如有纰漏错误，请多指正。</p>
</blockquote>
<h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img src="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg" srcset="/img/loading.gif" lazyload alt="1"></p>
<p>简化版：</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1VLid.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<h1 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h1><blockquote>
<p>机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”</p>
</blockquote>
<p>对称加密算法是一种加密方法，使用相同的密钥进行数据的加密和解密。发送方和接收方必须共享同一个密钥，以便于对数据进行加密和解密。对称加密算法通常速度较快，适用于大数据量的加密。这其中又因为应用场景不同又分为分块加密和流加密。</p>
<p>分组加密将数据分为固定大小的块逐块加密，适合大数据量，如文件加密；流加密则逐字节加密，适合实时数据传输，如音视频流。分组加密速度较慢，流加密较快，但流加密在错误传播时影响更大。</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1Vjzt.png" srcset="/img/loading.gif" lazyload alt="image-20240928180400857"></p>
<h2 id="分组密码算法-Block-cipher"><a href="#分组密码算法-Block-cipher" class="headerlink" title="分组密码算法(Block cipher)"></a>分组密码算法(Block cipher)</h2><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><blockquote>
<p>pdf源于B站:<a target="_blank" rel="noopener" href="https://www.alipan.com/s/nZN1ABDPfGf">https://www.alipan.com/s/nZN1ABDPfGf</a> 提取码: sw76 </p>
<p>有关的数学知识参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎</a></p>
</blockquote>
<p>由于DES加密算法被破解了，3DES加密算法虽然没有被破解，但是3DES算法的加解密效率低，所有现在都使用AES算法。<br>AES加密算法是密码学中的高级加密标准，AES为分组加密法，把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能是128位，AES是按照字节进行加密的，也就是说每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。这导致密钥长度不同，推荐加密的轮数也不同。</p>
<p>其加密过程如下：(解密过程同理)</p>
<p><img src="https://s2.loli.net/2024/12/22/W9DUKLNB7dJ38Xj.png" srcset="/img/loading.gif" lazyload alt="image-20241222153104837"></p>
<h4 id="初识变换"><a href="#初识变换" class="headerlink" title="初识变换"></a>初识变换</h4><img src="https://s2.loli.net/2024/12/22/ERrMZa2NTvubAde.png" srcset="/img/loading.gif" lazyload alt="image-20241222153413982" style="zoom:50%;" />

<p>其中初识变换是对其做按字节异或操作：</p>
<img src="https://s2.loli.net/2024/12/22/vzXk1eYaCiBQAct.png" srcset="/img/loading.gif" lazyload alt="image-20241222153444413" style="zoom:50%;" />

<h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>属于非线性替换，具体原理就是通过一个替换表（S盒）对每个字节进行替换，实际上就是一个查表操作，并且此过程可逆，将每一个字节的前4位作为行值，后4位作为列值，去S盒查找，进行输出。<br>下图为S盒（x表示行，y表示列），例如字节为0x14，那么前四位的16进制为1，后四位的16进制为4，去查找s盒中的第1行第4列的值，可以看出为0xfa，就把原先的字节0x14替换为0xfa。解密过程与此相同，唯一就是采用的是逆S盒。</p>
<p><img src="https://s2.loli.net/2024/12/22/DJ8cU19IoROqPng.png" srcset="/img/loading.gif" lazyload alt="image-20241222153712844"></p>
<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=105665820&content_type=Article&match_order=1&q=%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94&zhida_source=entity">雪崩效应</a>。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。</p>
<p>在加密时：</p>
<p>对于4*4的矩阵，操作为：<br>第0行：保持不动；<br>第1行：循环左移1个字节；<br>第2行：循环左移2个字节；<br>第3行：循环左移3个字节。<br>解密过程变为循环右移，每行移动字节数与加密过程相同，下图为列位移示意图。</p>
<p><img src="https://s2.loli.net/2024/12/22/8MhbPmAsDTtaL5E.png" srcset="/img/loading.gif" lazyload alt="image-20241222153925099"></p>
<h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>实际上为4<em>4的矩阵与另一个4</em>4矩阵异或相乘（注意为右乘操作），重新得到一个4*4的矩阵。解密过程为重新与此矩阵异或，因为两次异或得到的值为原数据本身。但实际过程却比较复杂</p>
<p><img src="https://s2.loli.net/2024/12/22/G1Bd4MJoiSKyfNj.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p>
<p><img src="https://s2.loli.net/2024/12/22/5qpuD8Q1In4cUZ3.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<p>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 &#x3D; (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：</p>
<p><img src="https://s2.loli.net/2024/12/22/9FNmzsqhVan2OQI.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<p>也就是说，如果a7为1，则进行异或运算，否则不进行。<br>类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：</p>
<p><img src="https://s2.loli.net/2024/12/22/MeJvXsjxan6qkQA.png" srcset="/img/loading.gif" lazyload alt="4"></p>
<p>乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/3cd9fdef1e1047d154a8c11bcfb898fa.png#pic_center" srcset="/img/loading.gif" lazyload alt="4" style="zoom:150%;" />

<p>因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。</p>
<p>最终：</p>
<p><img src="https://s2.loli.net/2024/12/22/7ZtU198y4rswegB.png" srcset="/img/loading.gif" lazyload alt="image-20241222154656683"></p>
<h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><h5 id="AES密钥生成"><a href="#AES密钥生成" class="headerlink" title="AES密钥生成"></a><strong>AES密钥生成</strong></h5><p><img src="https://s2.loli.net/2024/12/22/XjW4mgapc6UZVGQ.png" srcset="/img/loading.gif" lazyload alt="image-20241222155137422"></p>
<p>函数T由3部分组成：字循环、字节代换和轮常量异或。</p>
<p><strong>函数T()首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。轮系数是一个有10个元素的一维数组，一个元素1个字节。</strong></p>
<p><img src="https://s2.loli.net/2024/12/22/jf1Xl6NpGMLJq48.png" srcset="/img/loading.gif" lazyload alt="6"></p>
<hr>
<p>轮密钥与状态矩阵进行逐比特异或操作。<br>这个轮密钥是由种子密钥通过密钥编排算法得到的，并且轮密钥长度与分组长度相同。<br>解密过程与之相同，两次异或得到原始数据。</p>
<p>最终：</p>
<p><img src="https://s2.loli.net/2024/12/22/YAac6FbnZWVQ8eH.png" srcset="/img/loading.gif" lazyload alt="8"></p>
<h4 id="1轮最终轮T"><a href="#1轮最终轮T" class="headerlink" title="1轮最终轮T"></a>1轮最终轮T</h4><p>最终轮的操作与普通轮类似，但<strong>省略了列混合（MixColumns）</strong>。最终轮包含以下三个步骤：</p>
<ol>
<li><strong>字节代换（SubBytes）</strong>。</li>
<li><strong>行移位（ShiftRows）</strong>。</li>
<li><strong>轮密钥加（AddRoundKey）</strong>。</li>
</ol>
<h3 id="TEA算法"><a href="#TEA算法" class="headerlink" title="TEA算法"></a>TEA算法</h3><p>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。</p>
<p>TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，建议的迭代次数为 32 轮。该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ&#x3D;「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）。</p>
<p>之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    <span class="hljs-comment">//总共加密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        sum += delta;<br>        x += ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        y += ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Decrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    sum = delta &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">//注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br>    <span class="hljs-comment">//总共加密32轮 那么反序也解密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-comment">// 先将y解开 然后参与运算在解x</span><br>        y -= ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>        x -= ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        sum -= delta;<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">//明文，必须是8字节的倍数，不够需要程序补全，参考base64方法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;待加密的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);  <br><br>    <span class="hljs-type">long</span> key[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;   <span class="hljs-comment">//密钥随便</span><br><br>    <span class="hljs-comment">//Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.</span><br>    Encrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;加密后的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);<br>    Decrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密后的数值：%d %d\&quot;,Data[0],Data[1]);</span><br><span class="hljs-string">    system(&quot;</span>pause<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<h5 id="逆向练习："><a href="#逆向练习：" class="headerlink" title="逆向练习："></a>逆向练习：</h5><p>题目来源：攻防世界(easy-app)</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1VXRI.png" srcset="/img/loading.gif" lazyload alt="image-20240925190902367"></p>
<h2 id="流密码算法-Stream-cipher"><a href="#流密码算法-Stream-cipher" class="headerlink" title="流密码算法(Stream cipher)"></a>流密码算法(Stream cipher)</h2><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>RC4（Rivest Cipher 4）是一种流加密算法，由罗纳德·李维斯特（Ron Rivest）在1987年开发。RC4算法的核心思想是利用伪随机数生成器（PRNG）和密钥共同生成一个密钥流，该密钥流与明文进行异或运算得到密文。</p>
<p>在RC4算法中，密钥流由两部分组成：密钥调度算法（KSA）和伪随机数生成算法（PRGA）。KSA的主要作用是将输入的密钥进行排列，生成一个密钥数组。PRGA则根据密钥数组生成伪随机数序列，这个序列与明文进行异或运算，得到密文。</p>
<blockquote>
<p>来源于大佬：B站&#x2F;可厉害的土豆</p>
</blockquote>
<p><img src="https://s2.loli.net/2024/12/30/uF3ptzxAscLb419.png" srcset="/img/loading.gif" lazyload alt="image-20241230174024627"></p>
<p>[<img src="https://s2.loli.net/2024/12/30/AoLV8Z3K6BjaN5t.png" srcset="/img/loading.gif" lazyload alt="image-20241230174042662"></p>
<p><img src="https://s2.loli.net/2024/12/30/qZbOoz1IgD2wSsG.png" srcset="/img/loading.gif" lazyload alt="image-20241230174059487"></p>
<p><img src="https://s2.loli.net/2024/12/30/UFCKGxewkjE5VSN.png" srcset="/img/loading.gif" lazyload alt="image-20241230174109548"></p>
<p><img src="https://s2.loli.net/2024/12/30/aMchGDSPjz1pr8y.png" srcset="/img/loading.gif" lazyload alt="image-20241230174122187"></p>
<h4 id="（1）初始化S表"><a href="#（1）初始化S表" class="headerlink" title="（1）初始化S表"></a>（1）初始化S表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RC4_Initialize</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *S, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int</span> key_length)</span> &#123;<br>    <span class="hljs-type">int</span> i, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp;<br><br>    <span class="hljs-comment">// S 表初始化为从 0 到 255 的值</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; RC4_KEY_SIZE; i++) &#123;<br>        S[i] = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用密钥对 S 表进行扰动</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; RC4_KEY_SIZE; i++) &#123;<br>        j = (j + S[i] + key[i % key_length]) % RC4_KEY_SIZE;  <span class="hljs-comment">// 更新 j 的值</span><br>        <span class="hljs-comment">// 交换 S[i] 和 S[j] 的值</span><br>        temp = S[i];<br>        S[i] = S[j];<br>        S[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（2）利用S盒生成密钥流"><a href="#（2）利用S盒生成密钥流" class="headerlink" title="（2）利用S盒生成密钥流"></a>（2）利用S盒生成密钥流</h4><p><img src="https://s2.loli.net/2024/12/22/cB6mPfT4FY8opqz.png" srcset="/img/loading.gif" lazyload alt="10"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// RC4 生成伪随机字节流</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">RC4_Generate</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *S, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *output, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, t;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> K;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; length; k++) &#123;<br>        i = (i + <span class="hljs-number">1</span>) % RC4_KEY_SIZE;<br>        j = (j + S[i]) % RC4_KEY_SIZE;<br><br>        <span class="hljs-comment">// 交换 S[i] 和 S[j] 的值</span><br>        temp = S[i];<br>        S[i] = S[j];<br>        S[j] = temp;<br><br>        <span class="hljs-comment">// 生成伪随机字节流</span><br>        t = (S[i] + S[j]) % RC4_KEY_SIZE;<br>        K = S[t];<br>        output[k] = K;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="（3）异或得结果"><a href="#（3）异或得结果" class="headerlink" title="（3）异或得结果"></a>（3）异或得结果</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 与数据进行按位异或，得到加密结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data_length; i++) &#123;<br>        output[i] ^= data[i];<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a><strong>非对称密码算法</strong></h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>对称加密(公钥密码算法)的安全性依赖于密钥的保密性和算法的强度。如果密钥被泄露，攻击者可以轻易解密数据。因此，在实际应用中，密钥管理和分发是对称加密的关键挑战之一。而通过使用密钥交换协议，通信双方可以安全地获得一个对称密钥，而敌手却无法知道这个对称密钥。</p>
<p>非对称密码算法使用一对密钥进行加密和解密，通常包括公钥和私钥。公钥可以公开，任何人都可以使用它加密数据；而私钥则必须保密，仅由拥有者使用来解密数据。</p>
<p><strong>主要特性</strong>：</p>
<ol>
<li><strong>密钥对</strong>：每个用户拥有一对密钥，公钥用于加密，私钥用于解密。</li>
<li><strong>安全性</strong>：即使公钥被公开，私钥的保密性仍能确保加密数据的安全性。</li>
<li><strong>身份验证</strong>：可用于数字签名，通过私钥签名的数据可以用公钥验证，确保信息来源和完整性。</li>
</ol>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1VxQP.png" srcset="/img/loading.gif" lazyload alt="image-20240928180525589"></p>
<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><blockquote>
<p>RSA加密算法.pdf <a target="_blank" rel="noopener" href="https://www.alipan.com/s/tpBA521QB9q">https://www.alipan.com/s/tpBA521QB9q</a> 提取码: k9b2 </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/testtraveler/p/18499698">RSA算法详解及相关数学原理解析 - testtraveler - 博客园</a></p>
</blockquote>
<h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><h5 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h5><p>RSA（Rivest-Shamir-Adleman）加密算法是一种基于数论的非实时加密算法，广泛用于安全通信。RSA算法的核心依赖于<strong>大整数分解</strong>的困难性</p>
<h5 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h5><p>RSA是一种非加密加密算法，它使用<strong>公钥</strong>进行加密，<strong>私钥</strong>进行解密。非加密加密的优势在于，公钥可以公开（存储于公钥数据库PKDB），而私钥仅保留给接收者。这种设计使得消息安全传输，而消耗共享加密密钥。</p>
<h5 id="1-3-素数（素数）"><a href="#1-3-素数（素数）" class="headerlink" title="1.3 素数（素数）"></a>1.3 <strong>素数（素数）</strong></h5><p>RSA依赖于两个大素数的乘积。素数是指只能被1和自身整除的整数。两个大素数的乘积积极难以进行因数分解，而这一问题构成了RSA的安全基础。</p>
<h5 id="1-4-模运算（Modulo）"><a href="#1-4-模运算（Modulo）" class="headerlink" title="1.4 模运算（Modulo）"></a>1.4 <strong>模运算（Modulo）</strong></h5><p>余数 RSA 中广泛使用模破坏。模破坏是一种余数破坏，定义为一个整数除以另一个整数后得到的数。在 RSA 中，模破坏对加密和解密过程的避免可以在有限的数值范围内进行，从而避免溢出和精度问题。</p>
<h5 id="1-5欧几里得函数"><a href="#1-5欧几里得函数" class="headerlink" title="1.5欧几里得函数"></a>1.5欧几里得函数</h5><p>给定两个非负整数 a 和 b（假设 a ≥ b），欧几里得算法基于以下原理：</p>
<ol>
<li>如果 a &#x3D; b，那么结果就是 a（或 b）。</li>
<li>如果 a &#x3D; 0，那么结果是 b，反之亦然。</li>
<li>如果 a ≠ b，那么可以用较小的那个数去除较大的那个数，然后用余数代替较大的数，重复此步骤直到余数为 0。</li>
</ol>
<p>欧几里得算法的步骤</p>
<ol>
<li>计算 a mod b 得到余数 r。</li>
<li>如果 r &#x3D; 0，那么 b 就是 a 和 b 的最大公约数。</li>
<li>如果 r ≠ 0，令 a &#x3D; b，b &#x3D; r，然后重复步骤 1。</li>
</ol>
<p>示例</p>
<p>假设我们要找 48 和 18 的最大公约数：</p>
<ol>
<li>48mod  18&#x3D;1248mod18&#x3D;12</li>
<li>18mod  12&#x3D;618mod12&#x3D;6</li>
<li>12mod  6&#x3D;012mod6&#x3D;0，此时余数为 0，所以最大公约数是 6。</li>
</ol>
<p>扩展欧几里得算法</p>
<p>扩展欧几里得算法不仅可以找到 a 和 b 的最大公约数 d，还可以找到一对整数 x 和 y，使得 ax + by &#x3D; d</p>
<h5 id="1-6-欧拉函数φ-n"><a href="#1-6-欧拉函数φ-n" class="headerlink" title="1.6 欧拉函数φ(n)"></a>1.6 <strong>欧拉函数φ(n)</strong></h5><p>欧拉函数（Euler’s Totient Function），通常记作 φ(n)，是数论中的一个重要函数。它对于一个正整数 n 定义为小于或等于 n 的正整数中与 n 互质的数的数目。两个数互质（coprime）指的是它们的最大公约数（GCD）为 1。</p>
<p>例如，φ(9) &#x3D; 6，因为 1, 2, 4, 5, 7 和 8 与 9 互质；而 φ(8) &#x3D; 4，因为只有 1, 3, 5 和 7 与 8 互质。</p>
<p>如果 n 是一个质数 p 的幂次 p^k，则有：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(pk)=pk−pk−<span class="hljs-number">1</span>=pk(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p)*φ*<span class="hljs-comment">(*p**k*)</span>=*p**k*−*p**k*−<span class="hljs-number">1</span>=*p**k*(<span class="hljs-number">1</span>−*p*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>对于任意正整数 n，如果 n 可以分解为不同质数的乘积：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">n=p1k1⋅p2k2⋯pmkm<span class="hljs-emphasis">*n*</span>=<span class="hljs-emphasis">*p*</span>1<span class="hljs-emphasis">*k*</span>1⋅<span class="hljs-emphasis">*p*</span>2<span class="hljs-emphasis">*k*</span>2⋯<span class="hljs-emphasis">*p<span class="hljs-strong">**m**</span>k<span class="hljs-strong">**m*</span></span><br></code></pre></td></tr></table></figure>

<p>那么根据欧拉函数的性质，我们可以计算出：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(n)=φ(p1k1)⋅φ(p2k2)⋯φ(pmkm)*φ*<span class="hljs-comment">(*n*)</span>=*φ*<span class="hljs-comment">(*p*1*k*1)⋅*φ*(*p*2*k*2)⋯*φ*(*p**m**k**m*)</span> φ(n)=n⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p1)⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p2)⋯(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>pm)*φ*<span class="hljs-comment">(*n*)</span>=*n*⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">11</span>)⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">21</span>)⋯(<span class="hljs-number">1</span>−*p**m*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="0x02-算法描述"><a href="#0x02-算法描述" class="headerlink" title="0x02 算法描述"></a>0x02 算法描述</h4><h5 id="1-1-密钥计算步骤"><a href="#1-1-密钥计算步骤" class="headerlink" title="1.1 密钥计算步骤"></a>1.1 密钥计算步骤</h5><p>1、生成两个大素数p和q</p>
<p>2、计算两个素数的乘积</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">n</span>=p*q <br></code></pre></td></tr></table></figure>

<p>3、计算欧拉函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">φ(n)=(p-1)*(q-1)<br></code></pre></td></tr></table></figure>

<p>4、选择一个整数<code>e</code>（1 &lt; e &lt; φ(n)），使得<code>e</code>与<code>φ(n)</code>互质（即最大公约数gcd(e, φ(n)) &#x3D; 1）。通常情况下，<code>e</code>取一个较小的质数如65537 (<code>2^16 + 1</code>)，因为它使得加密过程更高效。</p>
<p>5、欧几里得算法计算d(私钥)</p>
<p><code>d</code>（1 &lt; d &lt; φ(n)），使得</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">(d * e) <span class="hljs-built_in">mod</span> φ(n) = <span class="hljs-number">1</span><br>d = e^<span class="hljs-number">-1</span> <span class="hljs-built_in">mod</span> φ(n)<br></code></pre></td></tr></table></figure>

<p>换句话说，<code>d</code>是<code>e</code>在模<code>φ(n)</code>下的乘法逆元</p>
<p>6、公钥：<strong>由<code>(n, e)</code>组成</strong></p>
<p> 私钥：<strong>由<code>(n, d)</code>组成</strong></p>
<p>7、加密</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">m（其中m必须小于n）使用公钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> e<span class="hljs-punctuation">)</span>，加密公式为<span class="hljs-built_in">c</span> <span class="hljs-operator">=</span> m<span class="hljs-operator">^</span>e mod n，这里<span class="hljs-built_in">c</span>是密文<br></code></pre></td></tr></table></figure>

<p>8、解密</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">c</span>使用私钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> d<span class="hljs-punctuation">)</span>，解密公式为m <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-operator">^</span>d mod n，这样就恢复了原始的消息m<br></code></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table>
<thead>
<tr>
<th>公钥</th>
<th>（e,n）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>私钥</strong></td>
<td><strong>（d,n）</strong></td>
</tr>
<tr>
<td><strong>密钥对</strong></td>
<td><strong>（e,n,d）</strong></td>
</tr>
<tr>
<td><strong>加密</strong></td>
<td><strong>c &#x3D; m^e mod n</strong></td>
</tr>
<tr>
<td><strong>解密</strong></td>
<td><strong>m &#x3D; c ^d mod n</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>n</th>
<th>p*q</th>
</tr>
</thead>
<tbody><tr>
<td><strong>φ(n)</strong></td>
<td><strong>(p-1)*(q-1)</strong></td>
</tr>
<tr>
<td><strong>e</strong></td>
<td><strong>1&lt;e&lt; φ(n)</strong></td>
</tr>
<tr>
<td><strong>d</strong></td>
<td><strong>1&lt;d&lt; φ(n)</strong> <strong>,e*d mod φ(n) &#x3D; 1</strong></td>
</tr>
</tbody></table>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 计算最大公约数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 求模反元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">modInverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt; m; x++) &#123;<br>        <span class="hljs-keyword">if</span> ((a * x) % m == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 快速幂算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    x = x % p;<br>    <span class="hljs-keyword">while</span> (y &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>            res = (res * x) % p;<br>        y = y &gt;&gt; <span class="hljs-number">1</span>;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// RSA加密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(m, e, n);<br>&#125;<br><br><span class="hljs-comment">// RSA解密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(c, d, n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">61</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">53</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> n = p * q; <span class="hljs-comment">// 计算n</span><br>    <span class="hljs-type">int</span> phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算φ(n)</span><br>    <br>    <span class="hljs-type">int</span> e = <span class="hljs-number">17</span>; <span class="hljs-comment">// 选择公钥</span><br>    <span class="hljs-keyword">while</span> (gcd(e, phi) != <span class="hljs-number">1</span>) &#123;<br>        e++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> d = modInverse(e, phi); <span class="hljs-comment">// 计算私钥</span><br>    <br>    <span class="hljs-type">int</span> m = <span class="hljs-number">65</span>; <span class="hljs-comment">// 明文</span><br>    <span class="hljs-type">int</span> c = rsa_encrypt(m, e, n); <span class="hljs-comment">// 加密</span><br>    <span class="hljs-type">int</span> decrypted = rsa_decrypt(c, d, n); <span class="hljs-comment">// 解密</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;明文: %d\n&quot;</span>, m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;密文: %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密: %d\n&quot;</span>, decrypted);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>简单地说，数字签名的作用类似于现实生活中在支票和合同上的签名。当然数字签名是一种密码学技术，相比手写签名，它提供了更多的安全保证。当数字签名应用在各种各样的协议中时，它会让这些协议具有更加强大的功能</p>
<p>我们知道数字签名与现实生活中的签名非常相似。该密码学原语是在直观上很容易理解的密码原语之一。</p>
<ul>
<li>只有签名者本人可以对任意消息生成签名。</li>
<li>任何人都可以验证签名者对消息的签名。</li>
</ul>
<p><strong>在非对称密码领域，我们很容易想到数字签名的这种非对称性实现方式。</strong></p>
<p>签名方案通常由3种不同的算法组成。</p>
<ul>
<li>密钥对生成算法：签名者使用该算法生成新的私钥和公钥（公钥可以共享出去）。</li>
<li>签名算法：该算法以私钥和消息为输入，输出消息的签名。</li>
<li>验证算法：该算法以公钥、消息以及消息的签名为输入，输出验证结果（通过或不通过）。</li>
</ul>
<p>有时我们也将私钥称为签名密钥，将公钥称为验证密钥。上述3种算法的原理如图7.1所示。</p>
<p><img src="https://s2.loli.net/2024/12/22/aUc9M5T7Avg46uq.png" srcset="/img/loading.gif" lazyload alt="image-20240928211112408"></p>
<p>那么为什么数字签名应用如此广泛呢？这是因为数字签名可以用于验证消息的来源以及完整性。</p>
<ul>
<li>来源：如果这个消息中包含某个人的签名，那么说明该消息源于这个人。</li>
<li>完整性：如果有人篡改了消息，签名就会失效。</li>
</ul>
<h3 id="数字证书-公钥的数字签名"><a href="#数字证书-公钥的数字签名" class="headerlink" title="数字证书(公钥的数字签名)"></a>数字证书(公钥的数字签名)</h3><p>数字证书也称为身份证书和<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=222777750&content_type=Article&match_order=1&q=%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6&zhida_source=entity">公钥证书</a>，是一种利用公钥基础设施(PKI)并使个人和企业能够通过互联网安全地共享数据的电子密码。</p>
<p>在信任可传递的假设下，数字签名将变得更加强大。简而言之，如果你相信我，而我相信Alice，那么你就可以相信Alice。信任的传递性使得系统中的信任关系得到极大地扩展。想象一下，假设我们信任某些权威机构及其验证密钥。那么，假设该权威机构对某些消息进行签名，比如Charles或者David的公钥信息等，我们就可以选择相信这个签名与消息的映射关系！这种映射称为公钥基础设施(Public Key Infrastructure，PKI)。例如，当我们尝试与Charles进行密钥交换，且他声称自己的公钥是3848时，可以通过检查我们信任的权威机构是否对类似“Charles的公钥是3848…”的消息进行签名来验证Charles的公钥的真实性。</p>
<p>PKI在实践中的一个应用是Web PKI。浏览器每天都通过Web PKI对我们与网站的密钥交换过程进行认证。Web PKI可以简化如下（见图7.3）过程：当我们下载浏览器时，它附带了一些内置在浏览器中的验证密钥。此验证密钥与一个权威机构相关联，该机构负责对成千上万个网站的公钥进行签名，以便网络用户可以信任这些公钥，而不必知道权威机构的存在。而用户不能观察到的是，这些网站在获得它们公钥的签名之前，必须向权威机构证明它们确实拥有自己所声称的域名。（事实上，浏览器信任许多权威机构而不仅只有一个。）</p>
<p><img src="https://s2.loli.net/2024/12/22/FUx1TDnlH94KktQ.png" srcset="/img/loading.gif" lazyload alt="image-20240928212930338"></p>
<h1 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a><strong>摘要算法</strong></h1><h2 id="密码原语-基础知识"><a href="#密码原语-基础知识" class="headerlink" title="密码原语(基础知识)"></a>密码原语(基础知识)</h2><p>哈希函数(Hash Function)，它可以给任何数据生成一个全局唯一的标识符。哈希函数在密码学中随处可见！非正式地说，哈希函数以任意值为输入，并输出一个唯一的字节串。给定相同的输入，哈希函数总是产生相同的字节串。这可能看起来没什么，但在密码学中，许多算法都是基于哈希函数构造的。哈希函数的输出通常被称为摘要(Digest)或哈希值(Hash)</p>
<p>哈希函数的三种安全属性的表格及其简要介绍：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>抗第一原像性</td>
<td>给定哈希值，无法找到一个输入值，使得该输入值的哈希值等于该给定哈希值。</td>
<td>这确保了即使攻击者知道哈希值，也不能轻易反推原始输入。</td>
</tr>
<tr>
<td>抗第二原像性</td>
<td>给定输入值，无法找到另一个不同的输入值，使得两个输入的哈希值相同。</td>
<td>这保证了不同输入产生相同哈希值的概率极低，有效抵御替换攻击。</td>
</tr>
<tr>
<td>抗碰撞性</td>
<td>任何两个不同的输入值，几乎不可能产生相同的哈希值。</td>
<td>这使得攻击者无法找到两个不同的输入使它们的哈希值相同。</td>
</tr>
</tbody></table>
<p>主要应用场景：</p>
<table>
<thead>
<tr>
<th>应用场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数据完整性验证</td>
<td>检查数据在传输或存储过程中的完整性，确保未被篡改。</td>
</tr>
<tr>
<td>密码存储</td>
<td>将用户密码哈希后存储，防止直接获取明文密码。</td>
</tr>
<tr>
<td>数字签名</td>
<td>生成数字签名的摘要，确保签名的数据未被篡改并提供身份验证。</td>
</tr>
<tr>
<td>文件完整性校验</td>
<td>在软件分发时，通过哈希值验证下载文件的完整性，防止恶意篡改。</td>
</tr>
<tr>
<td>区块链技术</td>
<td>用于生成区块的哈希值，确保区块链中的数据不可篡改和一致性。</td>
</tr>
<tr>
<td>身份认证</td>
<td>在安全协议中，确保用户身份的验证，防止伪造身份。</td>
</tr>
<tr>
<td>网络协议安全</td>
<td>在SSL&#x2F;TLS等协议中用于数据传输的安全性和完整性校验。</td>
</tr>
<tr>
<td>防止重放攻击</td>
<td>确保每次通信都有唯一的哈希值，防止旧通信内容被重放。</td>
</tr>
<tr>
<td>电子邮件安全</td>
<td>用于生成邮件的哈希值，确保邮件内容未被篡改。</td>
</tr>
<tr>
<td>代码签名</td>
<td>验证软件代码的完整性和来源，确保软件未被篡改。</td>
</tr>
</tbody></table>
<h2 id="消息摘要算法-Message-Digest"><a href="#消息摘要算法-Message-Digest" class="headerlink" title="消息摘要算法(Message Digest)"></a>消息摘要算法(Message Digest)</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： MD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，它产生一个128位（16字节）的哈希值，通常以32位十六进制数字表示。</p>
<p><strong>主要特性</strong>：</p>
<ul>
<li><strong>输出固定长度</strong>：无论输入数据大小如何，MD5总是生成128位的哈希值。</li>
<li><strong>快速计算</strong>：MD5的计算速度相对较快，适合处理大量数据。</li>
<li><strong>抗碰撞性</strong>：理论上，MD5应保证不同输入不产生相同的哈希值（尽管实际应用中存在漏洞）。</li>
<li><strong>广泛应用</strong>：MD5曾被广泛用于数据完整性校验、数字签名和密码存储等场景。</li>
</ul>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块"><a href="#数据填充和分块" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>对待加密的文件或者字符串的处理是将一个字符串分割成每512位为一个分组(小到KB大到GB都是如此划分)，形如N*512+R，这里的R是余下的位数。这个R分为几种情况：</p>
<ul>
<li>当R&#x3D;0时，实际上不需要单独“补上一个512位的分组”，因为接下来的填充和长度信息添加会自动形成一个完整的分组。</li>
<li>当R&lt;448时，需要在消息后面添加一个<code>1</code>，然后添加足够多的<code>0</code>，直到消息长度达到448位。之后，添加64位的长度信息（即原始消息的长度，以位为单位，低位在前）。</li>
<li>当R&gt;448时，确实需要添加足够的<code>0</code>（加上那个初始的<code>1</code>）来填满当前分组（即达到512位），然后在下一个分组中继续添加64位的长度信息(下一个分组的前64位)。但请注意，这里不是“再补上一个512位的分组”，而是说长度信息会放在一个新的分组中（如果原始消息加上填充的<code>1</code>和<code>0</code>不足以填满一个完整的分组，则可能看起来像是“再补”了一个分组，但实际上只是长度信息占据了一个分组的前部分）。</li>
</ul>
<p>这里的最后长度的填充一般在输出的前一刻执行。前面的分块后就可以执行后续操作了。</p>
<p>代码讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">Md5Finalise</span>  <br><span class="hljs-params">(  </span><br><span class="hljs-params">    Md5Context*         Context,        <span class="hljs-comment">// [in out] 指向MD5上下文的指针，该上下文将被修改以完成哈希计算。  </span></span><br><span class="hljs-params">    MD5_HASH*           Digest          <span class="hljs-comment">// [out] 用于接收最终哈希值的缓冲区。  </span></span><br><span class="hljs-params">)</span>  <br>&#123;  <br>    <span class="hljs-type">uint32_t</span>    used;     <span class="hljs-comment">// 用于存储缓冲区中已使用字节的数量。  </span><br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;     <span class="hljs-comment">// 用于存储缓冲区中剩余空闲字节的数量。  </span><br>  <br>    <span class="hljs-comment">// 计算缓冲区中已使用的字节数。  </span><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;  <br>  <br>    <span class="hljs-comment">// 在缓冲区的当前位置添加一个0x80字节作为填充的开始。  </span><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;  <br>  <br>    <span class="hljs-comment">// 计算填充0x80字节后剩余的空闲空间。  </span><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;  <br>  <br>    <span class="hljs-comment">// 如果剩余的空闲空间不足以存放64位长度信息，则进行填充、变换，并重置used和free。  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );  <br>        <span class="hljs-comment">//压缩循环函数(暂时不要管)</span><br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br>        used = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 在剩余空间中填充0，直到距离缓冲区末尾剩下8个字节用于存放长度信息。  </span><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );  <br>  <br>    <span class="hljs-comment">// 将消息长度（以位为单位）左移3位（这不是标准MD5），并存储到缓冲区末尾。  </span><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;  <br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );  <br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );  <br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );  <br>  <br>    <span class="hljs-comment">// 对填充后的缓冲区进行最后的变换，得到最终的哈希值。  </span><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br></code></pre></td></tr></table></figure>

<h5 id="链接变量初始化"><a href="#链接变量初始化" class="headerlink" title="链接变量初始化"></a>链接变量初始化</h5><p>初始化一个128-bit 的 MD 缓冲区，初始记为CV0，可以表示成4个32-bit 寄存器（A, B, C, D），后续的迭代始终在 MD 缓冲区进行，最后一步的128-bit 输出即为MD5算法的结果。</p>
<p>MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：A&#x3D;0x01234567，B&#x3D;0x89abcdef，C&#x3D;0xfedcba98，D&#x3D;0x76543210。但考虑到内存数据存储大小端的问题我们将其赋值为：A&#x3D;0x67452301，B&#x3D;0xefcdab89，C&#x3D;0x98badcfe，D&#x3D;0x10325476。</p>
<p>代码讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>     lo;<br>    <span class="hljs-type">uint32_t</span>     hi;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint8_t</span>      buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">uint32_t</span>     block[<span class="hljs-number">16</span>];<br>&#125; Md5Context;<br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;a = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;b = <span class="hljs-number">0xefcdab89</span>;<br>    Context-&gt;c = <span class="hljs-number">0x98badcfe</span>;<br>    Context-&gt;d = <span class="hljs-number">0x10325476</span>;<br><br>    Context-&gt;lo = <span class="hljs-number">0</span>;<br>    Context-&gt;hi = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="压缩循环"><a href="#压缩循环" class="headerlink" title="压缩循环"></a>压缩循环</h5><p>MD5算法规定了四个非线性操作函数（&amp;是与，|是或，~是非，^是异或）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define F( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">z</span>) ^ ((<span class="hljs-name">x</span>) &amp; ((<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>))) )<br>#define G( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">z</span>) &amp; ((<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>))) )<br>#define H( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>) )<br>#define I( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">x</span>) | ~(<span class="hljs-name">z</span>)) )<br></code></pre></td></tr></table></figure>

<p>这些函数设计思想的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p>
<p>利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a &#x3D; A, b &#x3D; B, c &#x3D; C, d &#x3D; D。然后定义这四个计算函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br></code></pre></td></tr></table></figure>

<p>其中M[j]表示消息的第j个子分组（从0到15），&lt;&lt;表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。</p>
<p>定义好上述的四个计算函数后，就可以实现MD5的真正循环计算了。<strong>这个循环的循环次数为512位分组的个数</strong>。</p>
<blockquote>
<p>压缩函数每次都从CV（即上文提到的 128-bit 缓冲区）输入128位，从之前分好的消息分组中按顺序输入512位，完成4轮循环后，得到该轮压缩的128位结果，加到原来的缓冲区中，然后用下一分组继续上述步骤。（<strong>说具体一点，就是函数每次都从缓冲区(A, B, C, D)拿到四个数a, b, c, d，然后对于a, b, c, d进行压缩循环操作，把最后得到的结果a, b, c, d加到原来的(A, B, C, D)中，下一次函数执行再从(A, B, C, D)中拿数据</strong>）</p>
</blockquote>
<p>每次循环执行64次计算，上述4个函数每个16次.</p>
<p>代码讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span>*<br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*     ctx,</span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*     data,</span><br><span class="hljs-params">        <span class="hljs-type">uintmax_t</span>       size</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span>*     ptr;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint32_t</span>     saved_a;<br>    <span class="hljs-type">uint32_t</span>     saved_b;<br>    <span class="hljs-type">uint32_t</span>     saved_c;<br>    <span class="hljs-type">uint32_t</span>     saved_d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(n) (ctx-&gt;block[(n)])</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(n) (ctx-&gt;block[(n)] =             \</span><br><span class="hljs-meta">            ((uint32_t)ptr[(n)*4 + 0] &lt;&lt; 0 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 1] &lt;&lt; 8 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 2] &lt;&lt; 16)      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 3] &lt;&lt; 24) )</span><br><br>    ptr = (<span class="hljs-type">uint8_t</span>*)data;<br><br>    a = ctx-&gt;a;<br>    b = ctx-&gt;b;<br>    c = ctx-&gt;c;<br>    d = ctx-&gt;d;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        saved_a = a;<br>        saved_b = b;<br>        saved_c = c;<br>        saved_d = d;<br><br>        <span class="hljs-comment">// Round 1</span><br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xd76aa478</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xe8c7b756</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x242070db</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xc1bdceee</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf57c0faf</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">5</span>),  <span class="hljs-number">0x4787c62a</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa8304613</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xfd469501</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">8</span> ),  <span class="hljs-number">0x698098d8</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">9</span> ),  <span class="hljs-number">0x8b44f7af</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">10</span> ), <span class="hljs-number">0xffff5bb1</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">11</span> ), <span class="hljs-number">0x895cd7be</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">12</span> ), <span class="hljs-number">0x6b901122</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">13</span> ), <span class="hljs-number">0xfd987193</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">14</span> ), <span class="hljs-number">0xa679438e</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">15</span> ), <span class="hljs-number">0x49b40821</span>, <span class="hljs-number">22</span> )<br><br>        <span class="hljs-comment">// Round 2</span><br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xf61e2562</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xc040b340</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x265e5a51</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xe9b6c7aa</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xd62f105d</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0x02441453</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xd8a1e681</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xe7d3fbc8</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0x21e1cde6</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xc33707d6</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xf4d50d87</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x455a14ed</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0xa9e3e905</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xfcefa3f8</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x676f02d9</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x8d2a4c8a</span>, <span class="hljs-number">20</span> )<br><br>        <span class="hljs-comment">// Round 3</span><br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfffa3942</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x8771f681</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x6d9d6122</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xfde5380c</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xa4beea44</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0x4bdecfa9</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xf6bb4b60</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xbebfbc70</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x289b7ec6</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xeaa127fa</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xd4ef3085</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0x04881d05</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xd9d4d039</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0xe6db99e5</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0x1fa27cf8</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xc4ac5665</span>, <span class="hljs-number">23</span> )<br><br>        <span class="hljs-comment">// Round 4</span><br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xf4292244</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x432aff97</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xab9423a7</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfc93a039</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x655b59c3</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0x8f0ccc92</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xffeff47d</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0x85845dd1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x6fa87e4f</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xfe2ce6e0</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa3014314</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x4e0811a1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf7537e82</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0xbd3af235</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x2ad7d2bb</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xeb86d391</span>, <span class="hljs-number">21</span> )<br><br>        a += saved_a;<br>        b += saved_b;<br>        c += saved_c;<br>        d += saved_d;<br><br>        ptr += <span class="hljs-number">64</span>;<br>    &#125; <span class="hljs-keyword">while</span>( size -= <span class="hljs-number">64</span> );<br><br>    ctx-&gt;a = a;<br>    ctx-&gt;b = b;<br>    ctx-&gt;c = c;<br>    ctx-&gt;d = d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> GET</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> SET</span><br><br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*         Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    saved_lo;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    saved_lo = Context-&gt;lo;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;lo = (saved_lo + BufferSize) &amp; <span class="hljs-number">0x1fffffff</span>) &lt; saved_lo )<br>    &#123;<br>        Context-&gt;hi++;<br>    &#125;<br>    Context-&gt;hi += (<span class="hljs-type">uint32_t</span>)( BufferSize &gt;&gt; <span class="hljs-number">29</span> );<br><br>    used = saved_lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    <span class="hljs-keyword">if</span>( used )<br>    &#123;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>        <span class="hljs-keyword">if</span>( BufferSize &lt; <span class="hljs-built_in">free</span> )<br>        &#123;<br>            <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, BufferSize );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, <span class="hljs-built_in">free</span> );<br>        Buffer = (<span class="hljs-type">uint8_t</span>*)Buffer + <span class="hljs-built_in">free</span>;<br>        BufferSize -= <span class="hljs-built_in">free</span>;<br>        TransformFunction(Context, Context-&gt;buffer, <span class="hljs-number">64</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( BufferSize &gt;= <span class="hljs-number">64</span> )<br>    &#123;<br>        Buffer = TransformFunction( Context, Buffer, BufferSize &amp; ~(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-number">0x3f</span> );<br>        BufferSize &amp;= <span class="hljs-number">0x3f</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( Context-&gt;buffer, Buffer, BufferSize );<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。当然，输出依然要考虑内存存储的大小端问题。</p>
<p>代码讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Finalise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        MD5_HASH*           Digest          <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;<br><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );<br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>        used = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );<br><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;<br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );<br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );<br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );<br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );<br><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>    <br>    <br>    <span class="hljs-comment">//-----------结果输出-----------------</span><br><br>    Digest-&gt;bytes[<span class="hljs-number">0</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a );<br>    Digest-&gt;bytes[<span class="hljs-number">1</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">2</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">3</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">4</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b );<br>    Digest-&gt;bytes[<span class="hljs-number">5</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">6</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">7</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">8</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c );<br>    Digest-&gt;bytes[<span class="hljs-number">9</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">10</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">11</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">12</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d );<br>    Digest-&gt;bytes[<span class="hljs-number">13</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">14</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">15</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">24</span> );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myseries/p/11581170.html">MD5算法+盐Salt - myseries - 博客园 (cnblogs.com)</a></p>
<p><strong>概念</strong>： MD5加盐是指在计算MD5哈希值时，向原始数据中添加一个随机的字符串（称为“盐”），以增强哈希值的安全性。盐的主要目的是防止使用预计算的哈希值（如彩虹表）进行攻击。(MD5加盐常用于密码存储、用户认证等需要保护敏感数据的场合)</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>生成盐</strong>：为每个用户或数据生成一个随机字符串，通常长度在8至16字节之间。</li>
<li><strong>组合数据</strong>：将盐与原始数据（如密码）结合。可以是简单的拼接，或采用更复杂的方式。</li>
<li><strong>计算哈希</strong>：使用MD5算法计算组合后的数据的哈希值。</li>
</ol>
<h2 id="安全散列算法-Secure-Hash-Algorithm"><a href="#安全散列算法-Secure-Hash-Algorithm" class="headerlink" title="安全散列算法(Secure Hash Algorithm)"></a>安全散列算法(Secure Hash Algorithm)</h2><p>哈希函数的概念最早出现在计算机科学中，主要用于数据结构（如哈希表）和简单的完整性校验</p>
<h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-1（Secure Hash Algorithm 1）是一种广泛使用的加密哈希函数，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于1995年。SHA-1生成一个160位（20字节）的哈希值，通常以40位十六进制数表示。(SHA-1已不再安全)</p>
<p><strong>主要特性</strong>：</p>
<ol>
<li><strong>输出固定长度</strong>：无论输入数据的大小，SHA-1总是生成160位的哈希值。</li>
<li><strong>快速计算</strong>：SHA-1计算速度较快，适合处理大数据量。</li>
<li><strong>抗碰撞性</strong>：SHA-1设计上应保证不同输入产生不同哈希值，但随着研究的深入，已被发现存在碰撞漏洞。</li>
</ol>
<h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块-1"><a href="#数据填充和分块-1" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。</p>
<p>其中分块与填充同MD5相同不多赘述</p>
<h5 id="初始化MD-Buffer"><a href="#初始化MD-Buffer" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// SHA1 initialisation constants</span><br>    Context-&gt;State[<span class="hljs-number">0</span>] = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;State[<span class="hljs-number">1</span>] = <span class="hljs-number">0xEFCDAB89</span>;<br>    Context-&gt;State[<span class="hljs-number">2</span>] = <span class="hljs-number">0x98BADCFE</span>;<br>    Context-&gt;State[<span class="hljs-number">3</span>] = <span class="hljs-number">0x10325476</span>;<br>    Context-&gt;State[<span class="hljs-number">4</span>] = <span class="hljs-number">0xC3D2E1F0</span>;<br>    Context-&gt;Count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Context-&gt;Count[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="16份子明文分组扩展为80份"><a href="#16份子明文分组扩展为80份" class="headerlink" title="16份子明文分组扩展为80份"></a>16份子明文分组扩展为80份</h5><p>扩充的方法:</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1Z9eS.png" srcset="/img/loading.gif" lazyload alt="image-20240919202000585"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> blk(i) (block-&gt;l[i&amp;15] = rol(block-&gt;l[(i+13)&amp;15] ^ block-&gt;l[(i+8)&amp;15] ^ block-&gt;l[(i+2)&amp;15] ^ block-&gt;l[i&amp;15],1))</span><br><span class="hljs-comment">//rol函数用于循环左移:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rol(value, bits) (((value) <span class="hljs-string">&lt;&lt; (bits)) | ((value) &gt;</span>&gt; (32 - (bits))))</span><br></code></pre></td></tr></table></figure>

<h5 id="80份子明文分组进行4轮运算"><a href="#80份子明文分组进行4轮运算" class="headerlink" title="80份子明文分组进行4轮运算"></a>80份子明文分组进行4轮运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1ZSL8.png" srcset="/img/loading.gif" lazyload alt="image-20240919203025400"></p>
<p>其中k为固定值：</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1eT4H.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<p>f函数为(之所以称为四轮运算的原因)：</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1eb8A.png" srcset="/img/loading.gif" lazyload alt="1111"></p>
<h5 id="链接变量与初始链接变量进行求和运算"><a href="#链接变量与初始链接变量进行求和运算" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1eqgI.png" srcset="/img/loading.gif" lazyload alt="image-20240919203559058"></p>
<p>这里的Ho就是初始化的5个常量</p>
<p>注意这里的”+”是指:</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1mSUg.png" srcset="/img/loading.gif" lazyload alt="image-20240919203941364"></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            state[<span class="hljs-number">5</span>],</span><br><span class="hljs-params">        <span class="hljs-type">uint8_t</span> <span class="hljs-type">const</span>       buffer[<span class="hljs-number">64</span>]</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>            a;<br>    <span class="hljs-type">uint32_t</span>            b;<br>    <span class="hljs-type">uint32_t</span>            c;<br>    <span class="hljs-type">uint32_t</span>            d;<br>    <span class="hljs-type">uint32_t</span>            e;<br>    <span class="hljs-type">uint8_t</span>             workspace[<span class="hljs-number">64</span>];<br>    CHAR64LONG16*       block = (CHAR64LONG16*) workspace;<br><br>    Load128BitsAsWords( block-&gt;l, buffer );<br><br>    <span class="hljs-comment">// Copy context-&gt;state[] to working vars</span><br>    a = state[<span class="hljs-number">0</span>];<br>    b = state[<span class="hljs-number">1</span>];<br>    c = state[<span class="hljs-number">2</span>];<br>    d = state[<span class="hljs-number">3</span>];<br>    e = state[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-comment">// 4 rounds of 20 operations each. Loop unrolled.</span><br>    R0(a,b,c,d,e, <span class="hljs-number">0</span>); R0(e,a,b,c,d, <span class="hljs-number">1</span>); R0(d,e,a,b,c, <span class="hljs-number">2</span>); R0(c,d,e,a,b, <span class="hljs-number">3</span>);<br>    R0(b,c,d,e,a, <span class="hljs-number">4</span>); R0(a,b,c,d,e, <span class="hljs-number">5</span>); R0(e,a,b,c,d, <span class="hljs-number">6</span>); R0(d,e,a,b,c, <span class="hljs-number">7</span>);<br>    R0(c,d,e,a,b, <span class="hljs-number">8</span>); R0(b,c,d,e,a, <span class="hljs-number">9</span>); R0(a,b,c,d,e,<span class="hljs-number">10</span>); R0(e,a,b,c,d,<span class="hljs-number">11</span>);<br>    R0(d,e,a,b,c,<span class="hljs-number">12</span>); R0(c,d,e,a,b,<span class="hljs-number">13</span>); R0(b,c,d,e,a,<span class="hljs-number">14</span>); R0(a,b,c,d,e,<span class="hljs-number">15</span>);<br>    R1(e,a,b,c,d,<span class="hljs-number">16</span>); R1(d,e,a,b,c,<span class="hljs-number">17</span>); R1(c,d,e,a,b,<span class="hljs-number">18</span>); R1(b,c,d,e,a,<span class="hljs-number">19</span>);<br>    R2(a,b,c,d,e,<span class="hljs-number">20</span>); R2(e,a,b,c,d,<span class="hljs-number">21</span>); R2(d,e,a,b,c,<span class="hljs-number">22</span>); R2(c,d,e,a,b,<span class="hljs-number">23</span>);<br>    R2(b,c,d,e,a,<span class="hljs-number">24</span>); R2(a,b,c,d,e,<span class="hljs-number">25</span>); R2(e,a,b,c,d,<span class="hljs-number">26</span>); R2(d,e,a,b,c,<span class="hljs-number">27</span>);<br>    R2(c,d,e,a,b,<span class="hljs-number">28</span>); R2(b,c,d,e,a,<span class="hljs-number">29</span>); R2(a,b,c,d,e,<span class="hljs-number">30</span>); R2(e,a,b,c,d,<span class="hljs-number">31</span>);<br>    R2(d,e,a,b,c,<span class="hljs-number">32</span>); R2(c,d,e,a,b,<span class="hljs-number">33</span>); R2(b,c,d,e,a,<span class="hljs-number">34</span>); R2(a,b,c,d,e,<span class="hljs-number">35</span>);<br>    R2(e,a,b,c,d,<span class="hljs-number">36</span>); R2(d,e,a,b,c,<span class="hljs-number">37</span>); R2(c,d,e,a,b,<span class="hljs-number">38</span>); R2(b,c,d,e,a,<span class="hljs-number">39</span>);<br>    R3(a,b,c,d,e,<span class="hljs-number">40</span>); R3(e,a,b,c,d,<span class="hljs-number">41</span>); R3(d,e,a,b,c,<span class="hljs-number">42</span>); R3(c,d,e,a,b,<span class="hljs-number">43</span>);<br>    R3(b,c,d,e,a,<span class="hljs-number">44</span>); R3(a,b,c,d,e,<span class="hljs-number">45</span>); R3(e,a,b,c,d,<span class="hljs-number">46</span>); R3(d,e,a,b,c,<span class="hljs-number">47</span>);<br>    R3(c,d,e,a,b,<span class="hljs-number">48</span>); R3(b,c,d,e,a,<span class="hljs-number">49</span>); R3(a,b,c,d,e,<span class="hljs-number">50</span>); R3(e,a,b,c,d,<span class="hljs-number">51</span>);<br>    R3(d,e,a,b,c,<span class="hljs-number">52</span>); R3(c,d,e,a,b,<span class="hljs-number">53</span>); R3(b,c,d,e,a,<span class="hljs-number">54</span>); R3(a,b,c,d,e,<span class="hljs-number">55</span>);<br>    R3(e,a,b,c,d,<span class="hljs-number">56</span>); R3(d,e,a,b,c,<span class="hljs-number">57</span>); R3(c,d,e,a,b,<span class="hljs-number">58</span>); R3(b,c,d,e,a,<span class="hljs-number">59</span>);<br>    R4(a,b,c,d,e,<span class="hljs-number">60</span>); R4(e,a,b,c,d,<span class="hljs-number">61</span>); R4(d,e,a,b,c,<span class="hljs-number">62</span>); R4(c,d,e,a,b,<span class="hljs-number">63</span>);<br>    R4(b,c,d,e,a,<span class="hljs-number">64</span>); R4(a,b,c,d,e,<span class="hljs-number">65</span>); R4(e,a,b,c,d,<span class="hljs-number">66</span>); R4(d,e,a,b,c,<span class="hljs-number">67</span>);<br>    R4(c,d,e,a,b,<span class="hljs-number">68</span>); R4(b,c,d,e,a,<span class="hljs-number">69</span>); R4(a,b,c,d,e,<span class="hljs-number">70</span>); R4(e,a,b,c,d,<span class="hljs-number">71</span>);<br>    R4(d,e,a,b,c,<span class="hljs-number">72</span>); R4(c,d,e,a,b,<span class="hljs-number">73</span>); R4(b,c,d,e,a,<span class="hljs-number">74</span>); R4(a,b,c,d,e,<span class="hljs-number">75</span>);<br>    R4(e,a,b,c,d,<span class="hljs-number">76</span>); R4(d,e,a,b,c,<span class="hljs-number">77</span>); R4(c,d,e,a,b,<span class="hljs-number">78</span>); R4(b,c,d,e,a,<span class="hljs-number">79</span>);<br><br>    <span class="hljs-comment">// Add the working vars back into context.state[]</span><br>    state[<span class="hljs-number">0</span>] += a;<br>    state[<span class="hljs-number">1</span>] += b;<br>    state[<span class="hljs-number">2</span>] += c;<br>    state[<span class="hljs-number">3</span>] += d;<br>    state[<span class="hljs-number">4</span>] += e;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span>  <span class="hljs-type">const</span>*        Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    i;<br>    <span class="hljs-type">uint32_t</span>    j;<br><br>    j = (Context-&gt;Count[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">63</span>;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;Count[<span class="hljs-number">0</span>] += BufferSize &lt;&lt; <span class="hljs-number">3</span>) &lt; (BufferSize &lt;&lt; <span class="hljs-number">3</span>) )<br>    &#123;<br>        Context-&gt;Count[<span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    Context-&gt;Count[<span class="hljs-number">1</span>] += (BufferSize &gt;&gt; <span class="hljs-number">29</span>);<br>    <span class="hljs-keyword">if</span>( (j + BufferSize) &gt; <span class="hljs-number">63</span> )<br>    &#123;<br>        i = <span class="hljs-number">64</span> - j;<br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], Buffer, i );<br>        TransformFunction(Context-&gt;State, Context-&gt;Buffer);<br>        <span class="hljs-keyword">for</span>( ; i + <span class="hljs-number">63</span> &lt; BufferSize; i += <span class="hljs-number">64</span> )<br>        &#123;<br>            TransformFunction(Context-&gt;State, (<span class="hljs-type">uint8_t</span>*)Buffer + i);<br>        &#125;<br>        j = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        i = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], &amp;((<span class="hljs-type">uint8_t</span>*)Buffer)[i], BufferSize - i );<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="链接变量作为下一个明文分组的输入重复进行以上操作"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1mp5Q.png" srcset="/img/loading.gif" lazyload alt="image-20240919203902118"></p>
<p>代码：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pf">// Copy context-&gt;state[] <span class="hljs-keyword">to</span> working vars<br>  a = <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>];<br>  b = <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>];<br>  c = <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>];<br>  d = <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>];<br>  e = <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>];<br><br>  // <span class="hljs-number">4</span> rounds of <span class="hljs-number">20</span> operations each. Loop unrolled.<br>  ............<br>  .....<br>  .<br><br>  // Add the working vars back into context.<span class="hljs-keyword">state</span>[]<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>] += a;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>] += b;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>] += c;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>] += d;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>] += e;<br></code></pre></td></tr></table></figure>

<h5 id="最后5个链接变量里面的数据就是SHA1摘要"><a href="#最后5个链接变量里面的数据就是SHA1摘要" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>在所有数据块处理完成后，5个链接变量的最终值即为SHA1的摘要值。</p>
<h3 id="SHA2算法"><a href="#SHA2算法" class="headerlink" title="SHA2算法"></a>SHA2算法</h3><h4 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-2（Secure Hash Algorithm 2）是一组加密哈希函数的集合，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于2001年。SHA-2包含多个变种，主要有SHA-224、SHA-256、SHA-384、SHA-512等，输出的哈希值长度分别为224、256、384和512位。</p>
<p><strong>主要特性</strong>：</p>
<ol>
<li><strong>输出长度可变</strong>：SHA-2支持多种输出长度，适应不同安全需求。</li>
<li><strong>增强的安全性</strong>：相较于SHA-1，SHA-2提供更强的抗碰撞性和抗预映像性，当前被认为是安全的哈希算法。</li>
<li><strong>广泛应用</strong>：被广泛用于数据完整性验证、数字签名、SSL&#x2F;TLS证书等领域。</li>
</ol>
<h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充与分组"><a href="#数据填充与分组" class="headerlink" title="数据填充与分组"></a>数据填充与分组</h5><p>同MD5 算法、SHA-1 算法，第一步还是要将数据填充为512 bits 的整数倍，也就是64字节的整数倍。这些n 段512bits(64字节)的数据会作为原始信息进行处理。</p>
<h5 id="初始化MD-Buffer-1"><a href="#初始化MD-Buffer-1" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha256Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha256Context*      Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;curlen = <span class="hljs-number">0</span>;<br>    Context-&gt;length = <span class="hljs-number">0</span>;<br>    Context-&gt;state[<span class="hljs-number">0</span>] = <span class="hljs-number">0x6A09E667</span>UL;<br>    Context-&gt;state[<span class="hljs-number">1</span>] = <span class="hljs-number">0xBB67AE85</span>UL;<br>    Context-&gt;state[<span class="hljs-number">2</span>] = <span class="hljs-number">0x3C6EF372</span>UL;<br>    Context-&gt;state[<span class="hljs-number">3</span>] = <span class="hljs-number">0xA54FF53A</span>UL;<br>    Context-&gt;state[<span class="hljs-number">4</span>] = <span class="hljs-number">0x510E527F</span>UL;<br>    Context-&gt;state[<span class="hljs-number">5</span>] = <span class="hljs-number">0x9B05688C</span>UL;<br>    Context-&gt;state[<span class="hljs-number">6</span>] = <span class="hljs-number">0x1F83D9AB</span>UL;<br>    Context-&gt;state[<span class="hljs-number">7</span>] = <span class="hljs-number">0x5BE0CD19</span>UL;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="将512bits数据（164字节）扩展为644字节"><a href="#将512bits数据（164字节）扩展为644字节" class="headerlink" title="将512bits数据（164字节）扩展为644字节"></a>将512bits数据（16<em>4字节）扩展为64</em>4字节</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mCCj.png" srcset="/img/loading.gif" lazyload alt="image-20240919212319707"></p>
<p><img src="https://s21.ax1x.com/2024/09/28/pA1mP8s.png" srcset="/img/loading.gif" lazyload alt="image-20240919212345601"></p>
<h5 id="进入主循环，进行64次循环"><a href="#进入主循环，进行64次循环" class="headerlink" title="进入主循环，进行64次循环"></a>进入主循环，进行64次循环</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mi2n.png" srcset="/img/loading.gif" lazyload alt="image-20240919212616394"></p>
<p><img src="https://s2.loli.net/2024/09/29/HyfBTmEteP3s1h6.png" srcset="/img/loading.gif" lazyload alt="image-20240919213245654.png"></p>
<p>注意A、B、C、D 、E、F、G、H分别是上一段512bits 处理后留下来的8个整数(<strong>第一次运算的时候这8个数为固定的常数</strong>)。在对该512bits 数据运算前需要先把这8个整数临时存起来（作为下一组运算的初始值，一直到64 次循环彻底结束。）。</p>
<p><img src="https://s2.loli.net/2024/09/29/2MSCtv1HZTLQg4o.png" srcset="/img/loading.gif" lazyload alt="image-20240919212718907.png"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ed7f15772e4ddc5d23f140f85027b53.gif" srcset="/img/loading.gif" lazyload alt="W_t">表示一个32 bits(4个字节) 的输入数据(512bits 数据其中的32bits)，<img src="https://i-blog.csdnimg.cn/blog_migrate/23a5f8b290dde5116088d13bad292457.gif" srcset="/img/loading.gif" lazyload alt="K_t"> 表示一个32bits 的常数(这个也是固定的)</p>
<p><img src="https://s2.loli.net/2024/09/29/21ld5pgQmVKWs3t.png" srcset="/img/loading.gif" lazyload alt="image-20240919213306065.png"></p>
<h5 id="链接变量与初始链接变量进行求和运算-1"><a href="#链接变量与初始链接变量进行求和运算-1" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s2.loli.net/2024/09/29/xurShl8HjsMXFZN.png" srcset="/img/loading.gif" lazyload alt="image-20240919213011417.png"></p>
<h5 id="链接变量作为下一个明文分组的输入重复进行以上操作-1"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作-1" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p>
<h5 id="最后5个链接变量里面的数据就是SHA1摘要-1"><a href="#最后5个链接变量里面的数据就是SHA1摘要-1" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>最后一段512bits 运算后得到最终的A、B、C、D、E，即为最终的160bits数，因为需要得到最后256bits(64 位16进制)的字符串，所以要将每个4字节的数转换成8位的16进制字符串。</p>
<hr>
<h2 id="消息认证码法-Message-Authentication-Code"><a href="#消息认证码法-Message-Authentication-Code" class="headerlink" title="消息认证码法(Message Authentication Code)"></a>消息认证码法(Message Authentication Code)</h2><p><img src="https://s2.loli.net/2024/09/29/PG2V5SeEJ4IvfxH.png" srcset="/img/loading.gif" lazyload alt="image-20240919215256824"></p>
<p><strong>把哈希函数和密钥结合起来</strong>，将得到一个新的保护数据完整性的密码学原语——消息认证码(Message Authentication Code，MAC)。密钥是安全的基础：没有密钥就无法保证机密性，也无法实现认证性。虽然哈希函数可以为任意数据提供认证性或完整性，但它需要依赖于一个不可篡改的可信信道.</p>
<blockquote>
<p><em>比如：恶意用户可以修改cookie中的信息。若cookie中仅包含用户名及用户名的哈希值，则可以通过修改这些信息来模拟不同的用户</em></p>
<p><em>为了确保用户的cookie不被随意更改，我们可以使用上面提到的密码学原语。当用户第一次登录网站时，网站根据密钥和用户名生成一个认证标签，并让用户将用户名和认证标签存储在cookie中。由于不知道密钥，所以用户无法伪造其他用户名的有效认证标签。</em></p>
</blockquote>
<p>实现方式有：</p>
<table>
<thead>
<tr>
<th><strong>实现方式</strong></th>
<th><strong>原理</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>HMAC</strong></td>
<td>基于哈希函数与密钥结合，经过两次哈希生成认证码</td>
<td>简单易实现，支持多种哈希函数，安全性好</td>
<td>相较于其他方法，计算效率较低</td>
<td>网络协议（TLS、IPsec）、API认证、OAuth</td>
</tr>
<tr>
<td><strong>CMAC</strong></td>
<td>基于分组密码（如AES），通过分组加密生成认证码</td>
<td>适合硬件实现，安全性高</td>
<td>密钥管理相对复杂</td>
<td>无线通信协议（如IEEE 802.11i）、密码学库</td>
</tr>
<tr>
<td><strong>OMAC</strong></td>
<td>基于CMAC的简化版本，仅使用一个密钥</td>
<td>密钥管理简单，适合低资源场景</td>
<td>不适合并行计算</td>
<td>嵌入式系统</td>
</tr>
<tr>
<td><strong>PMAC</strong></td>
<td>通过块加密算法并行处理消息块生成认证码</td>
<td>支持并行处理，速度快</td>
<td>实现复杂度较高</td>
<td>高性能场景，如高速网络、数据加密存储</td>
</tr>
<tr>
<td><strong>GMAC</strong></td>
<td>基于Galois&#x2F;Counter Mode（GCM）模式生成认证码</td>
<td>高性能，支持并行处理</td>
<td>需要与加密模式结合使用</td>
<td>IPsec、TLS等加密协议</td>
</tr>
<tr>
<td><strong>Poly1305</strong></td>
<td>基于伪随机函数，通过模数运算生成认证码</td>
<td>轻量级设计，计算效率高</td>
<td>需要与ChaCha20等算法配合</td>
<td>嵌入式设备、高效加密协议（如TLS 1.3）</td>
</tr>
<tr>
<td><strong>CBC-MAC</strong></td>
<td>基于分组加密的CBC模式生成认证码</td>
<td>简单易实现</td>
<td>对变长消息不安全，容易受长度攻击</td>
<td>已被更安全的CMAC替代</td>
</tr>
</tbody></table>
<h3 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h3><h4 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>HMAC</strong>（基于哈希的消息认证码）是一种通过哈希函数生成消息认证码的算法。它的主要作用是验证消息的完整性和真实性，防止消息在传输过程中被篡改。HMAC 结合了加密哈希函数（如SHA-256或SHA-1）和一个密钥，生成一个固定长度的消息摘要。</p>
<h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://s2.loli.net/2024/09/29/p4hcDSjUk9e3YG2.png" srcset="/img/loading.gif" lazyload alt="image-20240919214933334"><br>其中：<br>H 为密码Hash函数（如MD5或SHA-2），能够对明文进行分组循环压缩；<br>k 为密钥（secret key）；<br>m 为要认证的消息；<br>k’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）<br>ipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；<br>opad 外部填充（0x363636…3636，一段十六进制常量)<br><img src="https://s2.loli.net/2024/09/29/2XDcgNFAbvwBxmG.png" srcset="/img/loading.gif" lazyload alt="R-C"></p>
<p>a) 在密钥k后面添加0，或者对密钥k用H（Hash函数）进行处理，创建一个字长为B的字符串（B为Hash函数的明文分组长度）；<br>b) 将上一步生成的B字长的字符串ipad做异或运算；<br>c)将数据流m填充至第二步的结果字符串中；<br>d)用H作用于第三步生成的数据流；<br>e)将第一步生成的B字长字符串与opad做异或运算；<br>f)再将第四步的结果填充进第五步的结果中；<br>g)用H作用于第六步生成的数据流，输出最终结果。</p>
<hr>
<h2 id="国密-SM3"><a href="#国密-SM3" class="headerlink" title="国密(SM3)"></a>国密(SM3)</h2><h3 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h3><p><strong>概述</strong>： SM3是一种由中国国家密码管理局设计的加密哈希函数，属于国密算法系列，发布于2010年。SM3主要用于确保数据完整性和身份验证，输出的哈希值长度为256位。(SM3广泛应用于电子商务、数字签名、区块链和信息安全等领域)</p>
<p><strong>主要特性</strong>：</p>
<ol>
<li><strong>输出固定长度</strong>：无论输入数据大小，SM3总是生成256位的哈希值。</li>
<li><strong>安全性</strong>：SM3经过严格的安全评估，具有良好的抗碰撞性和抗预映像性，适合用于高安全性需求的场合。</li>
<li><strong>高效性</strong>：在硬件和软件实现上具有较高的效率，适合处理大规模数据。</li>
</ol>
<h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h4><p><img src="https://s2.loli.net/2024/09/29/wTA6OfE2Yb4lJ5H.png" srcset="/img/loading.gif" lazyload alt="image-20240920102423212"></p>
<h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再<strong>用这16个消息字递推生成剩余的116个消息字</strong>。</p>
<p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p>
<p><img src="https://s2.loli.net/2024/09/29/SYcCjgi3HDQW2pN.png" srcset="/img/loading.gif" lazyload alt="image-20240920102620139"></p>
<h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p>这块结构和SHA系列算法也比较相似，由初始化向量然后对于每一个扩展后的消息进行处理，直到处理完最后一个分块。</p>
<p><img src="https://s2.loli.net/2024/09/29/xBK6a4djoQMH5tV.jpg" srcset="/img/loading.gif" lazyload alt="f0adf403fda784ac40e30771876caede (1)"></p>
<h5 id="压缩函数-核心"><a href="#压缩函数-核心" class="headerlink" title="压缩函数(核心)"></a>压缩函数(核心)</h5><p><img src="https://s2.loli.net/2024/09/29/1Ao9rcevbuyjOtM.png" srcset="/img/loading.gif" lazyload alt="image-20240920103047143"></p>
<p>其中初值IV被放在A、B、C、D、E、F、G、H八个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=32%E4%BD%8D%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:129692191%7D">32位变量</a>中</p>
<p>压缩函数将这八个变量进行64轮相同的计算，一轮的计算过程如下图所示：</p>
<p><img src="https://s2.loli.net/2024/09/29/PH7kIDdAfOyKMSc.jpg" srcset="/img/loading.gif" lazyload alt="748a9c1bcf39b12e4d868474649ff333"></p>
<p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://s2.loli.net/2024/09/29/DafG4M9qZjzh1LC.png" srcset="/img/loading.gif" lazyload alt="image-20240920103309918"></p>
<p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p>
<h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="Base系列算法"><a href="#Base系列算法" class="headerlink" title="Base系列算法"></a>Base系列算法</h2><h3 id="Base16编码"><a href="#Base16编码" class="headerlink" title="Base16编码"></a>Base16编码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Base16（也称为Hexadecimal或Hex）是一种常见的编码方式，用于将二进制数据转换为可读的文本格式。它使用16个不同的字符来表示每4位二进制数。Base16编码使用的字符集包括<code>0-9</code>和<code>A-F</code>，其中<code>A-F</code>代表10到15的数字。这种编码方式通常用于计算机系统中表示二进制数据，并且非常适合于调试和数据展示。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据（通常是字节）准备好。</li>
<li><strong>分组处理</strong>：将每个字节（8位）分解为两个4位的部分。</li>
<li><strong>映射字符</strong>：使用Base16字符集将每个4位部分映射为一个Base16字符。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base16字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base16编码后的字符串。</li>
<li><strong>字符映射</strong>：将每个Base16字符转换为对应的4位二进制值。</li>
<li><strong>合并处理</strong>：将这些4位二进制值重新组合成字节（8位），还原原始的二进制数据。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base16 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hexChars = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 每个字节对应两个十六进制字符</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &gt;&gt; <span class="hljs-number">4</span>]);   <span class="hljs-comment">// 高四位</span><br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &amp; <span class="hljs-number">0x0F</span>]); <span class="hljs-comment">// 低四位</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base16 解码函数</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">decodeHexChar</span><span class="hljs-params">(<span class="hljs-type">char</span> hexChar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid hex character&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base16 input length&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> high = <span class="hljs-built_in">decodeHexChar</span>(input[i]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> low = <span class="hljs-built_in">decodeHexChar</span>(input[i + <span class="hljs-number">1</span>]);<br>        output.<span class="hljs-built_in">push_back</span>((high &lt;&lt; <span class="hljs-number">4</span>) | low);  <span class="hljs-comment">// 高位和低位合并成一个字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase16</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase16</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base32编码"><a href="#Base32编码" class="headerlink" title="Base32编码"></a>Base32编码</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>Base32是一种编码方案，用于将二进制数据转换为可打印的文本格式。它使用32个不同的字符来表示每5位二进制数。Base32编码使用的字符集通常包括<code>A-Z</code>和<code>2-7</code>，这些字符在ASCII范围内都是可打印的。Base32通常用于需要对数据进行一定程度的可读性增强的场景，例如在URL中或在一些认证系统中。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好。</li>
<li><strong>分组处理</strong>：将数据分成每5位二进制的一组，每组对应一个Base32字符。</li>
<li><strong>映射字符</strong>：使用Base32字符集将每5位二进制数据映射为一个Base32字符。</li>
<li><strong>填充处理</strong>：如果数据长度不是5的倍数，使用<code>=</code>字符进行填充，以确保编码字符串的长度为8的倍数。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base32字符和填充字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base32编码后的字符串，并去除可能存在的填充字符<code>=</code>。</li>
<li><strong>字符映射</strong>：将每个Base32字符转换为对应的5位二进制值。</li>
<li><strong>合并处理</strong>：将这些5位二进制值重新组合成字节（8位），还原原始的二进制数据。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE32_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;<br><br><span class="hljs-comment">// Base32 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 将缓冲区左移8位</span><br>        buffer |= c;   <span class="hljs-comment">// 将当前字节加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">5</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &gt;&gt; (bitsLeft - <span class="hljs-number">5</span>)) &amp; <span class="hljs-number">0x1F</span>]);  <span class="hljs-comment">// 取高5位</span><br>            bitsLeft -= <span class="hljs-number">5</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余位数不足5位的情况</span><br>    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &lt;&lt; (<span class="hljs-number">5</span> - bitsLeft)) &amp; <span class="hljs-number">0x1F</span>]);<br>        paddingCount = (<span class="hljs-number">8</span> - (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">8</span>)) % <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Base32 的 &quot;=&quot; 填充字符</span><br>    output.<span class="hljs-built_in">append</span>(paddingCount, <span class="hljs-string">&#x27;=&#x27;</span>);<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base32 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            paddingCount++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = BASE32_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base32 character&quot;</span>);<br>        &#125;<br><br>        buffer &lt;&lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// 将缓冲区左移5位</span><br>        buffer |= index;  <span class="hljs-comment">// 将当前字符的值加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">5</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (bitsLeft - <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 取高8位</span><br>            bitsLeft -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase32</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase32</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base58-编码"><a href="#Base58-编码" class="headerlink" title="Base58 编码"></a>Base58 编码</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Base58是一种用于将二进制数据编码为可打印字符的方案，广泛应用于加密货币（如比特币地址）等领域。Base58编码通过去除Base64编码中的某些容易混淆的字符（如<code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>），使编码结果更易于手动输入和读取。它使用58个可打印的ASCII字符，编码效率高，每4字节二进制数据编码为5个Base58字符。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li>
<li><strong>转换为整数</strong>：将二进制数据转换为一个大整数。</li>
<li><strong>映射字符</strong>：用58作为基数，将大整数逐步除以58，得到的余数用于索引Base58字符集，从而得到Base58字符。</li>
<li><strong>处理前导零</strong>：在编码结果前添加相应数量的Base58字符<code>1</code>，以保持与原始数据前导零的对应关系。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base58字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base58编码后的字符串。</li>
<li><strong>字符映射</strong>：将每个Base58字符转换为其在Base58字符集中的索引值。</li>
<li><strong>转换为整数</strong>：将这些索引值重新组合成一个大整数。</li>
<li><strong>处理前导零</strong>：根据编码结果中的前导<code>1</code>的数量，将相应数量的前导零添加到解码结果中。</li>
<li><strong>转换为二进制数据</strong>：将大整数转换回二进制数据，得到原始数据。</li>
</ol>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE58_ALPHABET = <span class="hljs-string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span>;<br><br><span class="hljs-comment">// 辅助函数：将字节数组解释为大整数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">toBigInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(input.begin(), input.end())</span></span>;<br>    <span class="hljs-keyword">return</span> bigInt;<br>&#125;<br><br><span class="hljs-comment">// Base58 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; digits;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; bigInt = <span class="hljs-built_in">toBigInt</span>(input);<br><br>    <span class="hljs-comment">// 跳过前导的0字节</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte : bigInt) &#123;<br>        <span class="hljs-keyword">if</span> (byte == <span class="hljs-number">0</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将大整数转为Base58编码</span><br>    <span class="hljs-keyword">while</span> (!bigInt.<span class="hljs-built_in">empty</span>() &amp;&amp; *std::<span class="hljs-built_in">max_element</span>(bigInt.<span class="hljs-built_in">begin</span>(), bigInt.<span class="hljs-built_in">end</span>()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = carry * <span class="hljs-number">256</span> + byte;<br>            byte = value / <span class="hljs-number">58</span>;<br>            carry = value % <span class="hljs-number">58</span>;<br>        &#125;<br>        digits.<span class="hljs-built_in">push_back</span>(carry);<br>    &#125;<br><br>    <span class="hljs-comment">// 将前导0字节编码为Base58的`1`字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 反转余数得到的Base58编码</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = digits.<span class="hljs-built_in">rbegin</span>(); it != digits.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += BASE58_ALPHABET[*it];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Base58 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-type">size_t</span> index = BASE58_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base58 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> carry = index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = byte * <span class="hljs-number">58</span> + carry;<br>            carry = value &gt;&gt; <span class="hljs-number">8</span>;<br>            byte = value &amp; <span class="hljs-number">0xFF</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (carry) &#123;<br>            bigInt.<span class="hljs-built_in">push_back</span>(carry &amp; <span class="hljs-number">0xFF</span>);<br>            carry &gt;&gt;= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理前导的&#x27;1&#x27;字符</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bigInt.<span class="hljs-built_in">rbegin</span>(); it != bigInt.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(*it);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase58</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase58</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Base64是一种广泛使用的编码方式，将二进制数据转换为可打印的ASCII字符。它常用于在需要将二进制数据嵌入到文本格式中时（如在电子邮件、URL、JSON等）。Base64将每3字节的二进制数据编码为4个ASCII字符，使得编码后的数据长度增加约33%。Base64字符集包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>和<code>=</code>（作为填充字符）。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li>
<li><strong>分组处理</strong>：将数据分成每3字节（24位）的一组，如果数据长度不足3字节，则使用填充字符<code>=</code>进行填充，以确保处理的字节数为3的倍数。</li>
<li><strong>转换为6位组</strong>：将每组24位二进制数据分成4组6位的二进制数。</li>
<li><strong>映射字符</strong>：使用Base64字符集将每6位二进制数据映射为一个Base64字符。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base64字符和填充字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base64编码后的字符串，并去除填充字符<code>=</code>。</li>
<li><strong>字符映射</strong>：将每个Base64字符转换为对应的6位二进制值。</li>
<li><strong>组合处理</strong>：将这些6位二进制值重新组合成24位的二进制数据。</li>
<li><strong>分解字节</strong>：将24位二进制数据分解为3个字节（8位），还原原始的二进制数据。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE64_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-comment">// Base64 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output; <span class="hljs-comment">// 存储编码后的输出字符串</span><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储当前处理的字符值</span><br>    <span class="hljs-type">int</span> bits = <span class="hljs-number">-6</span>; <span class="hljs-comment">// 当前处理的位数，初始化为 -6，因为我们要填充 6 位的 Base64 字符</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b63 = <span class="hljs-number">0x3F</span>; <span class="hljs-comment">// 64 的二进制数（111111），用于获取 Base64 字符</span><br><br>    <span class="hljs-comment">// 遍历输入字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        val = (val &lt;&lt; <span class="hljs-number">8</span>) + c; <span class="hljs-comment">// 将当前字符的 ASCII 值添加到 val 中，左移 8 位</span><br>        bits += <span class="hljs-number">8</span>; <span class="hljs-comment">// 增加已处理的位数</span><br><br>        <span class="hljs-comment">// 当处理的位数大于等于 0 时，进行编码</span><br>        <span class="hljs-keyword">while</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从 val 中提取出高 6 位，并查找对应的 Base64 字符</span><br>            output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[(val &gt;&gt; bits) &amp; b63]);<br>            bits -= <span class="hljs-number">6</span>; <span class="hljs-comment">// 每次处理 6 位，减少 bits 的值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位，如果还有剩余的 bits &gt; -6，则需要继续编码</span><br>    <span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">-6</span>) &#123;<br>        <span class="hljs-comment">// 将剩余的位向左移动并提取对应的 Base64 字符</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[((val &lt;&lt; <span class="hljs-number">8</span>) &gt;&gt; (bits + <span class="hljs-number">8</span>)) &amp; b63]);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 output 的大小不是 4 的倍数，则添加 &#x27;=&#x27; 作为填充</span><br>    <span class="hljs-keyword">while</span> (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">4</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 添加填充字符 &#x27;=&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output; <span class="hljs-comment">// 返回编码后的 Base64 字符串</span><br>&#125;<br><br><br><span class="hljs-comment">// Base64 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        T[BASE64_ALPHABET[i]] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, bits = <span class="hljs-number">-8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        <span class="hljs-keyword">if</span> (T[c] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>        val = (val &lt;&lt; <span class="hljs-number">6</span>) + T[c];<br>        bits += <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">if</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>((val &gt;&gt; bits) &amp; <span class="hljs-number">0xFF</span>));<br>            bits -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase64</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    std::string decoded = <span class="hljs-built_in">decodeBase64</span>(encoded);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base85编码"><a href="#Base85编码" class="headerlink" title="Base85编码"></a>Base85编码</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>Base85是一种用于将二进制数据转换为可打印字符的编码方案。它通过使用85个不同的ASCII字符来表示每4字节（32位）的二进制数据。这种编码方式常用于需要将二进制数据嵌入文本中的场景，如在PDF文件中。相比于Base64，Base85编码能够以更高的效率将数据压缩成更短的字符串，因为每4字节的二进制数据在Base85中编码为5个字符。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li>
<li><strong>分组处理</strong>：将数据分成每4字节（32位）的组，如果数据长度不足4字节，则进行填充。</li>
<li><strong>转换为整数</strong>：将每4字节的二进制数据转换为一个32位的整数。</li>
<li><strong>映射字符</strong>：将32位整数转换为5个Base85字符。具体来说，整数被逐步除以85，得到的余数对应Base85字符集中的字符。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base85字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base85编码后的字符串。</li>
<li><strong>字符映射</strong>：将每个Base85字符转换为Base85字符集中的索引值。</li>
<li><strong>转换为整数</strong>：将这些索引值重新组合成一个32位的整数。</li>
<li><strong>分解字节</strong>：将32位整数转换回4字节（32位）的二进制数据。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE85_ALPHABET = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&amp;()*+-;&lt;=&gt;?@^_`&#123;|&#125;~&quot;</span>;<br><br><span class="hljs-comment">// Base85 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        buffer = buffer * <span class="hljs-number">256</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(input[i]);<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>                buffer /= <span class="hljs-number">85</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">end</span>());<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        buffer &lt;&lt;= (<span class="hljs-number">4</span> - count) * <span class="hljs-number">8</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>            buffer /= <span class="hljs-number">85</span>;<br>        &#125;<br>        output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">begin</span>() + count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base85 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE85_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base85 character&quot;</span>);<br>        &#125;<br>        buffer = buffer * <span class="hljs-number">85</span> + pos;<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>            &#125;<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>            buffer = buffer * <span class="hljs-number">85</span> + <span class="hljs-number">84</span>;  <span class="hljs-comment">// 用最大值填充</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">4</span> - count; --j) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase85</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase85</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base91编码"><a href="#Base91编码" class="headerlink" title="Base91编码"></a>Base91编码</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>Base91是一种编码方案，用于将二进制数据转换为可打印的ASCII字符。它使用91个字符来表示每13位的二进制数据。Base91设计的目的是在保证编码效率的同时，提供更好的数据密度比Base64和Base85。Base91编码通常用于需要高数据密度的应用场景，例如某些压缩算法和数据传输协议。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li>
<li><strong>分组处理</strong>：将数据分成每13位（即1.625字节）的组。由于13位并不整除8位字节，因此每个Base91编码块处理的字节数可能会有所不同。</li>
<li><strong>转换为整数</strong>：将每组13位的二进制数据转换为一个大整数。</li>
<li><strong>映射字符</strong>：将这个整数转换为Base91字符。整数会被逐步除以91，得到的余数对应Base91字符集中的字符。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base91字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base91编码后的字符串。</li>
<li><strong>字符映射</strong>：将每个Base91字符转换为Base91字符集中的索引值。</li>
<li><strong>转换为整数</strong>：将这些索引值重新组合成一个13位的二进制整数。</li>
<li><strong>分解字节</strong>：将13位的二进制整数转换回原始的字节数据。这可能涉及到将整数拆分为多个字节（通常是2或3个字节）。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base91 字符集</span><br><span class="hljs-type">const</span> std::string BASE91_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span><br>                                    <span class="hljs-string">&quot;!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~\&quot;&quot;</span>;<br><br><span class="hljs-comment">// Base91 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer |= (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(c) &lt;&lt; bitsLeft);<br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-type">uint32_t</span> value = buffer &amp; <span class="hljs-number">8191</span>;  <span class="hljs-comment">// 取13位</span><br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">88</span>) &#123;                <span class="hljs-comment">// 处理特殊情况</span><br>                buffer &gt;&gt;= <span class="hljs-number">13</span>;<br>                bitsLeft -= <span class="hljs-number">13</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                value = buffer &amp; <span class="hljs-number">16383</span>;      <span class="hljs-comment">// 取14位</span><br>                buffer &gt;&gt;= <span class="hljs-number">14</span>;<br>                bitsLeft -= <span class="hljs-number">14</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value % <span class="hljs-number">91</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余不足13位的部分</span><br>    <span class="hljs-keyword">if</span> (bitsLeft) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer % <span class="hljs-number">91</span>]);<br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">7</span> || buffer &gt; <span class="hljs-number">90</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base91 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE91_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base91 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>            value = pos;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            value += pos * <span class="hljs-number">91</span>;<br>            buffer |= value &lt;&lt; bitsLeft;<br>            bitsLeft += (value &amp; <span class="hljs-number">8191</span>) &gt; <span class="hljs-number">88</span> ? <span class="hljs-number">13</span> : <span class="hljs-number">14</span>;<br><br>            <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>                output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);<br>                buffer &gt;&gt;= <span class="hljs-number">8</span>;<br>                bitsLeft -= <span class="hljs-number">8</span>;<br>            &#125;<br>            value = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位</span><br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(buffer | (value &lt;&lt; bitsLeft));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase91</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase91</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Base100编码"><a href="#Base100编码" class="headerlink" title="Base100编码"></a>Base100编码</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>Base100是一种用于将二进制数据转换为可打印字符的编码方案。它使用100个不同的字符来表示每16位的二进制数据。这种编码方式在字符集选择上较为宽松，通常选择可打印的ASCII字符。Base100的设计旨在提供比Base64和Base85更高的数据密度，使得编码后的数据更为紧凑。</p>
<p>编码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li>
<li><strong>分组处理</strong>：将数据分成每16位（即2字节）的组。如果数据长度不足2字节，则进行填充。</li>
<li><strong>转换为整数</strong>：将每16位的二进制数据转换为一个大整数。</li>
<li><strong>映射字符</strong>：将这个整数转换为Base100字符。整数会被逐步除以100，得到的余数对应Base100字符集中的字符。</li>
<li><strong>输出结果</strong>：将所有映射得到的Base100字符连接起来，形成编码后的字符串。</li>
</ol>
<p>解码步骤</p>
<ol>
<li><strong>输入数据准备</strong>：获取Base100编码后的字符串。</li>
<li><strong>字符映射</strong>：将每个Base100字符转换为Base100字符集中的索引值。</li>
<li><strong>转换为整数</strong>：将这些索引值重新组合成一个16位的二进制整数。</li>
<li><strong>分解字节</strong>：将16位的二进制整数转换回原始的字节数据，通常是2个字节（或1个字节的填充情况）。</li>
<li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li>
</ol>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base100 字符集 (ASCII 范围: 33-132)</span><br><span class="hljs-type">const</span> std::string BASE100_ALPHABET = <span class="hljs-string">&quot; !\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span><br>                                     <span class="hljs-string">&quot;€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ&quot;</span>;<br><br><span class="hljs-comment">// Base100 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer = (buffer &lt;&lt; <span class="hljs-number">8</span>) | c;<br>        count++;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 填充一个字节</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base100 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 input length.&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> index1 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-type">int</span> index2 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i + <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">if</span> (index1 == std::string::npos || index2 == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 character.&quot;</span>);<br>        &#125;<br><br>        buffer = index1 * <span class="hljs-number">100</span> + index2;<br>        output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 高字节</span><br>        output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);         <span class="hljs-comment">// 低字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase100</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase100</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.equinox.chat/archives/45/">Base系列编码详解 - 二进制学习 (equinox.chat)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62690279/article/details/123941239">常见加密算法总结-base系列部分_base加密-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://danielxuuuuu.github.io/2019/11/18/MD5%E7%AE%97%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84">MD5算法的C语言实现 · Daniel’s Studio (danielxuuuuu.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/foxclever/p/7668369.html">信息摘要算法之一：MD5算法解析及实现 - Moonan - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/450180396">RSA —— 经典的非对称加密算法 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二） - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<p>[RSA算法详解 - 飞翔的大熊 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA算法流程</a> 1 生成秘钥 选择两个不相等的质数p%2Cq 计算p%2Cq的乘积n 计算n的欧拉函数φ (n)%3D (p-1)*,根据上面的公式可以算出密文C 解密 接收方获取密文c，使用自己的私钥 (n%2Cd)依照如下公式解密 c^d%3Dm (mod n) c%2Cd%2Cn已知，可以算出明文m)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s2603898260/article/details/122389816">RSA 算法图解+数学证明_rsa算法流程图-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98514678">AES加密算法流程介绍 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiao__1bai/article/details/123307059">解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shelmean/p/14281332.html">RC4加密算法 - shelmean - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c34y1M7NW/?spm_id_from=333.999.0.0">HMAC | MAC | 基于哈希函数的消息认证码</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="category-chain-item">密码学</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" class="print-no-link">#密码学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>密码学体系框架</div>
      <div>http://example.com/2023/07/15/密码学/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/10/Golang%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/" title="Goalng语法概览">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Goalng语法概览</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/02/%E9%AB%98%E6%80%A7%E8%83%BD(%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5-%E9%9B%86%E7%BE%A4)-Redis/" title="高性能(主从复制-哨兵-集群)">
                        <span class="hidden-mobile">高性能(主从复制-哨兵-集群)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
