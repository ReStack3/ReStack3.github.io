

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="索引的基本思想 索引是提升查询速度的一种数据结构，可以理解为类似书的目录。索引之所以能提升查询速度，在于它在插入时对数据进行了排序（显而易见，其缺点是影响插入或者更新的性能）。有效的设计并创建索引可以提升数据库系统的整体性能，但是也要考虑索引维护带来的成本消耗。 索引的演化历史 关于索引的知识具体可以参考： 为什么MySQL的主键查询这么快 | 蝉沐风 从数据页的角度看 B+ 树 | 小林codi">
<meta property="og:type" content="article">
<meta property="og:title" content="查询优化(索引角度)">
<meta property="og:url" content="http://example.com/2023/05/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="索引的基本思想 索引是提升查询速度的一种数据结构，可以理解为类似书的目录。索引之所以能提升查询速度，在于它在插入时对数据进行了排序（显而易见，其缺点是影响插入或者更新的性能）。有效的设计并创建索引可以提升数据库系统的整体性能，但是也要考虑索引维护带来的成本消耗。 索引的演化历史 关于索引的知识具体可以参考： 为什么MySQL的主键查询这么快 | 蝉沐风 从数据页的角度看 B+ 树 | 小林codi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-16T01:12:18.000Z">
<meta property="article:modified_time" content="2025-03-18T11:43:08.616Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>查询优化(索引角度) - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="查询优化(索引角度)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-16 09:12" pubdate>
          2023年5月16日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">查询优化(索引角度)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="索引的基本思想"><a href="#索引的基本思想" class="headerlink" title="索引的基本思想"></a>索引的基本思想</h1><p> 索引是<strong>提升查询速度的一种数据结构</strong>，可以理解为类似书的目录。索引之所以能提升查询速度，在于它在插入时对数据进行了排序（显而易见，其缺点是影响插入或者更新的性能）。有效的设计并创建索引可以提升数据库系统的整体性能，但是也要考虑索引维护带来的成本消耗。</p>
<h1 id="索引的演化历史"><a href="#索引的演化历史" class="headerlink" title="索引的演化历史"></a>索引的演化历史</h1><blockquote>
<p>关于索引的知识具体可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.chanmufeng.com/posts/storage/MySQL/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%9A%84%E4%B8%BB%E9%94%AE%E6%9F%A5%E8%AF%A2%E8%BF%99%E4%B9%88%E5%BF%AB.html">为什么MySQL的主键查询这么快 | 蝉沐风</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">从数据页的角度看 B+ 树 | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dl962454/article/details/115800802">【MySQL】MySQL为什么用B+树做索引而不用B-树或红黑树？_innodb为什么不用红黑树-CSDN博客</a></p>
</blockquote>
<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a><strong>使用索引</strong></h2><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在使用联合索引时，索引的列顺序决定了查询能否有效利用索引。具体来说，查询条件必须从复合索引的最左列开始，并且连续使用索引中的列，才能充分利用索引。什么意思呢？</p>
<p>例如：复合索引是由多个列组成的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> users(name, age);<br></code></pre></td></tr></table></figure>

<p>这个索引先按<code>name</code>排序，再按<code>age</code>排序。</p>
<p>该联合索引的B+树数据页内的记录首先按照<code>name</code>字段进行排序，<code>name</code>字段相同的情况下，再按照<code>age</code>字段进行排序。</p>
<p>所以，如果我们直接使用<code>age</code>字段进行搜索，无法利用索引的顺序性。</p>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><blockquote>
<p>在前面索引篇，前辈提到：</p>
<p>通过二级索引找到B+树中的叶子结点，但是二级索引的叶子节点的内容并不全，只有索引列的值和主键值。我们需要拿着主键值再去聚簇索引（主键索引）的叶子节点中去拿到完整的用户记录，这个过程叫做回表。</p>
</blockquote>
<p>由于：二级索引的叶子节点是按照 <code>name</code> 字段排序的，而主键 <code>id</code> 在二级索引中的排布是随机的。当 MySQL 通过二级索引找到主键 <code>id</code> 后，需要根据 <code>id</code> 去聚簇索引中查找完整的行数据。</p>
<p>由于 <code>id</code> 的排布是随机的，回表操作可能会导致 MySQL 在聚簇索引中反复跳跃访问不同的数据页（Page），从而产生 <strong>随机 I&#x2F;O</strong>。</p>
<p>而随机I&#x2F;O由于数据页在磁盘上是分散存储的，访问速度慢。如果目标数据页不在内存中，MySQL 需要从磁盘中加载数据页（16KB）到内存中，随机 I&#x2F;O 的代价非常高。</p>
<blockquote>
<p>所以尽量地减少回表操作带来的损耗：</p>
<ol>
<li>能不回表就不回；</li>
<li>必须回表就减少回表的次数。</li>
</ol>
</blockquote>
<p>这时如果查询的列都包含在二级索引中，MySQL 可以直接从二级索引中获取数据，而不需要回表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设 name 是二级索引</span><br><span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>如果 <code>name</code> 是二级索引，且查询只需要 <code>id</code> 和 <code>name</code>，MySQL 可以直接从二级索引中返回结果，无需回表。</p>
<blockquote>
<p>把索引中已经包含了所有需要读取的列数据的查询方式称为<strong>覆盖索引</strong>（或<strong>索引覆盖</strong>）。</p>
</blockquote>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是 MySQL 5.6 引入的一项优化技术，旨在减少回表操作的次数。核心思想是：<strong>将过滤条件下推到存储引擎层执行，而不是在 Server 层执行</strong>。这样可以减少存储引擎返回给 Server 层的数据量，进而减少回表操作的次数。</p>
<p>假设有一个 <code>user_innodb</code> 表，表结构如下：</p>
<table>
<thead>
<tr>
<th>id (主键)</th>
<th>name</th>
<th>phone</th>
</tr>
</thead>
<tbody><tr>
<td>3485</td>
<td>王晓</td>
<td>1234566606</td>
</tr>
<tr>
<td>78921</td>
<td>王晓</td>
<td>1234566607</td>
</tr>
<tr>
<td>423476</td>
<td>王晓</td>
<td>1234566608</td>
</tr>
</tbody></table>
<p>在 <code>name</code> 和 <code>phone</code> 字段上创建了联合索引 <code>idx_name_phone</code>。</p>
<p>查询需求：查找所有 <code>name</code> 为「王晓」且 <code>phone</code> 尾号为「6606」的记录。查询 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_innodb <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> &quot;王晓&quot; <span class="hljs-keyword">AND</span> phone <span class="hljs-keyword">LIKE</span> &quot;%6606&quot;;<br></code></pre></td></tr></table></figure>

<p>在没有索引下推的情况下，查询的执行过程如下：</p>
<p><strong>步骤 1：使用联合索引查找 <code>name</code> 为「王晓」的记录</strong></p>
<p>通过联合索引 <code>idx_name_phone</code>，找到所有 <code>name</code> 为「王晓」的记录。假设找到 3 条记录，对应的主键 <code>id</code> 为：<code>3485</code>、<code>78921</code>、<code>423476</code>。</p>
<p><strong>步骤 2：回表操作</strong></p>
<p>根据主键 <code>id</code> 回表，从聚簇索引中获取完整的行数据。回表 3 次，获取 3 条完整的记录。</p>
<p><strong>步骤 3：Server 层过滤</strong></p>
<p>将 3 条完整的记录返回给 MySQL 的 Server 层。Server 层根据 <code>phone LIKE &quot;%6606&quot;</code> 条件进行过滤，最终返回 1 条符合条件的记录。</p>
<p><strong>问题是</strong>：</p>
<p>即使只有 1 条记录符合 <code>phone LIKE &quot;%6606&quot;</code> 条件，存储引擎仍然需要回表 3 次，将 3 条记录返回给 Server 层。如果 <code>name</code> 为「王晓」的记录有 10 万条，而只有 1 条符合 <code>phone LIKE &quot;%6606&quot;</code> 条件，存储引擎需要回表 10 万次，将 10 万条记录返回给 Server 层，造成大量的无效回表和数据传输。</p>
<hr>
<p><strong>这时就需要引入 索引下推了</strong></p>
<p><strong>步骤 1：使用联合索引查找 <code>name</code> 为「蝉沐风」的记录</strong></p>
<p>通过联合索引 <code>idx_name_phone</code>，找到所有 <code>name</code> 为「王晓」的记录。假设找到 3 条记录，对应的主键 <code>id</code> 为：<code>3485</code>、<code>78921</code>、<code>423476</code>。</p>
<p><strong>步骤 2：在存储引擎层过滤 <code>phone LIKE &quot;%6606&quot;</code></strong></p>
<p>存储引擎直接在联合索引的叶子节点中过滤 <code>phone LIKE &quot;%6606&quot;</code> 条件。只有符合条件的记录才会回表。</p>
<p><strong>步骤 3：回表操作</strong></p>
<p>假设只有 1 条记录符合 <code>phone LIKE &quot;%6606&quot;</code> 条件，存储引擎只需要回表 1 次，获取完整的行数据。</p>
<p><strong>优势</strong></p>
<ul>
<li>减少了回表次数：从 3 次减少到 1 次。</li>
<li>减少了数据传输量：从 3 条记录减少到 1 条记录。</li>
</ul>
<p>使用条件：索引下推适用于联合索引，因为联合索引的叶子节点中包含了多个字段的值。过滤条件必须包含在联合索引中。索引下推是 MySQL 5.6 及以上版本的功能，默认开启。</p>
<p>这些是数据库索引设计中的核心原则，目的是为了 <strong>提升查询性能</strong> 和 <strong>减少资源消耗</strong>。下面详细解释每一条原则的原因和适用场景。</p>
<hr>
<h3 id="不为离散度低的列创建索引"><a href="#不为离散度低的列创建索引" class="headerlink" title="不为离散度低的列创建索引"></a><strong>不为离散度低的列创建索引</strong></h3><p><strong>离散度</strong>：指列中不同值的数量与总行数的比例。离散度低的列（如性别、状态等）只有少数几个不同的值。</p>
<p><strong>索引效果差</strong>：</p>
<ul>
<li>如果列的离散度低，索引无法有效过滤数据，查询时仍然需要扫描大量数据。例如，性别列只有「男」和「女」两个值，创建索引后，查询时仍然需要扫描大约 50% 的数据。</li>
</ul>
<p>只为离散度高的列（如用户 ID、手机号等）创建索引。</p>
<hr>
<h3 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a><strong>只为用于搜索、排序或分组的列创建索引</strong></h3><p><strong>索引的作用</strong>：加速搜索（<code>WHERE</code> 条件），加速排序（<code>ORDER BY</code>），加速分组（<code>GROUP BY</code>）。如果列不用于以上，创建索引只会增加存储和维护开销，而不会提升查询性能。</p>
<p>只为实际用于查询条件的列创建索引。</p>
<hr>
<h3 id="对过长的字段，建立前缀索引"><a href="#对过长的字段，建立前缀索引" class="headerlink" title="对过长的字段，建立前缀索引"></a><strong>对过长的字段，建立前缀索引</strong></h3><p>如果字段过长（如 <code>VARCHAR(255)</code>），索引会占用大量存储空间。长字段的索引查询效率较低，因为需要比较更多的字节。</p>
<p><strong>前缀索引</strong>：</p>
<ul>
<li>只对字段的前缀部分创建索引，减少索引大小。</li>
<li>需要在索引长度和选择性之间找到平衡。</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 对 email 字段的前 10 个字符创建前缀索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_email_prefix <span class="hljs-keyword">ON</span> users(email(<span class="hljs-number">10</span>));<br><br><span class="hljs-comment">-- 查询时，前缀索引可以加速搜索</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;example%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>适用于长字符串字段（如 <code>VARCHAR</code>、<code>TEXT</code>）。</p>
<p>需要根据字段的选择性（不同前缀的数量）确定前缀长度。</p>
<hr>
<h3 id="用好联合索引"><a href="#用好联合索引" class="headerlink" title="用好联合索引"></a><strong>用好联合索引</strong></h3><p>联合索引可以同时覆盖多个列，支持多条件查询。遵循 <strong>最左前缀原则</strong>，可以加速复合条件的查询。</p>
<p>使用联合索引可以减少单列索引的数量，降低存储和维护开销。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建联合索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_name_phone <span class="hljs-keyword">ON</span> users(name, phone);<br><br><span class="hljs-comment">-- 查询时，联合索引可以加速多条件查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span> <span class="hljs-keyword">AND</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1234567890&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<p>多条件查询（如 <code>WHERE name = &#39;John&#39; AND phone = &#39;1234567890&#39;</code>）。</p>
<p>排序和分组（如 <code>ORDER BY name, phone</code>）。</p>
<h3 id="频繁更新的值，不要作为主键或索引"><a href="#频繁更新的值，不要作为主键或索引" class="headerlink" title="频繁更新的值，不要作为主键或索引"></a>频繁更新的值，不要作为主键或索引</h3><p>索引（如 B+树）是根据索引列的值排序的。如果索引列的值频繁更新，索引结构需要频繁调整。</p>
<ul>
<li>每次更新索引列的值，都需要删除旧的索引条目并插入新的索引条目。</li>
<li>如果索引列是主键，还需要更新聚簇索引（Clustered Index），因为聚簇索引的叶子节点存储了完整的行数据。</li>
</ul>
<p>同时频繁更新索引列会导致大量的写操作，增加磁盘 I&#x2F;O 和 CPU 开销。更新索引时可能需要加锁，导致并发性能下降。</p>
<h2 id="多表查询优化"><a href="#多表查询优化" class="headerlink" title="多表查询优化"></a>多表查询优化</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>等需要进行多表查询时，第一个最容易想到的就是子查询(根据 SQL 标准，将一个<strong>查询块</strong>嵌套进一个<strong>表达式</strong>中，我们就得到了一个子查询。)</p>
<p>但子查询的性能存在很大的不足：</p>
<ul>
<li><strong>嵌套查询</strong>：子查询通常需要嵌套执行，外层查询依赖于内层查询的结果，这会导致多次扫描表。</li>
<li><strong>临时表</strong>：MySQL在处理子查询时，可能会创建临时表来存储子查询的结果，这会增加额外的I&#x2F;O开销。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>在这个查询中，MySQL需要先执行子查询<code>SELECT user_id FROM orders WHERE amount &gt; 100</code>，然后将结果作为外层查询的条件。如果<code>orders</code>表数据量很大，子查询的结果集也会很大，导致外层查询性能下降。</p>
<blockquote>
<p>子查询深究起来一点不简单：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/350009405">子查询漫谈 - 知乎</a></p>
</blockquote>
<p>如果非要使用子查询需要明白什么时候用EXISTS和IN</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p><strong><code>IN</code> 的底层实现原理</strong></p>
<ol>
<li><code>IN</code> 子查询会先执行子查询，生成一个结果集。</li>
<li>外层查询会将每一行与子查询的结果集进行比较，判断是否匹配。</li>
<li>如果子查询的结果集很大，<code>IN</code> 的性能会显著下降。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> orders o <span class="hljs-keyword">WHERE</span> o.user_id <span class="hljs-operator">=</span> u.id <span class="hljs-keyword">AND</span> o.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p> <strong><code>EXISTS</code> 的底层实现原理</strong></p>
<ol>
<li><code>EXISTS</code> 子查询不会生成一个完整的结果集，而是通过关联子查询（Correlated Subquery）逐行判断是否存在匹配项。</li>
<li>外层查询的每一行都会触发一次子查询，子查询只需要返回一个布尔值（是否存在匹配项）。</li>
</ol>
<p>可以看出：<strong>exists只有内表可以用上索引</strong>，外层循环必须要走一个遍历过程；<strong>而in内表和外表都可以用上索引</strong>，因为in本质上属于多个条件查询的并集(or)。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/taomeechildren/article/details/128922688">从原理浅析MySQL中exists和in的区别（如何选用exists和in）_mysql中如何用exists代替in-CSDN博客</a></p>
</blockquote>
<p><strong>如何选用exists和in？</strong></p>
<p>当两个表的大小相当时，用exists和in的效率差别不大。<br>如果两个表一个大一个小，</p>
<p>则子查询表(即内表)大的用exists，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> orders o <span class="hljs-keyword">WHERE</span> o.user_id <span class="hljs-operator">=</span> u.id);<br></code></pre></td></tr></table></figure>

<p>子查询表(即内表)小的用in。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> orders);<br></code></pre></td></tr></table></figure>

<p>其实就是”<strong>小表驱动大表</strong>“的思想：</p>
<ul>
<li><strong>驱动表</strong>：外层查询的表，通常是较小的表。</li>
<li><strong>被驱动表</strong>：子查询的表，通常是较大的表。</li>
<li><strong>优化目标</strong>：减少被驱动表的扫描次数，提升查询性能。</li>
</ul>
<p><strong><code>IN</code> 的驱动关系</strong>:子查询表（内表）是驱动表。外层查询表（外表）是被驱动表。</p>
<p><strong><code>EXISTS</code> 的驱动关系</strong>:外层查询表（外表）是驱动表。子查询表（内表）是被驱动表。</p>
<p>MySQL 的优化器会自动根据表的大小调整驱动表，即使写了 <code>LEFT JOIN</code>，优化器也可能将小表作为驱动表。(MySQL 优化器会根据表的统计信息（如行数、索引等）选择最优的驱动表。)</p>
<h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><blockquote>
<p>Join用法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36501591/article/details/116234694">MySQL基础——多表查询（各种join连接详解）_三个表join怎样关联-CSDN博客</a></p>
<p>Join的底层原理：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150420895">join连接的底层原理 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2140975">mysql进阶优化篇04——深入JOIN语句的底层原理-腾讯云开发者社区-腾讯云</a></p>
</blockquote>
<p>相比较于子查询，Join就有了比较大的优势：</p>
<ul>
<li><strong>单次扫描</strong>：<code>JOIN</code>通常只需要扫描一次表，减少了I&#x2F;O开销。</li>
<li><strong>索引利用</strong>：<code>JOIN</code>可以更好地利用索引，尤其是在连接列上有索引的情况下。</li>
<li><strong>减少临时表</strong>：<code>JOIN</code>通常不需要创建临时表，减少了额外的开销。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> u.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id <span class="hljs-keyword">WHERE</span> o.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>

<p>值得注意的是：虽然<code>JOIN</code>通常比子查询更高效，但在某些场景下，子查询仍然是合理的选择：</p>
<ul>
<li><strong>简单子查询</strong>：如果子查询的结果集很小，且外层查询的条件可以充分利用索引，子查询的性能影响较小。</li>
<li><strong>逻辑清晰</strong>：在某些复杂的查询中，子查询可以使逻辑更清晰，便于维护。</li>
</ul>
<blockquote>
<p><strong>优先使用JOIN</strong>：在大多数情况下，优先使用<code>JOIN</code>替代子查询。<strong>使用EXISTS代替IN</strong>：如果必须使用子查询，可以考虑使用<code>EXISTS</code>代替<code>IN</code>，因为<code>EXISTS</code>通常更高效。</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><strong>使用LIMIT</strong>：限制返回的行数，减少查询结果集。</li>
<li>**避免SELECT ***：只选择需要的列，减少数据传输量。</li>
<li><strong>使用AND代替OR</strong>：<code>AND</code>条件通常比<code>OR</code>条件更高效。</li>
<li><strong>使用索引列排序</strong>：在ORDER BY和GROUP BY的列上创建索引。</li>
<li><strong>使用合适的数据类型</strong>：选择最合适的数据类型，减少存储空间和提高查询效率。</li>
<li><strong>查询缓存</strong>：启用查询缓存，缓存常用查询结果。</li>
<li><strong>应用程序缓存</strong>：在应用程序层缓存查询结果，减少数据库访问。</li>
</ul>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000044539044">性能优化 - MySQL优化：12种提升SQL执行效率的有效方法 - 架构师技术栈 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375828064">高mysql千万级大数据SQL查询优化几十条经验 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41942838/article/details/111244411">MySQL性能优化：优化思路、查询优化、索引优化、存储优化、数据库结构优化、数据库结构优化_mysql查询优化,索引优化,存储优化-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554034113">最全Mysql查询性能优化总结（超详细） - 知乎</a></p>
</blockquote>
<h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><h2 id="联合索引未使用最左前缀"><a href="#联合索引未使用最左前缀" class="headerlink" title="联合索引未使用最左前缀"></a><strong>联合索引未使用最左前缀</strong></h2><p>复合索引未从最左列开始使用。不多介绍</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> users(name, age);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure>

<h2 id="LIKE模糊查询"><a href="#LIKE模糊查询" class="headerlink" title="LIKE模糊查询"></a><strong>LIKE模糊查询</strong></h2><p><code>LIKE</code>查询以通配符开头。模糊查询中，如果通配符（<code>%</code>或<code>_</code>）出现在字符串的开头（如<code>%abc</code>），MySQL无法利用索引进行快速查找。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%John%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> 注意：B+树索引是基于值的精确匹配或前缀匹配构建的，模糊查询中的通配符在开头时，无法利用索引的有序性。</p>
</blockquote>
<p>B+树索引是按列值的有序结构存储的，查询时可以从根节点快速定位到叶子节点。对于<code>LIKE &#39;abc%&#39;</code>，MySQL可以利用<strong>索引的前缀匹配特性</strong>，快速定位到以<code>abc</code>开头的值。对于<code>LIKE &#39;%abc&#39;</code>，MySQL无法确定<code>abc</code>在字符串中的位置，只能逐行扫描整个表，导致索引失效。</p>
<h2 id="使用反向查询（-NOT-LIKE）"><a href="#使用反向查询（-NOT-LIKE）" class="headerlink" title="使用反向查询（!&#x3D;, &lt;&gt;,NOT LIKE）"></a>使用反向查询（!&#x3D;, &lt;&gt;,NOT LIKE）</h2><p>索引是基于值的排序结构，适合范围查询和等值查询。而</p>
<p><code>!=</code>、<code>&lt;&gt;</code>、<code>NOT LIKE</code> 等反向查询无法利用索引的有序性。MySQL 需要扫描整个索引或表，判断哪些值不满足条件。</p>
<h2 id="OR条件"><a href="#OR条件" class="headerlink" title="OR条件"></a><strong>OR条件</strong></h2><p>MySQL 只能为每个查询条件使用一个索引。如果 <code>OR</code> 条件中有一个列没有索引，MySQL 无法使用索引优化查询。MySQL 需要扫描整个表，判断哪些行满足 <code>OR</code> 条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">OR</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>如果<code>name</code>列没有索引，即使<code>id</code>有索引，索引也会失效。</p>
<h2 id="使用了UNION"><a href="#使用了UNION" class="headerlink" title="使用了UNION"></a><strong>使用了<code>UNION</code></strong></h2><p><code>UNION</code> 会将多个查询的结果集合并，并去除重复行。MySQL 需要为每个子查询生成临时表，并对临时表进行去重操作。</p>
<ul>
<li>临时表没有索引，导致查询性能下降。</li>
<li>如果子查询本身没有使用索引，<code>UNION</code> 的性能会更差。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">123</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure>

<p>即使<code>id</code>有索引，<code>UNION</code>操作可能导致索引失效。</p>
<h2 id="使用了JOIN"><a href="#使用了JOIN" class="headerlink" title="使用了JOIN"></a><strong>使用了<code>JOIN</code></strong></h2><p>使用JOIN进行查询尤其需要注意以下几点：</p>
<ul>
<li><strong>未使用索引列</strong>：如果<code>JOIN</code>的列没有索引，MySQL需要对表进行全表扫描。</li>
<li><strong>数据类型不匹配</strong>：<code>JOIN</code>列的数据类型不一致时，MySQL需要进行类型转换，导致索引失效。</li>
<li><strong>索引选择性低</strong>：如果<code>JOIN</code>列的索引选择性低（如性别列只有<code>Male</code>和<code>Female</code>），MySQL可能选择全表扫描。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id;<br></code></pre></td></tr></table></figure>

<p><strong>JOIN的执行过程</strong>：</p>
<ul>
<li>MySQL会根据<code>JOIN</code>的类型（如<code>INNER JOIN</code>、<code>LEFT JOIN</code>）和条件，选择最优的执行计划。</li>
<li>如果<code>JOIN</code>列有索引，MySQL会使用索引查找匹配的行（如Nested Loop Join）。</li>
<li>如果<code>JOIN</code>列没有索引，MySQL需要对表进行全表扫描，导致性能下降。</li>
</ul>
<h2 id="对索引列做任何操作"><a href="#对索引列做任何操作" class="headerlink" title="对索引列做任何操作"></a>对索引列做任何操作</h2><p>如果不是单纯使用索引列，而是对索引列做了其他操作，例如数值计算、使用函数、（手动或自动）类型转换等操作，会导致索引失效。</p>
<p>索引（如 B+树）是根据索引列的值排序的。如果对索引列进行操作（如函数、计算、类型转换），MySQL 无法直接使用索引的有序性。例如，<code>WHERE YEAR(created_at) = 2023</code> 中，<code>YEAR(created_at)</code> 是对 <code>created_at</code> 列的操作，索引无法直接使用。</p>
<p>尽量避免对索引列进行操作。如果必须操作，可以考虑创建函数索引（MySQL 8.0+ 支持）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>索引的作用</strong></td>
<td>1. 提高查询速度，通过减少扫描的数据量，避免全表扫描。2. 加速排序和分组操作。3. 实现唯一性约束，确保数据的唯一性。</td>
</tr>
<tr>
<td><strong>索引结构</strong></td>
<td>1. <strong>B树索引</strong>：自平衡的树结构，适合常见的等值和范围查询。2. <strong>哈希索引</strong>：基于哈希表，适用于等值查询。3. <strong>全文索引</strong>：适用于文本搜索，采用倒排索引。4. <strong>空间索引</strong>：用于空间数据的索引。</td>
</tr>
<tr>
<td><strong>索引工作原理</strong></td>
<td>1. <strong>查找</strong>：通过索引快速定位数据，避免全表扫描。2. <strong>范围查询</strong>：使用B树索引，快速定位范围的起始位置并顺序扫描。3. <strong>覆盖索引</strong>：查询字段全部在索引中，直接从索引中获取数据，减少对数据表的访问。</td>
</tr>
<tr>
<td><strong>索引分类</strong></td>
<td>1. <strong>单列索引</strong>：在单一列上创建的索引。2. <strong>联合索引</strong>：多个列上创建的索引，适用于多列查询。3. <strong>唯一索引</strong>：确保索引列中的值唯一。</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td><strong>优点</strong>：1. 提高查询速度。2. 优化排序、分组等操作。3. 实现唯一性约束。<strong>缺点</strong>：1. 占用存储空间。2. 插入、更新、删除时性能开销较大。</td>
</tr>
<tr>
<td><strong>索引维护成本</strong></td>
<td>1. <strong>空间开销</strong>：索引会占用额外的磁盘空间。2. <strong>更新开销</strong>：插入、更新或删除数据时需要同步更新索引，增加性能开销。3. <strong>维护复杂性</strong>：随着索引数量增多，维护复杂度上升，需要定期优化。</td>
</tr>
<tr>
<td><strong>优化索引设计</strong></td>
<td>1. <strong>选择高选择性的列</strong>：索引选择性高（重复值少）时能更有效提高查询性能。2. <strong>避免过多索引</strong>：过多的索引会增加更新操作的开销。3. <strong>使用联合索引</strong>：适合多列查询的情况下，联合索引比单列索引效率更高。4. <strong>覆盖索引</strong>：尽量使用覆盖索引，避免访问数据表。</td>
</tr>
<tr>
<td><strong>索引的类型</strong></td>
<td>1. <strong>PRIMARY KEY</strong>：唯一标识每行，自动创建索引。2. <strong>UNIQUE KEY</strong>：确保列值唯一，创建唯一索引。3. <strong>INDEX</strong>：普通索引，提升查询性能。4. <strong>FULLTEXT</strong>：全文索引，支持文本检索。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>索引使用场景</strong></td>
<td>1. <strong>单列查询</strong>：适用于单列查询条件，尤其是大表。2. <strong>范围查询</strong>：适用于<code>BETWEEN</code>、<code>&lt;</code>、<code>&gt;</code>等条件。3. <strong>JOIN操作</strong>：在多表连接时，使用索引提高连接效率。4. <strong>排序和分组</strong>：使用索引优化<code>ORDER BY</code>和<code>GROUP BY</code>操作。</td>
</tr>
</tbody></table>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="category-chain-item">基础知识</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" class="category-chain-item">Mysql</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="print-no-link">#数据库</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>查询优化(索引角度)</div>
      <div>http://example.com/2023/05/16/索引与算法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" title="Android类加载流程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android类加载流程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/15/Dex%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" title="Dex加载流程">
                        <span class="hidden-mobile">Dex加载流程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
