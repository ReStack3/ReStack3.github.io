

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个Golang语言使用的知识体系。  数据类型   数据类型 描述 示例代码 占用内存    布尔型 true 或 false var isActive bool &#x3D; true 1 字节   整数型 有符号整数类型 var x int &#x3D; 42     int（平台相关） var y">
<meta property="og:type" content="article">
<meta property="og:title" content="Goalng语法概览">
<meta property="og:url" content="http://example.com/2023/08/10/Golang%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个Golang语言使用的知识体系。  数据类型   数据类型 描述 示例代码 占用内存    布尔型 true 或 false var isActive bool &#x3D; true 1 字节   整数型 有符号整数类型 var x int &#x3D; 42     int（平台相关） var y">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/12/27/rvOaeF317VlDwTL.png">
<meta property="article:published_time" content="2023-08-10T01:12:18.000Z">
<meta property="article:modified_time" content="2025-03-09T09:14:50.679Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/12/27/rvOaeF317VlDwTL.png">
  
  
  
  <title>Goalng语法概览 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Goalng语法概览"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-10 09:12" pubdate>
          2023年8月10日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          94 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Goalng语法概览</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本文仅是由于自己经常多语言开发，对于一些语言时常不用感到陌生或者使用中同其他语言用法混淆，故作此文，仅为自己提供一个Golang语言使用的知识体系。</p>
</blockquote>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>示例代码</th>
<th>占用内存</th>
</tr>
</thead>
<tbody><tr>
<td><strong>布尔型</strong></td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>var isActive bool = true</code></td>
<td>1 字节</td>
</tr>
<tr>
<td><strong>整数型</strong></td>
<td>有符号整数类型</td>
<td><code>var x int = 42</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>int</code>（平台相关）</td>
<td><code>var y int32 = 100</code></td>
<td>32 位或 64 位</td>
</tr>
<tr>
<td></td>
<td><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></td>
<td><code>var z int64 = -123456</code></td>
<td>8, 16, 32, 64 位</td>
</tr>
<tr>
<td></td>
<td>无符号整数类型</td>
<td><code>var u uint = 50</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></td>
<td><code>var u2 uint64 = 9876</code></td>
<td>8, 16, 32, 64 位</td>
</tr>
<tr>
<td><strong>浮点型</strong></td>
<td>单精度和双精度浮点数</td>
<td><code>var pi float64 = 3.14159</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>float32</code>, <code>float64</code></td>
<td></td>
<td>32 位，64 位</td>
</tr>
<tr>
<td><strong>复数型</strong></td>
<td>实部和虚部的组合（浮点数）</td>
<td><code>var c complex128 = complex(1.2, 3.4)</code></td>
<td>64 位（每部分）</td>
</tr>
<tr>
<td></td>
<td><code>complex64</code>, <code>complex128</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>字符型</strong></td>
<td>单个字符（Unicode）</td>
<td><code>var char rune = &#39;A&#39;</code></td>
<td>4 字节（<code>rune</code>）</td>
</tr>
<tr>
<td></td>
<td><code>rune</code>（等同于 <code>int32</code>）</td>
<td><code>var b byte = 65</code></td>
<td>1 字节（<code>byte</code>）</td>
</tr>
<tr>
<td><strong>字符串型</strong></td>
<td>不可变字符序列</td>
<td><code>var name string = &quot;Hello&quot;</code></td>
<td>每个字符占 1 字节（UTF-8 编码）</td>
</tr>
<tr>
<td><strong>派生类型</strong></td>
<td>复合数据类型（如数组、切片、结构体等）</td>
<td><code>var arr [3]int</code></td>
<td>根据类型不同</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2024/12/27/rvOaeF317VlDwTL.png" srcset="/img/loading.gif" lazyload alt="数据类型"></p>
<h1 id="数据结构封装"><a href="#数据结构封装" class="headerlink" title="数据结构封装"></a>数据结构封装</h1><p>Go 语言不像 C++ 那样有类似 <strong>STL</strong> 的内建模板库，提供了一套丰富的泛型容器和算法封装。不过，Go 提供了一些内建的数据类型和库，使得开发者能够有效地处理常见的数据结构和操作。为了实现类似于 STL 的功能，Go 通过以下几种方式来弥补：</p>
<h2 id="1-Go-内建数据类型"><a href="#1-Go-内建数据类型" class="headerlink" title="1. Go 内建数据类型"></a>1. <strong>Go 内建数据类型</strong></h2><p>Go 语言提供了一些常用的数据结构和类型，能够完成基本的容器操作。常见的有：</p>
<ul>
<li><strong>数组（Array）</strong> 和 <strong>切片（Slice）</strong>：Go 的切片类似于 C++ 中的 <code>vector</code>，支持动态扩展，且非常灵活。</li>
<li><strong>映射（Map）</strong>：Go 提供了原生的哈希表（类似 C++ 的 <code>unordered_map</code> 或 <code>map</code>）。</li>
<li><strong>通道（Channel）</strong>：Go 内建的并发数据结构，用于在 goroutine 之间传递数据。</li>
</ul>
<h2 id="2-标准库"><a href="#2-标准库" class="headerlink" title="2. 标准库"></a>2. <strong>标准库</strong></h2><p>Go 提供了一些标准库来处理常见的算法和数据结构操作。虽然它不如 C++ STL 那样提供完备的模板库，但提供了一些非常实用的工具：</p>
<ul>
<li>**<code>container/list</code>**：提供双向链表。</li>
<li>**<code>container/heap</code>**：提供堆（优先队列）实现。</li>
<li>**<code>sort</code>**：对切片进行排序。</li>
<li>**<code>sync</code>**：提供并发控制结构，例如 <code>Mutex</code>、<code>RWMutex</code> 等。</li>
<li>**<code>math</code> 和 <code>math/rand</code>**：数学和随机数生成库。</li>
</ul>
<p>还有一些常见的第三方 Go 库，可以用来实现类似 STL 的功能：</p>
<ul>
<li>**<code>golang-collections/collections</code>**：提供一些额外的集合数据结构，例如队列、栈等。</li>
<li>**<code>gods</code>**（GoDS）：一个包含常见数据结构的包，如链表、堆、树、图、集合等。</li>
<li>**<code>go-datastructures</code>**：提供高级数据结构，如红黑树、跳表、堆等。</li>
</ul>
<h1 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h1><table>
<thead>
<tr>
<th>操作&#x2F;函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>make([]T, len, cap)</code></strong></td>
<td>创建一个切片并初始化，<code>len</code> 是切片的长度，<code>cap</code> 是容量。</td>
<td><code>s := make([]int, 5)</code> 创建长度为 5 的切片，容量为 5。 <code>s := make([]int, 5, 10)</code> 创建长度为 5，容量为 10 的切片。</td>
</tr>
<tr>
<td><strong><code>len(s)</code></strong></td>
<td>获取切片的长度，即切片中元素的个数。</td>
<td><code>s := []int&#123;1, 2, 3&#125;</code> <code>fmt.Println(len(s))</code> 输出 <code>3</code>。</td>
</tr>
<tr>
<td><strong><code>cap(s)</code></strong></td>
<td>获取切片的容量，即切片底层数组的长度。</td>
<td><code>s := make([]int, 5, 10)</code> <code>fmt.Println(cap(s))</code> 输出 <code>10</code>。</td>
</tr>
<tr>
<td><strong><code>append(s, elems...)</code></strong></td>
<td>向切片添加元素，如果容量不足则会自动扩展切片的容量。</td>
<td><code>s := []int&#123;1, 2&#125;</code> <code>s = append(s, 3, 4)</code> 输出 <code>s = [1, 2, 3, 4]</code>。</td>
</tr>
<tr>
<td><strong><code>copy(dest, src)</code></strong></td>
<td>将 <code>src</code> 切片的内容复制到 <code>dest</code> 切片，返回实际复制的元素个数。</td>
<td><code>s1 := []int&#123;1, 2, 3&#125;</code> <code>s2 := make([]int, 3)</code> <code>n := copy(s2, s1)</code> 输出 <code>n = 3</code>，<code>s2 = [1, 2, 3]</code>。</td>
</tr>
<tr>
<td><strong><code>s[start:end]</code></strong></td>
<td>切片操作，返回一个从索引 <code>start</code> 到 <code>end-1</code> 的切片。</td>
<td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[1:4])</code> 输出 <code>[2, 3, 4]</code>。</td>
</tr>
<tr>
<td><strong><code>s[:end]</code></strong></td>
<td>切片操作，返回一个从索引 <code>0</code> 到 <code>end-1</code> 的切片。</td>
<td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[:3])</code> 输出 <code>[1, 2, 3]</code>。</td>
</tr>
<tr>
<td><strong><code>s[start:]</code></strong></td>
<td>切片操作，返回一个从 <code>start</code> 到切片末尾的切片。</td>
<td><code>s := []int&#123;1, 2, 3, 4, 5&#125;</code> <code>fmt.Println(s[2:])</code> 输出 <code>[3, 4, 5]</code>。</td>
</tr>
<tr>
<td><strong><code>var s []T</code></strong></td>
<td>声明一个空切片，未指定长度和容量。</td>
<td><code>var s []int</code> 声明一个空的整数切片。</td>
</tr>
<tr>
<td><strong><code>s = make([]int, 0)</code></strong></td>
<td>创建一个长度为 0 的切片。</td>
<td><code>s := make([]int, 0)</code> 创建一个空的整数切片。</td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td>使用 <code>append</code> 删除切片中的元素。</td>
<td><code>s := []int&#123;1, 2, 3, 4&#125;</code> <code>s = append(s[:i], s[i+1:]...)</code> 删除索引 <code>i</code> 的元素。</td>
</tr>
</tbody></table>
<p><code>[][]int</code> 是一个二维切片的类型声明，没有实际分配内存。</p>
<p><code>make([][]int)</code> 创建了一个切片类型，并为外层切片分配了内存，但每一行（子切片）默认是 <code>nil</code>，需要进一步初始化。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>Go 语言在 <strong>1.18</strong> 版本中引入了 <strong>泛型（Generics）</strong>，这使得开发者能够编写类型安全的代码，同时避免了重复的类型声明。泛型允许函数、方法、类型和数据结构在不同类型之间进行抽象，提升代码的复用性和灵活性。与 C++ 或 Java 的泛型相比，Go 的泛型相对简单，并通过类型参数实现。</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. <strong>基本语法</strong></h3><p>泛型的核心在于 **类型参数。通过类型参数，可以定义支持不同类型的函数、结构体、接口等。</p>
<h4 id="1-1-函数泛型"><a href="#1-1-函数泛型" class="headerlink" title="1.1 函数泛型"></a>1.1 函数泛型</h4><p>Go 中可以通过 <code>type</code> 参数来创建一个可以接受任意类型的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 泛型函数，T 表示类型参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>    fmt.Println(value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Print(<span class="hljs-number">42</span>)       <span class="hljs-comment">// 输出: 42</span><br>    Print(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">// 输出: Hello</span><br>    Print(<span class="hljs-number">3.14</span>)     <span class="hljs-comment">// 输出: 3.14</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Print</code> 函数接受一个类型为 <code>T</code> 的参数，<code>T</code> 是一个类型参数，表示可以是任何类型。<code>any</code> 是 Go 1.18 引入的类型别名，等同于 <code>interface&#123;&#125;</code>，表示可以接受任意类型。</p>
<h4 id="1-2-类型约束"><a href="#1-2-类型约束" class="headerlink" title="1.2 类型约束"></a>1.2 <strong>类型约束</strong></h4><p>Go 允许为类型参数设置约束，限制类型参数的范围。通过接口约束，可以指定类型参数必须满足某些条件。</p>
<p>例如，我们可以定义一个泛型函数，它只接受实现了 <code>Stringer</code> 接口的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义约束：只允许实现了 String 方法的类型</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 泛型函数，要求类型参数实现 Stringer 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintString</span>[<span class="hljs-title">T</span> <span class="hljs-title">Stringer</span>]<span class="hljs-params">(value T)</span></span> &#123;<br>    fmt.Println(value.String())<br>&#125;<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Person 实现了 Stringer 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> p.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    PrintString(p)  <span class="hljs-comment">// 输出: Alice</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>PrintString</code> 函数要求传入的类型 <code>T</code> 必须实现 <code>Stringer</code> 接口，只有实现了 <code>String()</code> 方法的类型才能作为参数传递。</p>
<h3 id="2-结构体泛型"><a href="#2-结构体泛型" class="headerlink" title="2. 结构体泛型"></a>2. <strong>结构体泛型</strong></h3><p>Go 语言也支持为结构体定义泛型，使得结构体能够接受不同类型的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个泛型结构体，T 为类型参数</span><br><span class="hljs-keyword">type</span> Box[T any] <span class="hljs-keyword">struct</span> &#123;<br>    Value T<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    intBox := Box[<span class="hljs-type">int</span>]&#123;Value: <span class="hljs-number">42</span>&#125;     <span class="hljs-comment">// 泛型结构体，类型为 int</span><br>    stringBox := Box[<span class="hljs-type">string</span>]&#123;Value: <span class="hljs-string">&quot;Hello&quot;</span>&#125; <span class="hljs-comment">// 泛型结构体，类型为 string</span><br><br>    fmt.Println(intBox.Value)    <span class="hljs-comment">// 输出: 42</span><br>    fmt.Println(stringBox.Value) <span class="hljs-comment">// 输出: Hello</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>Box</code> 结构体接受一个类型参数 <code>T</code>，并且 <code>T</code> 可以是任意类型（<code>any</code>）。在 <code>main</code> 函数中，<code>intBox</code> 和 <code>stringBox</code> 是不同类型的泛型实例。</p>
<h3 id="3-接口泛型"><a href="#3-接口泛型" class="headerlink" title="3. 接口泛型"></a>3. <strong>接口泛型</strong></h3><p>接口也可以使用泛型。通过泛型接口，可以定义可以接受不同类型的接口，进一步提升代码的灵活性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个泛型接口</span><br><span class="hljs-keyword">type</span> Comparator[T any] <span class="hljs-keyword">interface</span> &#123;<br>    Compare(a, b T) <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IntComparator <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(IntComparator)</span></span> Compare(a, b <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    comparator := IntComparator&#123;&#125;<br>    fmt.Println(comparator.Compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出: -1</span><br>    fmt.Println(comparator.Compare(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出: 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Comparator</code> 接口定义了一个泛型方法 <code>Compare</code>，它接受两个参数并返回一个整数。<code>IntComparator</code> 实现了 <code>Comparator</code> 接口，可以比较 <code>int</code> 类型的数据。</p>
<h3 id="4-类型约束"><a href="#4-类型约束" class="headerlink" title="4. 类型约束"></a>4. <strong>类型约束</strong></h3><p>Go 泛型支持对类型参数设置约束，限制它们只能是某些类型或满足某些条件。这些约束可以是：</p>
<ul>
<li><strong>内建约束类型</strong>（如 <code>any</code>，表示没有约束）</li>
<li><strong>接口约束</strong>：要求类型实现某些方法</li>
<li><strong>组合约束</strong>：可以通过组合多个接口约束来实现更复杂的约束</li>
</ul>
<h4 id="4-1-内建类型约束：any-和-comparable"><a href="#4-1-内建类型约束：any-和-comparable" class="headerlink" title="4.1 内建类型约束：any 和 comparable"></a>4.1 <strong>内建类型约束：<code>any</code> 和 <code>comparable</code></strong></h4><ul>
<li><code>any</code>：表示没有约束，可以是任何类型。</li>
<li><code>comparable</code>：表示类型支持比较操作（例如，<code>==</code> 和 <code>!=</code>）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 泛型函数，约束参数必须是可比较类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(a, b T)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a == b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(Compare(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment">// 输出: true</span><br>    fmt.Println(Compare(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>)) <span class="hljs-comment">// 输出: false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-多个类型参数"><a href="#5-多个类型参数" class="headerlink" title="5. 多个类型参数"></a>5. <strong>多个类型参数</strong></h3><p>Go 允许为函数或结构体定义多个类型参数，这使得泛型能够处理更加复杂的类型组合。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个接受两个类型参数的泛型函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Swap</span>[<span class="hljs-title">T</span>, <span class="hljs-title">U</span> <span class="hljs-title">any</span>]<span class="hljs-params">(a T, b U)</span></span> (U, T) &#123;<br>    <span class="hljs-keyword">return</span> b, a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a, b := Swap(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br>    fmt.Println(a, b) <span class="hljs-comment">// 输出: hello 1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-泛型与性能"><a href="#6-泛型与性能" class="headerlink" title="6. 泛型与性能"></a>6. <strong>泛型与性能</strong></h3><p>Go 的泛型实现使用了 **类型擦除的技术【可参考对比Java】。在编译时，Go 会将泛型函数或类型的类型参数“擦除”，并生成特定类型的代码。与 C++ 或 Java 的泛型实现不同，Go 不会生成每个类型的特定代码，而是使用通用的类型实现，保持较好的性能。</p>
<p>具体可参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041634906">后端 - Go 1.18 泛型全面讲解：一篇讲清泛型的全部 - 个人文章 - SegmentFault 思否</a></p>
<h1 id="面向接口组合"><a href="#面向接口组合" class="headerlink" title="面向接口组合"></a>面向接口组合</h1><p>Go 语言不像传统的面向对象编程（OOP）语言（如 Java 或 C++）那样具有类（<code>class</code>）和继承的概念。Go 语言的面向对象编程模型更加简洁，提供了通过 <strong>结构体（<code>struct</code>）</strong> 和 <strong>方法（<code>method</code>）</strong> 实现类似面向对象的设计思路。虽然没有类和继承，但 Go 通过组合（composition）和接口（interface）来实现面向对象的思想。</p>
<h3 id="Go-面向对象编程的基本概念"><a href="#Go-面向对象编程的基本概念" class="headerlink" title="Go 面向对象编程的基本概念"></a>Go 面向对象编程的基本概念</h3><ol>
<li><strong>结构体（Struct）</strong></li>
<li><strong>方法（Method）</strong></li>
<li><strong>接口（Interface）</strong></li>
<li><strong>组合（Composition）</strong></li>
<li><strong>多态（Polymorphism）</strong></li>
</ol>
<p>下面详细介绍这些概念：</p>
<hr>
<h3 id="1-结构体（Struct）"><a href="#1-结构体（Struct）" class="headerlink" title="1. 结构体（Struct）"></a>1. <strong>结构体（Struct）</strong></h3><p>在 Go 中，<code>struct</code> 是一种自定义的数据类型，用于将多个不同类型的数据组合成一个单一的数据结构。虽然结构体不是类，但它可以用来表示对象。</p>
<h4 id="示例：定义和使用结构体"><a href="#示例：定义和使用结构体" class="headerlink" title="示例：定义和使用结构体"></a>示例：定义和使用结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个结构体（类似于类）</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个结构体实例</span><br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    <br>    <span class="hljs-comment">// 访问结构体的字段</span><br>    fmt.Println(p.Name)  <span class="hljs-comment">// 输出: Alice</span><br>    fmt.Println(p.Age)   <span class="hljs-comment">// 输出: 30</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-方法（Method）"><a href="#2-方法（Method）" class="headerlink" title="2. 方法（Method）"></a>2. <strong>方法（Method）</strong></h3><p>方法是与类型（如结构体）绑定的函数。与面向对象语言中的类方法类似，Go 中的 <strong>方法</strong> 是通过指定一个 <strong>接收者（receiver）</strong> 来将方法与结构体（或其他类型）关联。</p>
<h4 id="示例：结构体方法"><a href="#示例：结构体方法" class="headerlink" title="示例：结构体方法"></a>示例：结构体方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个方法（与结构体 Person 绑定）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Greet() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, p.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个结构体实例</span><br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    <br>    <span class="hljs-comment">// 调用结构体的方法</span><br>    p.Greet()  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，<code>Greet</code> 是一个 <strong>方法</strong>，它绑定到 <code>Person</code> 结构体上。方法的接收者 <code>p</code> 是 <code>Person</code> 类型的一个实例。</p>
<ul>
<li>方法接收者可以是值接收者（<code>p Person</code>）或者指针接收者（<code>p *Person</code>）。</li>
<li>如果使用指针接收者，方法会改变接收者的值；如果使用值接收者，则方法操作的是接收者的副本。</li>
</ul>
<h4 id="示例：指针接收者和值接收者"><a href="#示例：指针接收者和值接收者" class="headerlink" title="示例：指针接收者和值接收者"></a>示例：指针接收者和值接收者</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 使用值接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> CelebrateBirthday() &#123;<br>    p.Age++<br>    fmt.Println(<span class="hljs-string">&quot;Happy Birthday! Now I am&quot;</span>, p.Age, <span class="hljs-string">&quot;years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> HaveBirthday() &#123;<br>    p.Age++<br>    fmt.Println(<span class="hljs-string">&quot;Happy Birthday! Now I am&quot;</span>, p.Age, <span class="hljs-string">&quot;years old.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用值接收者</span><br>    p1 := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br>    p1.CelebrateBirthday()  <span class="hljs-comment">// 输出: Happy Birthday! Now I am 31 years old.</span><br>    fmt.Println(p1.Age)      <span class="hljs-comment">// 输出: 30 (没有改变)</span><br><br>    <span class="hljs-comment">// 使用指针接收者</span><br>    p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;Bob&quot;</span>, Age: <span class="hljs-number">25</span>&#125;<br>    p2.HaveBirthday()        <span class="hljs-comment">// 输出: Happy Birthday! Now I am 26 years old.</span><br>    fmt.Println(p2.Age)      <span class="hljs-comment">// 输出: 26 (值已经改变)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-接口（Interface）"><a href="#3-接口（Interface）" class="headerlink" title="3. 接口（Interface）"></a>3. <strong>接口（Interface）</strong></h3><p>Go 中的接口是面向对象编程的关键部分，它是 <strong>动态类型</strong>，并且没有显式的继承关系。Go 中的接口不需要显式声明实现，任何类型只要实现了接口中的方法，就可以认为该类型实现了该接口。</p>
<h4 id="示例：定义和使用接口"><a href="#示例：定义和使用接口" class="headerlink" title="示例：定义和使用接口"></a>示例：定义和使用接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个接口</span><br><span class="hljs-keyword">type</span> Greeter <span class="hljs-keyword">interface</span> &#123;<br>    Greet()<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Greet() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, my name is&quot;</span>, p.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    <br>    <span class="hljs-comment">// 使用接口</span><br>    <span class="hljs-keyword">var</span> g Greeter = p<br>    g.Greet()  <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Go 的接口是 <strong>隐式实现</strong> 的，即如果一个类型实现了接口所定义的所有方法，就认为该类型实现了接口。</p>
<h3 id="4-组合（Composition）"><a href="#4-组合（Composition）" class="headerlink" title="4. 组合（Composition）"></a>4. <strong>组合（Composition）</strong></h3><p>Go 语言通过组合（而非继承）来实现代码复用。你可以将一个结构体嵌入到另一个结构体中，从而获得它的方法和字段。</p>
<h4 id="示例：结构体组合"><a href="#示例：结构体组合" class="headerlink" title="示例：结构体组合"></a>示例：结构体组合</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个基础结构体</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Animal)</span></span> Speak() &#123;<br>    fmt.Println(a.Name, <span class="hljs-string">&quot;says hello!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体，组合了 Animal</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    Animal<br>    Breed <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    d := Dog&#123;Animal: Animal&#123;Name: <span class="hljs-string">&quot;Rex&quot;</span>&#125;, Breed: <span class="hljs-string">&quot;Golden Retriever&quot;</span>&#125;<br>    d.Speak()  <span class="hljs-comment">// 输出: Rex says hello!</span><br>    fmt.Println(d.Breed)  <span class="hljs-comment">// 输出: Golden Retriever</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Dog</code> 结构体通过 <strong>组合</strong> 包含了 <code>Animal</code> 结构体。<code>Dog</code> 可以直接调用 <code>Animal</code> 的方法 <code>Speak()</code>。</p>
<h3 id="5-多态（Polymorphism）"><a href="#5-多态（Polymorphism）" class="headerlink" title="5. 多态（Polymorphism）"></a>5. <strong>多态（Polymorphism）</strong></h3><p>Go 的多态通过接口实现。不同的类型可以实现相同的接口，因此通过接口可以让不同的类型表现出相同的行为。</p>
<h4 id="示例：多态实现"><a href="#示例：多态实现" class="headerlink" title="示例：多态实现"></a>示例：多态实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">type</span> Speaker <span class="hljs-keyword">interface</span> &#123;<br>    Speak()<br>&#125;<br><br><span class="hljs-comment">// 定义结构体 1</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Speak() &#123;<br>    fmt.Println(p.Name, <span class="hljs-string">&quot;says hello!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义结构体 2</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Speak() &#123;<br>    fmt.Println(d.Name, <span class="hljs-string">&quot;barks!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 多态</span><br>    <span class="hljs-keyword">var</span> speaker Speaker<br><br>    speaker = Person&#123;Name: <span class="hljs-string">&quot;Alice&quot;</span>&#125;<br>    speaker.Speak()  <span class="hljs-comment">// 输出: Alice says hello!</span><br><br>    speaker = Dog&#123;Name: <span class="hljs-string">&quot;Rex&quot;</span>&#125;<br>    speaker.Speak()  <span class="hljs-comment">// 输出: Rex barks!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person</code> 和 <code>Dog</code> 类型都实现了 <code>Speak()</code> 方法，因此它们都实现了 <code>Speaker</code> 接口。通过接口 <code>Speaker</code>，我们可以在运行时动态地决定调用哪个类型的方法，从而实现多态。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Go 语言虽然没有传统面向对象语言中的类和继承概念，但它通过结构体（<code>struct</code>）、方法（<code>method</code>）、接口（<code>interface</code>）和组合（<code>composition</code>）等机制实现了类似面向对象编程的功能。通过这些特性，Go 可以进行封装、抽象、接口设计以及代码复用。</p>
<ul>
<li><strong>结构体</strong>：用于定义数据类型。</li>
<li><strong>方法</strong>：与结构体关联的函数。</li>
<li><strong>接口</strong>：通过方法签名定义的行为契约，支持隐式实现。</li>
<li><strong>组合</strong>：通过组合结构体实现代码复用，而不是继承。</li>
<li><strong>多态</strong>：通过接口支持不同类型的行为一致性。</li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>Go 语言的并发编程是其最强大的特性之一。与许多语言相比，Go 提供了非常简洁和高效的并发模型。Go 的并发通过 <strong>goroutines</strong> 和 <strong>channels</strong> 来实现，具有以下特点：</p>
<ul>
<li><strong>goroutines</strong>：轻量级的线程，是 Go 实现并发的核心。</li>
<li><strong>channels</strong>：用于 goroutines 之间通信的管道，帮助协调不同的并发任务。</li>
</ul>
<p>在 Go 中，所有并发操作都围绕 <strong>goroutines</strong> 和 <strong>channels</strong> 进行。</p>
<h3 id="1-goroutines"><a href="#1-goroutines" class="headerlink" title="1. goroutines"></a>1. <strong>goroutines</strong></h3><p>goroutine 是 Go 中的一个轻量级线程，可以执行并发任务。启动一个 goroutine 非常简单，只需要在函数调用前加上 <code>go</code> 关键字即可。每个 goroutine 都有独立的栈，Go 会为每个 goroutine 分配一个小的栈空间，通常是几 KB，随着需要可以动态增长。</p>
<h4 id="示例：创建-goroutine"><a href="#示例：创建-goroutine" class="headerlink" title="示例：创建 goroutine"></a>示例：创建 goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-comment">// 定义一个函数，在 goroutine 中执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello from goroutine!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 启动一个 goroutine</span><br>    <span class="hljs-keyword">go</span> sayHello()<br>    <br>    <span class="hljs-comment">// 主线程休眠，以便 goroutine 执行</span><br>    time.Sleep(time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;Hello from main!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们通过 <code>go sayHello()</code> 启动了一个新的 goroutine，它与主线程并发执行。由于主线程在结束前需要等待，使用 <code>time.Sleep</code> 来确保 goroutine 有足够的时间执行。</p>
<h3 id="2-channels"><a href="#2-channels" class="headerlink" title="2. channels"></a>2. <strong>channels</strong></h3><p>Go 使用 <strong>channels</strong> 来进行 goroutines 之间的通信。channel 就是一个管道，它可以传递数据。通过 channels，goroutines 可以安全地传递数据，而不需要显式的锁机制。</p>
<h4 id="示例：使用-channels-进行通信"><a href="#示例：使用-channels-进行通信" class="headerlink" title="示例：使用 channels 进行通信"></a>示例：使用 channels 进行通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义一个函数，接收一个 channel 作为参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br>    ch &lt;- <span class="hljs-string">&quot;Hello from goroutine!&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 channel</span><br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <br>    <span class="hljs-comment">// 启动一个 goroutine</span><br>    <span class="hljs-keyword">go</span> greet(ch)<br>    <br>    <span class="hljs-comment">// 从 channel 中接收数据</span><br>    msg := &lt;-ch<br>    fmt.Println(msg)  <span class="hljs-comment">// 输出: Hello from goroutine!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>greet</code> 函数将一条消息通过 channel 传回主线程，主线程通过 <code>&lt;-ch</code> 接收消息并打印。</p>
<h3 id="3-channel-的类型"><a href="#3-channel-的类型" class="headerlink" title="3. channel 的类型"></a>3. <strong>channel 的类型</strong></h3><p>Go 中的 channels 可以有不同的类型和方向：</p>
<ul>
<li><strong>无缓冲 channel</strong>：接收和发送操作是同步的，即只有一个 goroutine 完成发送，另一个 goroutine 才能接收到数据。</li>
<li><strong>有缓冲 channel</strong>：允许在接收方还未准备好接收数据时，发送方可以继续发送数据。</li>
</ul>
<h4 id="示例：无缓冲-channel"><a href="#示例：无缓冲-channel" class="headerlink" title="示例：无缓冲 channel"></a>示例：无缓冲 channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)  <span class="hljs-comment">// 无缓冲 channel</span><br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Hello from goroutine!&quot;</span><br>    &#125;()<br>    <br>    msg := &lt;-ch<br>    fmt.Println(msg)  <span class="hljs-comment">// 输出: Hello from goroutine!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="示例：有缓冲-channel"><a href="#示例：有缓冲-channel" class="headerlink" title="示例：有缓冲 channel"></a>示例：有缓冲 channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 创建一个有缓冲区的 channel</span><br>    <br>    <span class="hljs-comment">// 启动两个 goroutine</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Message 1&quot;</span><br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        ch &lt;- <span class="hljs-string">&quot;Message 2&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-comment">// 接收数据</span><br>    fmt.Println(&lt;-ch)  <span class="hljs-comment">// 输出: Message 1</span><br>    fmt.Println(&lt;-ch)  <span class="hljs-comment">// 输出: Message 2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>ch</code> 是一个有缓冲区的 channel，可以存储最多 2 个消息。如果缓冲区未满，发送方不会被阻塞；只有当缓冲区满时，发送操作才会被阻塞。</p>
<h3 id="4-select-语句"><a href="#4-select-语句" class="headerlink" title="4. select 语句"></a>4. <strong>select 语句</strong></h3><p><code>select</code> 是 Go 提供的多路复用机制，允许 goroutine 同时等待多个 channel 操作。<code>select</code> 会阻塞，直到有一个 case 能够执行。</p>
<h4 id="示例：使用-select-实现多个-channel-的监听"><a href="#示例：使用-select-实现多个-channel-的监听" class="headerlink" title="示例：使用 select 实现多个 channel 的监听"></a>示例：使用 select 实现多个 channel 的监听</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>        ch1 &lt;- <span class="hljs-string">&quot;Message from ch1&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>        ch2 &lt;- <span class="hljs-string">&quot;Message from ch2&quot;</span><br>    &#125;()<br>    <br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg1 := &lt;-ch1:<br>        fmt.Println(msg1)  <span class="hljs-comment">// 输出: Message from ch1</span><br>    <span class="hljs-keyword">case</span> msg2 := &lt;-ch2:<br>        fmt.Println(msg2)  <span class="hljs-comment">// 不会执行，除非 ch2 先发送数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>select</code> 会等待并接收第一个准备好的 channel 中的数据。如果多个 channel 都准备好了，它会随机选择一个执行。</p>
<h3 id="5-goroutine-的生命周期和同步"><a href="#5-goroutine-的生命周期和同步" class="headerlink" title="5. goroutine 的生命周期和同步"></a>5. <strong>goroutine 的生命周期和同步</strong></h3><h4 id="使用-sync-WaitGroup-等待多个-goroutine-完成"><a href="#使用-sync-WaitGroup-等待多个-goroutine-完成" class="headerlink" title="使用 sync.WaitGroup 等待多个 goroutine 完成"></a>使用 <code>sync.WaitGroup</code> 等待多个 goroutine 完成</h4><p><code>sync.WaitGroup</code> 是 Go 提供的一个同步工具，用于等待一组 goroutine 执行完成。它允许你在多个 goroutines 执行完之前阻塞主线程。</p>
<h4 id="示例：sync-WaitGroup-等待多个-goroutine-完成"><a href="#示例：sync-WaitGroup-等待多个-goroutine-完成" class="headerlink" title="示例：sync.WaitGroup 等待多个 goroutine 完成"></a>示例：<code>sync.WaitGroup</code> 等待多个 goroutine 完成</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(wg *sync.WaitGroup, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()  <span class="hljs-comment">// 完成时通知 WaitGroup</span><br>    fmt.Println(n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <br>    <span class="hljs-comment">// 启动多个 goroutine</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 向 WaitGroup 中添加计数</span><br>        <span class="hljs-keyword">go</span> printNumber(&amp;wg, i)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等待所有 goroutine 完成</span><br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;All goroutines finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，主线程通过 <code>wg.Wait()</code> 阻塞，直到所有的 goroutines 完成它们的任务。<code>wg.Done()</code> 用于通知 <code>WaitGroup</code> 当前 goroutine 完成。</p>
<h3 id="6-Go-的并发优势"><a href="#6-Go-的并发优势" class="headerlink" title="6. Go 的并发优势"></a>6. <strong>Go 的并发优势</strong></h3><ul>
<li><strong>轻量级</strong>：goroutines 仅占用很小的内存（通常为 2KB），可以创建成千上万个 goroutine。</li>
<li><strong>简洁易用</strong>：Go 的并发模型通过 <code>go</code> 关键字和 <code>channel</code> 提供了简洁的编程模型，极大地减少了传统线程和锁的复杂性。</li>
<li><strong>高效</strong>：Go 的调度器能够高效地管理 goroutines 的调度，允许高并发的应用程序在多核处理器上良好运行。</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Go 语言的异常处理机制与传统的面向对象语言（如 Java、Python）不同。Go 语言没有像 <code>try-catch</code> 的传统异常处理机制，而是采用了一种基于 <strong>错误值（error）</strong> 的显式错误处理方式。这种方法使得错误处理更加清晰，开发者可以明确知道每个函数的返回值是否表示一个错误。</p>
<h3 id="1-Go-中的错误处理"><a href="#1-Go-中的错误处理" class="headerlink" title="1. Go 中的错误处理"></a>1. <strong>Go 中的错误处理</strong></h3><p>Go 使用 <code>error</code> 类型来表示错误。<code>error</code> 是一个内建的接口类型，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span>  <span class="hljs-comment">// 定义 Error() 方法，返回错误信息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>error</code> 接口只有一个方法 <code>Error()</code>，它返回一个字符串，用于描述错误的详细信息。大多数 Go 函数会返回一个 <code>error</code> 类型的值，表示是否发生了错误。</p>
<h4 id="示例：基本的错误处理"><a href="#示例：基本的错误处理" class="headerlink" title="示例：基本的错误处理"></a>示例：基本的错误处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个返回错误的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;division by zero&quot;</span>)  <span class="hljs-comment">// 返回错误</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 没有错误，返回结果和 nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    result, err := divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// 检查错误</span><br>        fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>    &#125;<br><br>    result, err = divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)  <span class="hljs-comment">// 输出: Error: division by zero</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>divide</code> 函数会返回一个 <code>int</code> 结果和一个 <code>error</code>。如果分母为 0，则返回一个错误对象，<code>error</code> 的值为 <code>&quot;division by zero&quot;</code>。</p>
<h3 id="2-panic-和-recover"><a href="#2-panic-和-recover" class="headerlink" title="2. panic 和 recover"></a>2. <strong><code>panic</code> 和 <code>recover</code></strong></h3><p>Go 提供了 <code>panic</code> 和 <code>recover</code> 两个机制，用于在程序中处理严重错误或不可恢复的错误。</p>
<ul>
<li>**<code>panic</code>**：<code>panic</code> 用于触发一个运行时错误，类似于其他语言中的抛出异常。当 <code>panic</code> 被调用时，程序会中止当前函数的执行，逐级向上传播，直到程序崩溃或被 <code>recover</code> 捕获。</li>
<li>**<code>recover</code>**：<code>recover</code> 用于从 <code>panic</code> 引发的错误中恢复，并防止程序崩溃。<code>recover</code> 只能在 <code>defer</code> 函数中使用。</li>
</ul>
<h4 id="示例：使用-panic-和-recover"><a href="#示例：使用-panic-和-recover" class="headerlink" title="示例：使用 panic 和 recover"></a>示例：使用 <code>panic</code> 和 <code>recover</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">causePanic</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>)  <span class="hljs-comment">// 触发 panic</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">safeFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Recovered from panic:&quot;</span>, r)  <span class="hljs-comment">// 恢复 panic</span><br>        &#125;<br>    &#125;()<br>    <br>    causePanic()  <span class="hljs-comment">// 调用会引发 panic 的函数</span><br>    fmt.Println(<span class="hljs-string">&quot;This will not be printed&quot;</span>)  <span class="hljs-comment">// 不会执行</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    safeFunction()<br>    fmt.Println(<span class="hljs-string">&quot;Program continues...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><code>causePanic</code> 函数触发了 <code>panic</code>，导致程序崩溃。</li>
<li><code>safeFunction</code> 使用 <code>defer</code> 和 <code>recover</code> 来捕获 <code>panic</code>，防止程序崩溃并恢复执行。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">Recovered from panic: something went wrong<br><span class="hljs-function"><span class="hljs-title">Program</span></span> continues...<br></code></pre></td></tr></table></figure>

<h3 id="3-defer-语句"><a href="#3-defer-语句" class="headerlink" title="3. defer 语句"></a>3. <strong><code>defer</code> 语句</strong></h3><p><code>defer</code> 语句用于延迟执行一个函数，直到包含它的函数返回时执行。这常用于资源的清理操作，如文件关闭、解锁、关闭数据库连接等。</p>
<h4 id="示例：使用-defer-进行资源清理"><a href="#示例：使用-defer-进行资源清理" class="headerlink" title="示例：使用 defer 进行资源清理"></a>示例：使用 <code>defer</code> 进行资源清理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Opening file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Closing file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> closeFile(filename)  <span class="hljs-comment">// 函数返回时执行，确保文件被关闭</span><br>    openFile(filename)<br>    fmt.Println(<span class="hljs-string">&quot;Processing file:&quot;</span>, filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    processFile(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Opening <span class="hljs-built_in">file</span>: example.txt<br>Processing <span class="hljs-built_in">file</span>: example.txt<br>Closing <span class="hljs-built_in">file</span>: example.txt<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>closeFile</code> 的调用被 <code>defer</code> 推迟到 <code>processFile</code> 函数执行完毕后进行。即使在 <code>processFile</code> 中发生了错误，<code>defer</code> 也会确保资源被正确释放。</p>
<h3 id="4-错误处理的最佳实践"><a href="#4-错误处理的最佳实践" class="headerlink" title="4. 错误处理的最佳实践"></a>4. <strong>错误处理的最佳实践</strong></h3><ul>
<li><p><strong>显式错误检查</strong>：Go 的错误处理要求开发者显式检查每个可能发生错误的函数的返回值。这种方式可以确保错误不会被忽略，也更容易理解代码的执行流。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">result, err := someFunction()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义错误类型</strong>：如果需要返回更详细的错误信息，可以定义自定义的错误类型。自定义错误类型通常实现 <code>error</code> 接口的 <code>Error()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    Code    <span class="hljs-type">int</span><br>    Message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Code: %d, Message: %s&quot;</span>, e.Code, e.Message)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorExample</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;MyError&#123;Code: <span class="hljs-number">404</span>, Message: <span class="hljs-string">&quot;Not Found&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    err := errorExample()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)  <span class="hljs-comment">// 输出: Code: 404, Message: Not Found</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个自定义的错误类型 <code>MyError</code>，它包含错误的 <code>Code</code> 和 <code>Message</code> 字段。</p>
</li>
<li><p><strong>不要使用 <code>panic</code> 来处理常规错误</strong>：Go 提倡通过返回错误值来处理错误，而不是使用 <code>panic</code>。<code>panic</code> 主要用于程序中的严重错误（例如，无法恢复的错误）。</p>
</li>
<li><p><strong>错误链</strong>：Go 1.13 引入了错误包装功能，允许我们在原有错误的基础上添加更多的上下文信息，这使得错误处理更加灵活。可以使用 <code>fmt.Errorf</code> 来包装错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;initial error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    err := someFunction()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 使用 fmt.Errorf 包装错误</span><br>        err = fmt.Errorf(<span class="hljs-string">&quot;additional context: %w&quot;</span>, err)<br>        fmt.Println(err)  <span class="hljs-comment">// 输出: additional context: initial error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，<code>%w</code> 用于将原始错误包装到新错误中，允许后续代码使用 <code>errors.Is()</code> 或 <code>errors.As()</code> 来检查原始错误。</p>
</li>
</ul>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. <strong>总结</strong>：</h3><p>Go 的错误处理方式与传统的异常机制不同，更加显式和简单。错误值 (<code>error</code>) 是 Go 的核心机制，开发者需要通过检查每个函数的返回值来处理错误。Go 还提供了 <code>panic</code> 和 <code>recover</code> 来处理不可恢复的错误，同时通过 <code>defer</code> 来处理资源清理工作。</p>
<ul>
<li><strong>错误处理</strong>：通过返回 <code>error</code> 类型来传递错误信息。</li>
<li>**<code>panic</code> 和 <code>recover</code>**：用于处理不可恢复的错误，<code>panic</code> 会导致程序崩溃，<code>recover</code> 可以捕获并恢复。</li>
<li>**<code>defer</code>**：用于推迟执行函数，确保资源的释放或清理。</li>
<li><strong>最佳实践</strong>：显式检查错误、自定义错误类型、错误链的使用等。</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Go 语言的内存管理采用了自动垃圾回收（<strong>GC，Garbage Collection</strong>）机制，并提供了类似于其他现代语言的 <strong>堆</strong>（Heap）和 <strong>栈</strong>（Stack）管理模型。Go 的内存管理机制设计旨在减少手动内存管理的复杂性，同时保持高效的性能。</p>
<p>Go 的内存管理包括以下几个关键概念：</p>
<ol>
<li><strong>堆和栈</strong></li>
<li><strong>垃圾回收（GC）</strong></li>
<li><strong>内存分配（Memory Allocation）</strong></li>
<li><strong>指针与引用</strong></li>
<li><strong>逃逸分析（Escape Analysis）</strong></li>
</ol>
<h3 id="1-堆和栈"><a href="#1-堆和栈" class="headerlink" title="1. 堆和栈"></a>1. <strong>堆和栈</strong></h3><p>Go 使用堆和栈来管理内存，像 C 语言一样，内存分为这两部分：</p>
<ul>
<li><strong>栈（Stack）</strong>：用于存储局部变量、函数调用等。栈的内存分配是由编译器自动管理的，且随着函数的调用和返回自动分配和释放。</li>
<li><strong>堆（Heap）</strong>：用于存储动态分配的对象，比如使用 <code>new</code> 或 <code>make</code> 创建的对象。堆内存由垃圾回收（GC）机制管理。</li>
</ul>
<h4 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h4><ul>
<li>栈内存的分配非常高效，因为栈是一个先进后出的结构，内存分配和释放非常迅速。</li>
<li>栈上的数据是自动回收的，局部变量的生命周期与其所在的函数的生命周期一致。</li>
</ul>
<h4 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h4><ul>
<li>堆内存是通过 <code>new</code> 或 <code>make</code> 显式分配的，内存释放由垃圾回收器管理。</li>
<li>堆上的数据通常具有较长的生命周期，可以跨越多个函数调用和 goroutine。</li>
</ul>
<h3 id="2-垃圾回收（GC）"><a href="#2-垃圾回收（GC）" class="headerlink" title="2. 垃圾回收（GC）"></a>2. <strong>垃圾回收（GC）</strong></h3><p>Go 的垃圾回收（GC）机制是自动的，目的是减少内存泄漏和提高内存使用的效率。Go 使用 <strong>标记-清除（Mark-and-Sweep）</strong> 和 <strong>三色标记法（Tri-Color Marking）</strong> 来进行垃圾回收。</p>
<h4 id="GC-的工作原理："><a href="#GC-的工作原理：" class="headerlink" title="GC 的工作原理："></a>GC 的工作原理：</h4><ol>
<li><strong>标记阶段</strong>：首先，GC 会扫描所有活动的对象，并标记它们为“活动”（Reachable）。活动对象包括从根对象（如全局变量、栈上的变量等）可直接访问到的对象。</li>
<li><strong>清除阶段</strong>：接着，GC 会清除那些没有被标记为活动的对象，释放它们所占用的内存。</li>
<li><strong>压缩阶段（optional）</strong>：对于某些实现，GC 可能还会进行内存的压缩（移动活动对象）以减少内存碎片。</li>
</ol>
<p>Go 的垃圾回收器是 <strong>并行且增量的</strong>，可以在程序运行时进行垃圾回收，而不会阻塞程序执行过长时间。Go 1.5 之后，GC 的性能得到了大幅改进，减少了对程序的影响。</p>
<h4 id="GC-触发时机："><a href="#GC-触发时机：" class="headerlink" title="GC 触发时机："></a>GC 触发时机：</h4><p>Go 会定期进行垃圾回收，通常有以下几种情况会触发 GC：</p>
<ul>
<li><strong>内存使用超过某个阈值</strong>：当堆内存的使用量超过了设定的阈值时，GC 会被触发。</li>
<li>**显式调用 <code>runtime.GC()</code>**：你可以通过调用 <code>runtime.GC()</code> 手动触发 GC，但这通常是不推荐的，除非在特定情况下需要精确控制。</li>
</ul>
<h4 id="配置垃圾回收："><a href="#配置垃圾回收：" class="headerlink" title="配置垃圾回收："></a>配置垃圾回收：</h4><p>你可以使用 <code>GOGC</code> 环境变量来调整垃圾回收的频率：</p>
<ul>
<li><code>GOGC=100</code>（默认）：表示在堆内存增长 100% 时触发 GC。</li>
<li>设置为更高的值，如 <code>GOGC=200</code>，表示需要堆内存增长到 200% 才会触发 GC，通常可以降低 GC 的频率，从而提高性能，但会增加内存占用。</li>
</ul>
<h3 id="3-内存分配（Memory-Allocation）"><a href="#3-内存分配（Memory-Allocation）" class="headerlink" title="3. 内存分配（Memory Allocation）"></a>3. <strong>内存分配（Memory Allocation）</strong></h3><p>Go 提供了多种内存分配方式，最常见的是通过 <code>new</code> 和 <code>make</code> 来分配内存：</p>
<ul>
<li><p>**<code>new</code>**：<code>new</code> 用于分配零值初始化的内存并返回指向该内存块的指针。它通常用于分配基础类型或结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br>p = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)  <span class="hljs-comment">// p 指向一个值为 0 的 int</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>**<code>make</code>**：<code>make</code> 用于分配并初始化切片（<code>slice</code>）、映射（<code>map</code>）、通道（<code>channel</code>）等特殊类型。<code>make</code> 会返回一个初始化后的引用，不是指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)  <span class="hljs-comment">// 创建一个空的映射</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)       <span class="hljs-comment">// 创建一个通道</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>直接分配</strong>：Go 支持通过常规的声明直接分配内存，如使用 <code>var</code> 或 <code>:=</code> 语法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span>  <span class="hljs-comment">// 栈分配一个 int</span><br>b := <span class="hljs-number">10</span>    <span class="hljs-comment">// 自动分配并初始化变量</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="内存池（Memory-Pool）："><a href="#内存池（Memory-Pool）：" class="headerlink" title="内存池（Memory Pool）："></a>内存池（Memory Pool）：</h4><p>Go 还提供了内存池（<code>sync.Pool</code>）来优化内存的分配和回收。它适用于短生命周期的对象，避免频繁的内存分配和回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> pool = sync.Pool&#123;<br>    New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)  <span class="hljs-comment">// 自定义对象池生成新对象</span><br>    &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := pool.Get().(*<span class="hljs-type">int</span>)  <span class="hljs-comment">// 从池中获取对象</span><br>    *p = <span class="hljs-number">42</span><br>    fmt.Println(*p)  <span class="hljs-comment">// 输出: 42</span><br>    pool.Put(p)      <span class="hljs-comment">// 将对象放回池中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-指针与引用"><a href="#4-指针与引用" class="headerlink" title="4. 指针与引用"></a>4. <strong>指针与引用</strong></h3><p>Go 支持指针，但是没有显式的指针运算（即没有像 C 语言那样的指针算术）。指针是 Go 中的重要概念，尤其是在传递大型对象或结构体时，通过指针传递可以避免对象的拷贝，提高效率。</p>
<h4 id="示例：使用指针"><a href="#示例：使用指针" class="headerlink" title="示例：使用指针"></a>示例：使用指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(x *<span class="hljs-type">int</span>)</span></span> &#123;<br>    *x++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-number">10</span><br>    increment(&amp;a)  <span class="hljs-comment">// 传递指向 a 的指针</span><br>    fmt.Println(a)  <span class="hljs-comment">// 输出: 11</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Go 中的指针与 C 语言类似，但是没有指针算术功能，指针只能用于引用数据，而不能做加减运算。</p>
<h3 id="5-逃逸分析（Escape-Analysis）"><a href="#5-逃逸分析（Escape-Analysis）" class="headerlink" title="5. 逃逸分析（Escape Analysis）"></a>5. <strong>逃逸分析（Escape Analysis）</strong></h3><p>Go 语言的编译器会进行 <strong>逃逸分析</strong>，它决定了变量是分配在栈上还是堆上。如果变量在函数返回后仍然被使用（例如，作为 goroutine 的参数），它将分配在堆上；如果变量仅在函数内使用，并且没有逃逸出去，它将分配在栈上。</p>
<h4 id="示例：逃逸分析"><a href="#示例：逃逸分析" class="headerlink" title="示例：逃逸分析"></a>示例：逃逸分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>    a := <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> &amp;a  <span class="hljs-comment">// a 的指针逃逸到堆上</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := newInt()<br>    fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，变量 <code>a</code> 的指针被返回并被 <code>main</code> 函数使用，导致编译器将 <code>a</code> 从栈上分配到堆上，避免栈内存的过早回收。</p>
<h3 id="6-内存泄漏"><a href="#6-内存泄漏" class="headerlink" title="6. 内存泄漏"></a>6. <strong>内存泄漏</strong></h3><p>Go 的垃圾回收机制能帮助我们自动回收不再使用的对象，防止内存泄漏。但如果一个对象的引用仍然存在，即使不再需要它，GC 也无法回收它，导致内存泄漏。</p>
<p>例如，切片、映射或通道的引用如果被误持有，可能会导致它们无法被垃圾回收。</p>
<h4 id="示例：内存泄漏"><a href="#示例：内存泄漏" class="headerlink" title="示例：内存泄漏"></a>示例：内存泄漏</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createLeak</span><span class="hljs-params">()</span></span> []<span class="hljs-type">int</span> &#123;<br>    slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)<br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    leak := createLeak()  <span class="hljs-comment">// 内存泄漏：slice 被返回并持有</span><br>    fmt.Println(<span class="hljs-built_in">len</span>(leak))<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-总结："><a href="#7-总结：" class="headerlink" title="7. 总结："></a>7. <strong>总结</strong>：</h3><p>Go 的内存管理机制结合了 <strong>垃圾回收</strong> 和 <strong>自动内存分配</strong>，极大地简化了内存管理的复杂性，避免了显式的内存释放操作（如 <code>free</code>），同时依然提供了足够的控制能力。</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>Go 语言的网络编程非常简单且高效，得益于其内置的 <strong><code>net</code></strong> 包，它提供了大量功能来实现网络通信，支持 TCP、UDP、HTTP、DNS 等协议的客户端和服务端编程。Go 的并发模型（goroutines 和 channels）使得处理并发连接变得非常简便。</p>
<h3 id="1-TCP-服务端和客户端"><a href="#1-TCP-服务端和客户端" class="headerlink" title="1. TCP 服务端和客户端"></a>1. <strong>TCP 服务端和客户端</strong></h3><h4 id="TCP-服务端"><a href="#TCP-服务端" class="headerlink" title="TCP 服务端"></a>TCP 服务端</h4><p>Go 语言通过 <code>net.Listen</code> 来创建一个监听指定端口的 TCP 服务器。服务器可以接收客户端的连接请求，接着通过 <code>Accept</code> 方法获取连接并处理。</p>
<h5 id="示例：TCP-服务端"><a href="#示例：TCP-服务端" class="headerlink" title="示例：TCP 服务端"></a>示例：TCP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, err := conn.Read(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>        conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> listener.Close()<br>    fmt.Println(<span class="hljs-string">&quot;Server is listening on port 8080...&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error accepting connection:&quot;</span>, err)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)  <span class="hljs-comment">// 使用 goroutine 处理每个连接</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>net.Listen</code> 创建一个监听端口 8080 的 TCP 服务器。</li>
<li><code>listener.Accept</code> 等待客户端连接，一旦接收到连接，<code>handleConnection</code> 被调用来处理通信。</li>
<li>使用 <code>go</code> 关键字为每个连接启动一个新的 goroutine，从而支持并发连接。</li>
</ul>
<h4 id="TCP-客户端"><a href="#TCP-客户端" class="headerlink" title="TCP 客户端"></a>TCP 客户端</h4><p>客户端通过 <code>net.Dial</code> 连接到服务端，向服务器发送数据并接收响应。</p>
<h5 id="示例：TCP-客户端"><a href="#示例：TCP-客户端" class="headerlink" title="示例：TCP 客户端"></a>示例：TCP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br><br>    <span class="hljs-comment">// 向服务端发送数据</span><br>    conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, server!&quot;</span>))<br><br>    <span class="hljs-comment">// 读取服务端响应</span><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    n, err := conn.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Server response:&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个客户端示例中：</p>
<ul>
<li><code>net.Dial</code> 用于连接到指定的 TCP 服务端。</li>
<li>通过 <code>conn.Write</code> 发送消息，使用 <code>conn.Read</code> 接收服务端返回的消息。</li>
</ul>
<h3 id="2-UDP-服务端和客户端"><a href="#2-UDP-服务端和客户端" class="headerlink" title="2. UDP 服务端和客户端"></a>2. <strong>UDP 服务端和客户端</strong></h3><p>与 TCP 不同，UDP 是一种无连接协议，因此不需要建立连接，直接向指定地址发送数据包即可。</p>
<h4 id="UDP-服务端"><a href="#UDP-服务端" class="headerlink" title="UDP 服务端"></a>UDP 服务端</h4><h5 id="示例：UDP-服务端"><a href="#示例：UDP-服务端" class="headerlink" title="示例：UDP 服务端"></a>示例：UDP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 UDP 地址</span><br>    addr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 监听 UDP 地址</span><br>    conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>, addr)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    fmt.Println(<span class="hljs-string">&quot;UDP server listening on port 8080...&quot;</span>)<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, addr, err := conn.ReadFromUDP(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading from UDP:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s from %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]), addr)<br>        conn.WriteToUDP([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>), addr)  <span class="hljs-comment">// 向客户端发送响应</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="UDP-客户端"><a href="#UDP-客户端" class="headerlink" title="UDP 客户端"></a>UDP 客户端</h4><h5 id="示例：UDP-客户端"><a href="#示例：UDP-客户端" class="headerlink" title="示例：UDP 客户端"></a>示例：UDP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建 UDP 地址</span><br>    addr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    <span class="hljs-comment">// 连接到 UDP 服务端</span><br>    conn, err := net.DialUDP(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-literal">nil</span>, addr)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br><br>    <span class="hljs-comment">// 向服务器发送消息</span><br>    conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, server!&quot;</span>))<br><br>    <span class="hljs-comment">// 读取响应</span><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    n, err := conn.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Server response:&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>UDP 客户端和服务端的通信相较于 TCP 更简单，不需要连接管理，但它不提供数据传输的可靠性保证。</p>
<h3 id="3-HTTP-服务端和客户端"><a href="#3-HTTP-服务端和客户端" class="headerlink" title="3. HTTP 服务端和客户端"></a>3. <strong>HTTP 服务端和客户端</strong></h3><p>Go 的 <code>net/http</code> 包提供了方便的 HTTP 服务端和客户端功能。</p>
<h4 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h4><p>Go 中实现 HTTP 服务端非常简单，可以通过 <code>http.HandleFunc</code> 注册路由，使用 <code>http.ListenAndServe</code> 启动服务器。</p>
<h5 id="示例：HTTP-服务端"><a href="#示例：HTTP-服务端" class="headerlink" title="示例：HTTP 服务端"></a>示例：HTTP 服务端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, helloHandler)<br>    fmt.Println(<span class="hljs-string">&quot;HTTP server listening on port 8080...&quot;</span>)<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error starting server:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>http.HandleFunc</code> 用来注册路由和处理函数。当收到 HTTP 请求时，<code>helloHandler</code> 会被调用，返回 <code>&quot;Hello, World!&quot;</code>。</p>
<h4 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h4><p>Go 提供了 <code>http.Get</code>、<code>http.Post</code> 等方法，简化了 HTTP 请求的发送。</p>
<h5 id="示例：HTTP-客户端"><a href="#示例：HTTP-客户端" class="headerlink" title="示例：HTTP 客户端"></a>示例：HTTP 客户端</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 发送 HTTP GET 请求</span><br>    resp, err := http.Get(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>    <span class="hljs-comment">// 读取响应数据</span><br>    body, err := ioutil.ReadAll(resp.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Server Response:&quot;</span>, <span class="hljs-type">string</span>(body))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>http.Get</code> 向本地运行的 HTTP 服务发送请求，并打印返回的数据。</p>
<h3 id="4-HTTP-服务器和路由"><a href="#4-HTTP-服务器和路由" class="headerlink" title="4. HTTP 服务器和路由"></a>4. <strong>HTTP 服务器和路由</strong></h3><p>Go 语言的 <code>net/http</code> 包也支持高级路由功能。你可以使用 <strong><code>http.ServeMux</code></strong> 或第三方路由库（如 <strong>Gin</strong>、<strong>Echo</strong>）来创建更复杂的 HTTP 路由和中间件。</p>
<h4 id="示例：自定义路由"><a href="#示例：自定义路由" class="headerlink" title="示例：自定义路由"></a>示例：自定义路由</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    mux := http.NewServeMux()<br>    mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, helloHandler)<br>    <br>    fmt.Println(<span class="hljs-string">&quot;HTTP server listening on port 8080...&quot;</span>)<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error starting server:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>http.NewServeMux</code> 创建了一个自定义的路由器，并为 <code>/</code> 路径注册了 <code>helloHandler</code>。</p>
<h3 id="5-使用-goroutines-和-channels-实现并发"><a href="#5-使用-goroutines-和-channels-实现并发" class="headerlink" title="5. 使用 goroutines 和 channels 实现并发"></a>5. <strong>使用 goroutines 和 channels 实现并发</strong></h3><p>Go 的并发模型使得处理多个并发连接非常简单。通过 <code>goroutines</code> 和 <code>channels</code>，你可以轻松地管理多个连接和通信。</p>
<h4 id="示例：并发处理-TCP-连接"><a href="#示例：并发处理-TCP-连接" class="headerlink" title="示例：并发处理 TCP 连接"></a>示例：并发处理 TCP 连接</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;net&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConnection</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        n, err := conn.Read(buffer)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error reading:&quot;</span>, err)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer[:n]))<br>        conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello from server!&quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> listener.Close()<br>    fmt.Println(<span class="hljs-string">&quot;Server is listening on port 8080...&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        conn, err := listener.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Println(<span class="hljs-string">&quot;Error accepting connection:&quot;</span>, err)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> handleConnection(conn)  <span class="hljs-comment">// 为每个连接启动一个 goroutine</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们通过 <code>go</code> 启动了一个新的 goroutine，来处理每个连接，从而支持并发的 TCP 服务端。</p>
<h1 id="文件流处理"><a href="#文件流处理" class="headerlink" title="文件流处理"></a>文件流处理</h1><p>Go 语言提供了丰富的文件流处理功能，能够进行高效的文件读取、写入和处理。Go 使用标准库中的 <code>os</code> 和 <code>io</code> 包来处理文件操作，支持同步和异步的文件流操作。</p>
<h3 id="1-打开和关闭文件"><a href="#1-打开和关闭文件" class="headerlink" title="1. 打开和关闭文件"></a>1. <strong>打开和关闭文件</strong></h3><p>要操作文件，首先需要通过 <code>os.Open</code> 或 <code>os.OpenFile</code> 打开文件。打开文件后，我们可以进行读取、写入或其他操作。操作完成后，记得通过 <code>defer file.Close()</code> 关闭文件。</p>
<h4 id="示例：打开文件"><a href="#示例：打开文件" class="headerlink" title="示例：打开文件"></a>示例：打开文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 打开文件，只读模式</span><br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close() <span class="hljs-comment">// 程序退出时关闭文件</span><br><br>    fmt.Println(<span class="hljs-string">&quot;File opened successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>os.Open</code> 打开文件以进行读取。如果文件不存在或无法打开，会返回错误。</li>
<li><code>defer file.Close()</code> 确保在函数退出时关闭文件，避免资源泄露。</li>
</ul>
<h4 id="示例：以可读写模式打开文件"><a href="#示例：以可读写模式打开文件" class="headerlink" title="示例：以可读写模式打开文件"></a>示例：以可读写模式打开文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.OpenFile(<span class="hljs-string">&quot;example.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure>

<p><code>os.O_RDWR</code> 表示以读写模式打开文件，<code>os.O_CREATE</code> 表示如果文件不存在则创建，<code>0666</code> 是文件的权限。</p>
<h3 id="2-文件读取"><a href="#2-文件读取" class="headerlink" title="2. 文件读取"></a>2. <strong>文件读取</strong></h3><p>Go 提供了多种读取文件的方法，最常见的包括：</p>
<ul>
<li>使用 <code>Read</code> 方法逐字节读取文件。</li>
<li>使用 <code>ReadLine</code> 逐行读取文件。</li>
<li>使用 <code>ioutil.ReadFile</code> 一次性读取整个文件。</li>
</ul>
<h4 id="示例：逐字节读取文件"><a href="#示例：逐字节读取文件" class="headerlink" title="示例：逐字节读取文件"></a>示例：逐字节读取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>    bytesRead, err := file.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Read %d bytes: %s\n&quot;</span>, bytesRead, <span class="hljs-type">string</span>(buffer[:bytesRead]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在此示例中：</p>
<ul>
<li><code>file.Read(buffer)</code> 逐字节读取文件，最多读取 <code>1024</code> 字节，返回实际读取的字节数。</li>
<li>读取的内容存储在 <code>buffer</code> 中，并通过 <code>string(buffer[:bytesRead])</code> 转换为字符串。</li>
</ul>
<h4 id="示例：逐行读取文件"><a href="#示例：逐行读取文件" class="headerlink" title="示例：逐行读取文件"></a>示例：逐行读取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Open(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    scanner := bufio.NewScanner(file)<br>    <span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>        fmt.Println(scanner.Text())  <span class="hljs-comment">// 打印每一行</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>bufio.NewScanner(file)</code> 创建了一个逐行读取文件的扫描器。</li>
<li>使用 <code>scanner.Scan()</code> 遍历文件中的每一行，并使用 <code>scanner.Text()</code> 获取当前行的内容。</li>
</ul>
<h4 id="示例：一次性读取整个文件"><a href="#示例：一次性读取整个文件" class="headerlink" title="示例：一次性读取整个文件"></a>示例：一次性读取整个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    content, err := ioutil.ReadFile(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;File content:\n%s\n&quot;</span>, content)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ioutil.ReadFile</code> 会将整个文件读取到内存中，如果文件很大，需要小心内存使用。</p>
<h3 id="3-文件写入"><a href="#3-文件写入" class="headerlink" title="3. 文件写入"></a>3. <strong>文件写入</strong></h3><p>Go 提供了多种文件写入方式，包括：</p>
<ul>
<li>使用 <code>Write</code> 方法逐字节写入文件。</li>
<li>使用 <code>WriteString</code> 将字符串写入文件。</li>
<li>使用 <code>ioutil.WriteFile</code> 一次性写入文件。</li>
</ul>
<h4 id="示例：写入文件（覆盖）"><a href="#示例：写入文件（覆盖）" class="headerlink" title="示例：写入文件（覆盖）"></a>示例：写入文件（覆盖）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.Create(<span class="hljs-string">&quot;output.txt&quot;</span>)  <span class="hljs-comment">// 创建并打开文件（覆盖模式）</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    _, err = file.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Data written to file successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>os.Create</code> 用于创建文件并打开。如果文件已存在，会覆盖原文件。</li>
<li><code>file.Write([]byte(&quot;Hello, World!&quot;))</code> 将字节写入文件。</li>
</ul>
<h4 id="示例：追加模式写入文件"><a href="#示例：追加模式写入文件" class="headerlink" title="示例：追加模式写入文件"></a>示例：追加模式写入文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.OpenFile(<span class="hljs-string">&quot;output.txt&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>_, err = file.WriteString(<span class="hljs-string">&quot;Appending text...\n&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Data appended to file.&quot;</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>os.OpenFile</code> 使用 <code>os.O_APPEND</code> 标志以追加模式打开文件。</li>
<li><code>file.WriteString</code> 用于写入字符串。</li>
</ul>
<h4 id="示例：一次性写入整个文件"><a href="#示例：一次性写入整个文件" class="headerlink" title="示例：一次性写入整个文件"></a>示例：一次性写入整个文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, Go!&quot;</span>)<br>    err := ioutil.WriteFile(<span class="hljs-string">&quot;output.txt&quot;</span>, data, <span class="hljs-number">0644</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Data written to file.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ioutil.WriteFile</code> 会覆盖文件内容，如果文件不存在，则会创建文件。</p>
<h3 id="4-文件复制"><a href="#4-文件复制" class="headerlink" title="4. 文件复制"></a>4. <strong>文件复制</strong></h3><p>Go 通过 <code>io.Copy</code> 可以实现文件的复制。</p>
<h4 id="示例：文件复制"><a href="#示例：文件复制" class="headerlink" title="示例：文件复制"></a>示例：文件复制</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    src, err := os.Open(<span class="hljs-string">&quot;source.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> src.Close()<br><br>    dst, err := os.Create(<span class="hljs-string">&quot;destination.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> dst.Close()<br><br>    _, err = io.Copy(dst, src)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;File copied successfully.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>io.Copy</code> 会将源文件的内容复制到目标文件中。它可以高效地处理大文件，因为它会在内部使用缓冲区。</p>
<h3 id="5-文件指针"><a href="#5-文件指针" class="headerlink" title="5. 文件指针"></a>5. <strong>文件指针</strong></h3><p>可以通过 <code>Seek</code> 方法控制文件指针的位置，允许在文件中进行随机访问。</p>
<h4 id="示例：使用-Seek-进行文件定位"><a href="#示例：使用-Seek-进行文件定位" class="headerlink" title="示例：使用 Seek 进行文件定位"></a>示例：使用 Seek 进行文件定位</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    file, err := os.OpenFile(<span class="hljs-string">&quot;example.txt&quot;</span>, os.O_RDWR, <span class="hljs-number">0666</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close()<br><br>    <span class="hljs-comment">// 定位到文件的第 5 个字节</span><br>    _, err = file.Seek(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 0 表示从文件开头开始定位</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    buffer := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">5</span>)<br>    _, err = file.Read(buffer)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Read from position 5: %s\n&quot;</span>, <span class="hljs-type">string</span>(buffer))<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>file.Seek(5, 0)</code> 将文件指针移动到文件的第 5 个字节位置，然后读取接下来的数据。</p>
<h3 id="6-文件权限和文件信息"><a href="#6-文件权限和文件信息" class="headerlink" title="6. 文件权限和文件信息"></a>6. <strong>文件权限和文件信息</strong></h3><p>Go 提供了 <code>os.Stat</code> 和 <code>os.Lstat</code> 用来获取文件的基本信息，包括文件大小、权限、修改时间等。</p>
<h4 id="示例：获取文件信息"><a href="#示例：获取文件信息" class="headerlink" title="示例：获取文件信息"></a>示例：获取文件信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fileInfo, err := os.Stat(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(err)<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;File name: %s\n&quot;</span>, fileInfo.Name())<br>    fmt.Printf(<span class="hljs-string">&quot;File size: %d bytes\n&quot;</span>, fileInfo.Size())<br>    fmt.Printf(<span class="hljs-string">&quot;File mode: %s\n&quot;</span>, fileInfo.Mode())<br>    fmt.Printf(<span class="hljs-string">&quot;Last modified: %s\n&quot;</span>, fileInfo.ModTime())<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>os.Stat</code> 返回一个 <code>os.FileInfo</code> 对象，其中包含文件的元数据（如大小、权限、修改时间等）。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// diameterOfBinaryTree 函数，返回二叉树的直径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span> <span class="hljs-comment">// 存储最大直径</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span> <span class="hljs-comment">// 声明 depth 函数</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rt *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> rt == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        L := depth(rt.Left)   <span class="hljs-comment">// 左子树的深度</span><br>        R := depth(rt.Right)  <span class="hljs-comment">// 右子树的深度</span><br>        ans = max(ans, L+R)   <span class="hljs-comment">// 更新最大直径</span><br>        <span class="hljs-keyword">return</span> max(L, R) + <span class="hljs-number">1</span>  <span class="hljs-comment">// 返回当前节点为根的子树的深度</span><br>    &#125;<br><br>    depth(root)  <br>    <span class="hljs-keyword">return</span> ans   <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>函数是第一类公民</strong>： 在 Go 中，函数是“第一类公民”，这意味着函数可以像其他类型的变量一样进行赋值、传递和调用。因此，可以将一个匿名函数赋值给一个函数类型的变量（如 <code>depth</code>）。</p>
<p><strong>匿名函数（闭包）</strong>：比如 <code>depth</code> 是一个匿名函数（没有名字的函数），它作为一个闭包可以访问外部的 <code>ans</code> 变量。闭包是指一个函数和它的环境（外部变量）绑定在一起。在这里，<code>depth</code> 函数能够访问 <code>ans</code> 变量并且递归调用自己。</p>
<p><strong>函数变量的定义与赋值</strong>： 首先声明了一个函数变量 <code>depth</code>，并定义了它的类型：<code>func(*TreeNode) int</code>，表示它是一个接受 <code>*TreeNode</code> 类型参数并返回 <code>int</code> 的函数。然后你通过 <code>depth = func(rt *TreeNode) int &#123; ... &#125;</code> 来将一个匿名函数赋值给这个变量。赋值后，<code>depth</code> 就成为了一个可用的函数，你可以像调用普通函数一样调用它。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="category-chain-item">基础知识</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/" class="category-chain-item">Golang</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="print-no-link">#基础知识</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Goalng语法概览</div>
      <div>http://example.com/2023/08/10/Golang语法概览/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Golang%E8%AF%AD%E8%A8%80/" title="深入学习Golang语言">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入学习Golang语言</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/" title="软件安全, 基础与进阶, 密码学体系框架">
                        <span class="hidden-mobile">软件安全, 基础与进阶, 密码学体系框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
