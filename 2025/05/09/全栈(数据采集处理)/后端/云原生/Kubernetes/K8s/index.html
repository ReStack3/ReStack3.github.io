

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="Kubernetes 文档 | Kubernetes  为什么需要Kubernetes?在前面Docker技术原理浅析 - The Peak Tower我们简单谈到了Docker用于构建和运行容器,目前已经被很多公司采用，从单机走向集群已成为必然。Docker在单机环境，管理少量容器中尚可，但想象一下假如有1000个以上的微服务容器集群需要管理，其中的调度、扩展和负载均衡，又或者自动扩展、自我修复">
<meta property="og:type" content="article">
<meta property="og:title" content="K8s基础知识">
<meta property="og:url" content="http://example.com/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E5%90%8E%E7%AB%AF/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/K8s/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="Kubernetes 文档 | Kubernetes  为什么需要Kubernetes?在前面Docker技术原理浅析 - The Peak Tower我们简单谈到了Docker用于构建和运行容器,目前已经被很多公司采用，从单机走向集群已成为必然。Docker在单机环境，管理少量容器中尚可，但想象一下假如有1000个以上的微服务容器集群需要管理，其中的调度、扩展和负载均衡，又或者自动扩展、自我修复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/02/08/SME2kqyQpFgKl5V.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/EVhTS6xYJKiun5m.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/UvutF8LNPcxECKn.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/Eli4ARQxvyFpku6.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/rXfuRPg3zxWZySm.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/dor4uSjZIPYBHRq.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/rtkaJIUf6x5TmSl.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/Lk3TuogqnwVl5eP.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/DojuWbV1st49wPc.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/jbVBSUvuJMYfhAs.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/IrP5wui4v7XMRJk.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/TYU3LSOVIQZverH.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/swPhCkrUI4Q6gpm.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/pY1Nr6Rfq5ZP3hO.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/ToIjLbOGruC5lWR.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/F4wQ2vWxH8VOnSg.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/8o9EjrI4mFA6fGt.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/c8DNv7pSnudxyRm.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/o6SHxC3jP5d8VUI.png">
<meta property="og:image" content="c:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250213171136005.png">
<meta property="og:image" content="https://s2.loli.net/2025/02/13/KmjzQnVbw7s6Euv.png">
<meta property="article:published_time" content="2025-05-09T07:31:42.131Z">
<meta property="article:modified_time" content="2025-05-09T13:15:40.767Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/02/08/SME2kqyQpFgKl5V.png">
  
  
  
  <title>K8s基础知识 - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="K8s基础知识"></span>
          
        </div>

        
          
  <div class="mt-3">
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          106 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">K8s基础知识</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>
<p><img src="https://s2.loli.net/2025/02/08/SME2kqyQpFgKl5V.png" srcset="/img/loading.gif" lazyload alt="K8s架构图"></p>
<h1 id="为什么需要Kubernetes"><a href="#为什么需要Kubernetes" class="headerlink" title="为什么需要Kubernetes?"></a>为什么需要Kubernetes?</h1><p>在前面<a target="_blank" rel="noopener" href="https://wangxiaobai08.github.io/2024/11/26/%E4%BB%80%E4%B9%88%E6%98%AFDocker/">Docker技术原理浅析 - The Peak Tower</a>我们简单谈到了Docker用于构建和运行容器,目前已经被很多公司采用，从单机走向集群已成为必然。Docker在单机环境，管理少量容器中尚可，但想象一下假如有1000个以上的微服务容器集群需要管理，其中的调度、扩展和负载均衡，又或者自动扩展、自我修复、滚动更新等功能。仅凭Docke来说将异常困难。于是，Kubernetes就被引入了。</p>
<p>其主要作用就是：</p>
<ol>
<li><strong>大规模管理</strong>：当容器数量增多时，手动管理变得困难，Kubernetes 提供自动化管理。</li>
<li><strong>高可用性</strong>：Kubernetes 能自动替换故障容器，确保应用持续运行。</li>
<li><strong>扩展性</strong>：支持根据负载自动扩展或缩减容器数量。</li>
<li><strong>服务发现与负载均衡</strong>：自动管理服务发现和负载均衡，简化网络配置。</li>
<li><strong>存储管理</strong>：提供持久化存储解决方案，支持多种存储后端。</li>
</ol>
<h1 id="什么是Kubernetes"><a href="#什么是Kubernetes" class="headerlink" title="什么是Kubernetes?"></a>什么是Kubernetes?</h1><blockquote>
<p>Kubernetes（通常缩写为 K8s）是一个开源的<strong>容器编排平台</strong>，用于自动化容器化应用的部署、扩展和管理。它由 Google 设计并捐赠给云原生计算基金会（CNCF），现已成为容器编排领域的事实标准。</p>
</blockquote>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Kubernetes中的大部分概念如Node、Pod、Replication Controller、Service等都可以被看作一种资源对象，几乎所有资源对象都可以通过Kubernetes提供的kubectl工具（或者API编程调用）执行增、删、改、查等操作并将其保存在etcd中持久化存储。从这个角度来看，Kubernetes其实是一个高度自动化的资源控制系统，它通过跟踪对比etcd库里保存的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错的高级功能。</p>
<p>Kubernetes平台采用了“核心+外围扩展”的设计思路，在保持平台核心稳定的同时具备持续演进升级的优势。Kubernetes大部分常见的核心资源对象都归属于v1这个核心API，比如Node、Pod、Service、Endpoints、Namespace、RC、PersistentVolume等。</p>
<p>我们可以采用YAML或JSON格式声明（定义或创建）一个Kubernetes资源对象，每个资源对象都有自己的特定语法格式（可以理解为数据库中一个特定的表），但随着Kubernetes版本的持续升级，一些资源对象会不断引入新的属性。</p>
<h2 id="Kubernetes-核心功能"><a href="#Kubernetes-核心功能" class="headerlink" title="Kubernetes 核心功能"></a>Kubernetes 核心功能</h2><table>
<thead>
<tr>
<th><strong>核心功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>容器编排</strong></td>
<td>自动化容器的部署、调度和管理，支持多容器应用的协同工作。</td>
</tr>
<tr>
<td><strong>自动扩展</strong></td>
<td>根据 CPU、内存等指标自动调整容器数量，支持水平扩展（Horizontal Pod Autoscaler）。</td>
</tr>
<tr>
<td><strong>自我修复</strong></td>
<td>自动重启故障容器，替换不健康的节点或容器。</td>
</tr>
<tr>
<td><strong>服务发现与负载均衡</strong></td>
<td>自动分配 IP 地址和 DNS 名称，提供内置的负载均衡机制。</td>
</tr>
<tr>
<td><strong>存储编排</strong></td>
<td>支持多种存储解决方案（如本地存储、云存储），自动挂载存储卷到容器。</td>
</tr>
<tr>
<td><strong>滚动更新与回滚</strong></td>
<td>支持无缝更新应用版本，在更新失败时自动回滚到上一版本。</td>
</tr>
<tr>
<td><strong>配置与密钥管理</strong></td>
<td>集中管理配置和敏感信息（如密码、密钥），支持动态更新配置。</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td>分配和管理 CPU、内存等资源，确保应用高效运行。</td>
</tr>
<tr>
<td><strong>网络策略</strong></td>
<td>定义容器间的网络通信规则，增强安全性。</td>
</tr>
<tr>
<td><strong>多租户支持</strong></td>
<td>支持多个团队或项目共享集群，通过命名空间隔离资源。</td>
</tr>
<tr>
<td><strong>监控与日志</strong></td>
<td>集成监控工具（如 Prometheus）和日志系统（如 Fluentd），便于运维和故障排查。</td>
</tr>
<tr>
<td><strong>跨平台支持</strong></td>
<td>支持多种云平台（如 AWS、Azure、GCP）和本地环境，提供一致的部署体验。</td>
</tr>
</tbody></table>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><strong>微服务架构</strong>：适合管理复杂的微服务应用。</li>
<li><strong>CI&#x2F;CD 流水线</strong>：与 Jenkins、GitLab 等工具集成，实现持续交付。</li>
<li><strong>混合云与多云环境</strong>：统一管理跨多个云平台的应用。</li>
<li><strong>大规模分布式系统</strong>：如大数据、机器学习等场景。</li>
</ol>
<h2 id="Kubernetes核心组件"><a href="#Kubernetes核心组件" class="headerlink" title="Kubernetes核心组件"></a>Kubernetes核心组件</h2><p>这里先简单了解一些Kubernetes 的核心组件，具体将在下面各节中叙述。</p>
<table>
<thead>
<tr>
<th><strong>核心组件</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Master 节点组件</strong></td>
<td></td>
</tr>
<tr>
<td>API Server</td>
<td>提供 Kubernetes API，是集群的控制入口，处理所有 REST 请求。</td>
</tr>
<tr>
<td>Scheduler</td>
<td>负责将 Pod 调度到合适的节点，基于资源需求和策略进行调度。</td>
</tr>
<tr>
<td>Controller Manager</td>
<td>管理各种控制器（如节点控制器、副本控制器），确保集群状态与期望状态一致。</td>
</tr>
<tr>
<td>etcd</td>
<td>分布式键值存储，保存集群的所有配置数据和状态信息。</td>
</tr>
<tr>
<td><strong>Worker 节点组件</strong></td>
<td></td>
</tr>
<tr>
<td>Kubelet</td>
<td>管理节点上的容器，与 Master 节点通信，确保 Pod 按预期运行。</td>
</tr>
<tr>
<td>Kube Proxy</td>
<td>负责网络代理和负载均衡，维护节点上的网络规则。</td>
</tr>
<tr>
<td>容器运行时</td>
<td>如 Docker、containerd，用于运行容器。</td>
</tr>
<tr>
<td><strong>核心对象</strong></td>
<td></td>
</tr>
<tr>
<td>Pod</td>
<td>Kubernetes 的最小部署单元，包含一个或多个容器，共享网络和存储资源。</td>
</tr>
<tr>
<td>Service</td>
<td>提供稳定的网络端点，用于访问一组 Pod，支持负载均衡和服务发现。</td>
</tr>
<tr>
<td>Deployment</td>
<td>定义应用的期望状态（如副本数、镜像版本），支持滚动更新和回滚。</td>
</tr>
<tr>
<td>ConfigMap</td>
<td>存储应用的配置信息，支持动态更新配置。</td>
</tr>
<tr>
<td>Secret</td>
<td>存储敏感信息（如密码、密钥），以加密形式保存。</td>
</tr>
<tr>
<td>Namespace</td>
<td>提供虚拟集群，用于隔离资源和管理多租户环境。</td>
</tr>
<tr>
<td>Volume</td>
<td>提供持久化存储，支持多种存储类型（如本地存储、云存储）。</td>
</tr>
<tr>
<td><strong>网络与安全组件</strong></td>
<td></td>
</tr>
<tr>
<td>Ingress</td>
<td>管理外部访问，提供 HTTP&#x2F;HTTPS 路由规则。</td>
</tr>
<tr>
<td>Network Policy</td>
<td>定义 Pod 间的网络通信规则，增强安全性。</td>
</tr>
<tr>
<td><strong>监控与日志组件</strong></td>
<td></td>
</tr>
<tr>
<td>Metrics Server</td>
<td>收集资源使用情况（如 CPU、内存），用于自动扩展和监控。</td>
</tr>
<tr>
<td>Prometheus</td>
<td>集成监控工具，提供集群和应用的详细监控数据。</td>
</tr>
<tr>
<td>Fluentd</td>
<td>日志收集工具，用于集中管理和分析日志。</td>
</tr>
</tbody></table>
<h2 id="Kubernnets系统组件关系"><a href="#Kubernnets系统组件关系" class="headerlink" title="Kubernnets系统组件关系"></a><strong>Kubernnets系统组件关系</strong></h2><p><img src="https://s2.loli.net/2025/02/13/EVhTS6xYJKiun5m.png" srcset="/img/loading.gif" lazyload alt="核心组件"></p>
<p><strong>对比：</strong></p>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>功能</strong></th>
<th><strong>核心原理</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>API Server</strong></td>
<td>处理外部请求、提供统一的 REST API</td>
<td>与 etcd 交互，验证请求，支持 watch 功能，处理集群状态的变化</td>
</tr>
<tr>
<td><strong>Controller Manager</strong></td>
<td>维持集群状态，确保资源的期望状态</td>
<td>通过控制循环和 watch 机制，确保集群资源的期望状态</td>
</tr>
<tr>
<td><strong>Scheduler</strong></td>
<td>将 Pod 调度到合适的节点</td>
<td>过滤和优选节点，考虑资源需求、亲和性等因素进行调度</td>
</tr>
<tr>
<td><strong>kubelet</strong></td>
<td>管理节点上容器的生命周期，确保 Pod 和容器正常运行</td>
<td>与 API Server 通信，启动和监控容器，更新容器状态</td>
</tr>
<tr>
<td><strong>kube-proxy</strong></td>
<td>提供服务发现和负载均衡功能</td>
<td>监控 Service 和 Endpoints，配置 iptables 或 ipvs 实现负载均衡</td>
</tr>
</tbody></table>
<h1 id="核心组件运行机制"><a href="#核心组件运行机制" class="headerlink" title="核心组件运行机制"></a>核心组件运行机制</h1><h2 id="Kubernetes-API-Server原理解析"><a href="#Kubernetes-API-Server原理解析" class="headerlink" title="Kubernetes API Server原理解析"></a>Kubernetes API Server原理解析</h2><p>Kubernetes API Server 是集群的核心组件，它充当集群的入口，处理客户端和其他控制组件的请求，提供统一的接口（REST API）进行管理和操作。所有对 Kubernetes 集群的操作都会通过 API Server 进行。</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p><strong>请求处理</strong>：API Server 通过 HTTP&#x2F;HTTPS 协议接收客户端请求（如 kubectl、Controller、Scheduler 等），并验证请求的合法性（如身份验证、权限控制）。</p>
<p><strong>集群状态</strong>：API Server 与 <strong>etcd</strong>（集群的分布式键值存储）交互，存储集群的所有状态数据（如 Pod、Service、Deployment 等资源对象）。API Server 将资源对象的状态保存到 etcd 中，并且在集群的状态发生变化时，API Server 会通知其他组件。</p>
<p><strong>API</strong>：API Server 提供 RESTful API，允许用户和其他组件通过 HTTP 请求对资源进行 CRUD 操作（如创建、读取、更新和删除）。</p>
<p><strong>Watch 功能</strong>：API Server 支持 watch 功能，允许客户端订阅资源对象的变化。例如，Controller Manager 会通过 watch 监听 Pod 状态变化并进行相应的操作。</p>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><ul>
<li>处理对集群资源的创建、修改、删除请求。</li>
<li>验证和授权 API 请求。</li>
<li>将请求转发给 etcd 存储集群状态。</li>
<li>支持 Watch 和 Notify 机制。</li>
</ul>
<h2 id="Controller-Manager原理解析"><a href="#Controller-Manager原理解析" class="headerlink" title="Controller Manager原理解析"></a>Controller Manager原理解析</h2><p>Controller Manager 是 Kubernetes 集群中负责调度和管理各种控制器的组件。它通过监控集群状态并根据需要进行必要的变更，确保集群始终处于期望状态。</p>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p><strong>控制循环</strong>：Controller Manager 中运行着多个控制器（如 ReplicaSet Controller、Deployment Controller、StatefulSet Controller 等）。每个控制器会不断地监视集群中的资源对象的状态，并通过调整资源的数量或状态来保持目标状态。</p>
<p><strong>工作流程</strong>：控制器的工作原理是不断对比当前状态和期望状态，若发现偏差，则会发起相关操作进行修复。例如，ReplicaSet 控制器会监控 Pod 的数量，若 Pod 数量不足，则会创建新的 Pod。</p>
<p><strong>资源监控</strong>：Controller Manager 通过 watch 功能实时监听 API Server 中的资源变化，一旦检测到状态不一致，就会采取相应的行动以达到期望的状态。</p>
<h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><ul>
<li>通过控制循环，维持集群资源的期望状态。</li>
<li>监控和响应集群中的资源对象的变化。</li>
</ul>
<h2 id="Scheduler原理解析"><a href="#Scheduler原理解析" class="headerlink" title="Scheduler原理解析"></a>Scheduler原理解析</h2><p>Kubernetes Scheduler 是负责将待调度的 Pod 安排到适当节点上的组件。它是根据资源需求、调度策略等因素来选择最合适的节点。</p>
<h4 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p><strong>待调度的 Pod</strong>：每当一个新的 Pod 被创建时，它会进入待调度状态。Scheduler 负责决定该 Pod 被调度到哪个节点。</p>
<p><strong>调度策略</strong>：Scheduler 会根据多种调度策略来选择最合适的节点，包括节点资源的可用性（如 CPU、内存）、节点标签、亲和性（Affinity）、反亲和性（Anti-Affinity）、拓扑等因素。</p>
<ul>
<li>过滤和优选：<ol>
<li><strong>过滤</strong>：Scheduler 首先根据 Pod 的资源需求和节点的资源状况，过滤出符合条件的节点。</li>
<li><strong>优选</strong>：然后，Scheduler 根据优先级算法，对这些符合条件的节点进行排序，选择最合适的节点。</li>
</ol>
</li>
</ul>
<p><strong>绑定 Pod</strong>：最终，Scheduler 会将 Pod 与选定的节点绑定，Pod 就会在该节点上运行。</p>
<h4 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><ul>
<li>选择合适的节点将 Pod 调度到集群中的适当位置。</li>
<li>使用调度策略和算法确保负载均衡和资源合理利用。</li>
</ul>
<h2 id="kubelet运行机制解析"><a href="#kubelet运行机制解析" class="headerlink" title="kubelet运行机制解析"></a>kubelet运行机制解析</h2><p>Kubelet 是每个节点上的核心组件，负责保证容器的运行。它通过与 API Server 进行通信，监控节点上的 Pod 并确保容器按预期运行。</p>
<h4 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p><strong>Pod 监控</strong>：Kubelet 监控本节点上运行的容器，并通过与 API Server 进行交互，确保容器的状态符合期望。</p>
<p><strong>容器管理</strong>：Kubelet 会将 Pod 中的容器启动、停止并监控其状态。如果容器崩溃或终止，Kubelet 会重新启动容器，以确保容器的健康。</p>
<p><strong>Pod 生命周期管理</strong>：Kubelet 还负责管理 Pod 的生命周期，执行 Pod 的启动、健康检查、日志记录等操作。</p>
<p><strong>同步状态</strong>：Kubelet 通过调用容器运行时（如 Docker 或 containerd）来启动容器，并向 API Server 更新 Pod 的状态信息。</p>
<h4 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><ul>
<li>启动、停止和维护容器的状态。</li>
<li>定期向 API Server 上报节点和 Pod 的状态。</li>
<li>管理容器的健康检查和日志。</li>
</ul>
<h2 id="kube-proxy运行机制解析"><a href="#kube-proxy运行机制解析" class="headerlink" title="kube-proxy运行机制解析"></a>kube-proxy运行机制解析</h2><p>Kube-proxy 是 Kubernetes 中实现网络负载均衡和服务发现的组件。它主要负责在集群中提供网络代理功能，并根据 Service 的定义配置负载均衡。</p>
<h4 id="原理：-4"><a href="#原理：-4" class="headerlink" title="原理："></a><strong>原理</strong>：</h4><p><strong>负载均衡</strong>：Kube-proxy 监视 Kubernetes API Server 中的 Service 和 Endpoint 资源，一旦有变化，它会在本地节点上配置负载均衡规则。Kube-proxy 支持多种模式，如 <strong>iptables</strong> 模式和 <strong>ipvs</strong> 模式，分别通过不同的机制实现负载均衡。</p>
<p><strong>流量代理</strong>：当客户端请求访问一个 Service 时，Kube-proxy 会根据其负载均衡策略将请求转发到后端的 Pod 上。</p>
<ul>
<li><strong>iptables 模式</strong>：使用 Linux 的 <code>iptables</code> 规则，基于 Service 的 IP 和端口将流量路由到对应的 Pod。</li>
<li><strong>ipvs 模式</strong>：使用 Linux 内核的 <code>IPVS</code> 模块进行负载均衡，提供更高效的负载均衡和更复杂的路由策略。</li>
</ul>
<p><strong>Service 和 Endpoints 管理</strong>：Kube-proxy 监控 API Server 上的 Service 和 Endpoint 对象的变化，及时调整负载均衡策略。</p>
<h4 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a><strong>功能</strong>：</h4><ul>
<li>提供集群内部的网络代理和负载均衡。</li>
<li>确保 Service 的访问能够路由到正确的 Pod。</li>
<li>支持多种负载均衡算法和流量转发机制。</li>
</ul>
<h1 id="Kubernetes-基础概念"><a href="#Kubernetes-基础概念" class="headerlink" title="Kubernetes 基础概念"></a>Kubernetes 基础概念</h1><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p>Kubernetes里的Master指的是集群控制节点，在每个Kubernetes集群里都需要有一个Master来负责整个集群的管理和控制，基本上Kubernetes的所有控制命令都发给它，它负责具体的执行过程，执行的所有命令基本都是在Master上运行的。Master通常会占据一个独立的服务器（高可用部署建议用3台服务器），主要原因是它太重要了，是整个集群的“首脑”，如果它宕机或者不可用，那么对集群内容器应用的管理都将失效。</p>
<p>在Master上运行着以下关键进程:</p>
<ul>
<li>Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程。</li>
<li>Kubernetes Controller Manager（kube-controller-manager）：Kubernetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的“大总管”。</li>
<li>Kubernetes Scheduler（kube-scheduler）：负责资源调度（Pod调度）的进程，相当于公交公司的“调度室”。另外，在Master上通常还需要部署etcd服务，因为Kubernetes里的所有资源对象的数据都被保存在etcd中。</li>
</ul>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>除了Master，Kubernetes集群中的其他机器被称为Node，在较早的版本中也被称为Minion。与Master一样，Node可以是一台物理主机，也可以是一台虚拟机。Node是Kubernetes集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。</p>
<p>在每个Node上都运行着以下关键进程。</p>
<ul>
<li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能。</li>
<li>kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。</li>
<li>Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作。</li>
</ul>
<p>Node可以在运行期间动态增加到Kubernetes集群中，前提是在这个节点上已经正确安装、配置和启动了上述关键进程，在默认情况下kubelet会向Master注册自己，这也是Kubernetes推荐的Node管理方式。一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身的情报，例如操作系统、Docker版本、机器的CPU和内存情况，以及当前有哪些Pod在运行等，这样Master就可以获知每个Node的资源使用情况，并实现高效均衡的资源调度策略。而某个Node在超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用（Not Ready），随后Master会触发“工作负载大转移”的自动流程。</p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><h3 id="为什需要Pod？"><a href="#为什需要Pod？" class="headerlink" title="为什需要Pod？"></a><strong>为什需要Pod？</strong></h3><p>原因一：在一组容器作为一个单元的情况下，我们难以简单地对“整体”进行判断及有效地行动。比如，一个容器死亡了，此时算是整体死亡么？是N&#x2F;M的死亡率么？引入业务无关并且不易死亡的Pause容器作为Pod的根容器，以它的状态代表整个容器组的状态，就简单、巧妙地解决了这个难题。</p>
<p>在实际使用时，单个容器是无法单独来支撑我们的应用，往往需要很多微服务才能组成一个系统，并且还会存在A服务依赖B服务，B服务需要和C服务共用某个目录，实现数据共享。另外，在使用裸容器时，很难实现对容器内进程的健康检查及横向扩容等，而Pod可以轻轻松松解决上述问题。</p>
<p><img src="https://s2.loli.net/2025/02/13/UvutF8LNPcxECKn.png" srcset="/img/loading.gif" lazyload alt="Pod图"></p>
<p>原因二：Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，这样既简化了密切关联的业务容器之间的通信问题，也很好地解决了它们之间的文件共享问题。</p>
<p>原因三：Docker只是容器Runtime（运行时）中的一种，市面上还有很多容器的Runtime，比如Rkt、CRI-O等，而Kubernetes作为目前最流行的容器编排工具，需要支持各个Runtime并且不依赖于底层Runtime的实现技术，于是就抽象了Pod这个概念，用于管理多个紧密相连的符合CRI标准的容器Docker只是容器Runtime（运行时）中的一种，市面上还有很多容器的Runtime，比如Rkt、CRI-O等，而Kubernetes作为目前最流行的容器编排工具，需要支持各个Runtime并且不依赖于底层Runtime的实现技术，于是就抽象了Pod这个概念，用于管理多个紧密相连的符合CRI标准的容器</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Pod可简单地理解为一组、一个或多个容器，每个Pod还包含一个Pause容器，Pause容器是Pod的父容器，它主要负责僵尸进程的回收管理，同时通过Pause容器可以使同一个Pod里面的不同容器共享存储、网络、PID、IPC等，容器之间可以使用localhost:port相互访问，可以使用Volume等实现数据共享。根据Docker的构造，Pod可被建模为一组具有共享命名空间、卷、IP地址和端口的容器。</p>
<h3 id="Pause容器"><a href="#Pause容器" class="headerlink" title="Pause容器"></a>Pause容器</h3><p>Pod是Kubernetes最重要的基本概念，如图所示是Pod的组成示意图，我们看到每个Pod都有一个特殊的被称为“根容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。</p>
<p><img src="https://s2.loli.net/2025/02/13/Eli4ARQxvyFpku6.png" srcset="/img/loading.gif" lazyload alt="Pod的组成示意图"></p>
<h3 id="Pod-IP"><a href="#Pod-IP" class="headerlink" title="Pod IP"></a>Pod IP</h3><p>使用裸容器时，需要将容器内应用程序的端口映射到宿主机，如果容器过多，端口管理就会比较困难，而且容易引起端口冲突。而Kubernetes为每个Pod都分配一个唯一的IP地址，称之为Pod IP，一个Pod里的多个容器共享Pod IP地址。这样就可以保证不同应用程序可以使用同一个端口，之后通过Kubernetes的内部Service进行访问，这样就避免了发生端口冲突的问题。Kubernetes要求底层网络支持集群内任意两个Pod之间的TCP&#x2F;IP直接通信，这通常采用虚拟二层网络技术来实现，例如Flannel、Open vSwitch等，因此需要牢记一点：在Kubernetes里，一个Pod里的容器与另外主机上的Pod容器能够直接通信。</p>
<h3 id="Pod分类"><a href="#Pod分类" class="headerlink" title="Pod分类"></a>Pod分类</h3><p>Pod其实有两种类型：普通的Pod及静态Pod（Static Pod）。后者比较特殊，它并没被存放在Kubernetes的etcd存储里，而是被存放在某个具体的Node上的一个具体文件中，并且只在此Node上启动、运行。</p>
<p>【静态Pod是由kubelet进行管理的仅存在于特定Node上的Pod。它们不能通过API Server进行管理，无法与ReplicationController、Deployment或者DaemonSet进行关联，并且kubelet无法对它们进行健康检查。静态Pod总是由kubelet创建的，并且总在kubelet所在的Node上运行。】</p>
<p>而普通的Pod一旦被创建，就会被放入etcd中存储，随后会被Kubernetes Master调度到某个具体的Node上并进行绑定（Binding），随后该Pod被对应的Node上的kubelet进程实例化成一组相关的Docker容器并启动。在默认情况下，当Pod里的某个容器停止时，Kubernetes会自动检测到这个问题并且重新启动这个Pod（重启Pod里的所有容器），如果Pod所在的Node宕机，就会将这个Node上的所有Pod重新调度到其他节点上。Pod、容器与Node的关系如图所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/rXfuRPg3zxWZySm.png" srcset="/img/loading.gif" lazyload alt="Pod、容器与Node的关系"></p>
<h3 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h3><blockquote>
<p>Kubernetes 创建 Pod 的过程涉及多个组件的协作：</p>
<ol>
<li>用户提交 Pod 定义。</li>
<li>API Server 接收请求并存储到 etcd。</li>
<li>Scheduler 调度 Pod 到合适的节点。</li>
<li>Kubelet 调用容器运行时创建容器。</li>
<li>容器启动后，Kubelet 监控并上报状态。</li>
</ol>
</blockquote>
<h4 id="用户提交-Pod-定义"><a href="#用户提交-Pod-定义" class="headerlink" title="用户提交 Pod 定义"></a>用户提交 Pod 定义</h4><p>YAML格式的Pod定义文件的完整内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs yaml">    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">imagePullPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">IfNotPresent</span>]<br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]<br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">string</span>]<br>        <span class="hljs-attr">workingDir:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span><br>          <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">exec:</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]<br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">httpHeaders:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">tcpSocket:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">securityContext:</span><br>      <span class="hljs-attr">privileged:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">OnFailure</span>]<br>  <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">object</span><br>  <span class="hljs-attr">imagePullSecrets:</span><br><span class="hljs-bullet">-</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>     <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>     <span class="hljs-attr">hostPath:</span><br>       <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>     <span class="hljs-attr">secret:</span><br>       <span class="hljs-attr">secretName:</span> <span class="hljs-string">string</span><br>       <span class="hljs-attr">items:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">items:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure>

<p>对各属性的详细说明如表所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/dor4uSjZIPYBHRq.png" srcset="/img/loading.gif" lazyload alt="对Pod定义文件模板中各属性的详细说明"></p>
<p><img src="https://s2.loli.net/2025/02/13/rtkaJIUf6x5TmSl.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<p><img src="https://s2.loli.net/2025/02/13/Lk3TuogqnwVl5eP.png" srcset="/img/loading.gif" lazyload alt="2"></p>
<p><img src="https://s2.loli.net/2025/02/13/DojuWbV1st49wPc.png" srcset="/img/loading.gif" lazyload alt="3"></p>
<h3 id="Pod生命周期和重启策略"><a href="#Pod生命周期和重启策略" class="headerlink" title="Pod生命周期和重启策略"></a>Pod生命周期和重启策略</h3><p>和裸容器部署一样，Pod在运行时也会有不同的状态，Pod的状态信息保存在PodStatus对象中，在PodStatus中有一个Phase字段，用于描述Pod在其生命周期中的不同状态。可以使用Kubernetes的客户端工具Kubectl查看某个Pod的Phase字段，比如查看kube-system命名空间下的metrics-server的状态。</p>
<p><img src="https://s2.loli.net/2025/02/13/jbVBSUvuJMYfhAs.png" srcset="/img/loading.gif" lazyload alt="Pod状态字段Phase的不同取值"></p>
<h3 id="Pod容器共享Volume"><a href="#Pod容器共享Volume" class="headerlink" title="Pod容器共享Volume"></a>Pod容器共享Volume</h3><p>同一个Pod中的多个容器能够共享Pod级别的存储卷Volume。Volume可以被定义为各种类型，多个容器各自进行挂载操作，将一个Volume挂载为容器内部需要的目录，如图所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/IrP5wui4v7XMRJk.png" srcset="/img/loading.gif" lazyload alt="Pod中多个容器共享Volume"></p>
<h3 id="Pod健康检查和服务可用性检查"><a href="#Pod健康检查和服务可用性检查" class="headerlink" title="Pod健康检查和服务可用性检查"></a>Pod健康检查和服务可用性检查</h3><p>在生产环境下，进程正常启动并不代表应用能正常处理请求，所以合理地设计应用的健康检查尤为重要。在使用裸机或者裸容器部署时，一般很难对应用做很完善的健康检查，而Pod提供的探针可以很方便地用来检测容器内的应用是否正常。目前探针有3种检测方式，可以根据不同的场景选择合适的健康检查方式。检测方式如表所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/TYU3LSOVIQZverH.png" srcset="/img/loading.gif" lazyload alt="Pod探针的实现方式"></p>
<p>上述检查方式可以被周期性执行，每次检查容器后可能得到的容器状态如表所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/swPhCkrUI4Q6gpm.png" srcset="/img/loading.gif" lazyload alt="Pod探针检查容器后可能得到的状态"></p>
<p>Kubelet实现上述检查有3种检测方式，在生产环境中多加利用可以提高应用的可用率。目前支持的探测器类型有3种，可以选择性地对容器进行检测，参考表。</p>
<p><img src="https://s2.loli.net/2025/02/13/pY1Nr6Rfq5ZP3hO.png" srcset="/img/loading.gif" lazyload alt="探针的种类"></p>
<h1 id="Kubernetes-调度基础"><a href="#Kubernetes-调度基础" class="headerlink" title="Kubernetes 调度基础"></a>Kubernetes 调度基础</h1><h2 id="Replication-Controller和ReplicaSet"><a href="#Replication-Controller和ReplicaSet" class="headerlink" title="Replication Controller和ReplicaSet"></a>Replication Controller和ReplicaSet</h2><h3 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p><strong>Replication Controller（RC）</strong> 是 Kubernetes 中的一个核心概念，用于确保指定数量的 Pod 副本始终处于运行状态。它的主要作用是实现 Pod 的自动扩缩容和自我修复。</p>
<hr>
<h4 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a><strong>核心定义</strong></h4><p>RC 通过声明式配置定义了一个期望状态，确保系统中某种 Pod 的副本数量始终符合预期。其定义包括以下三个关键部分：</p>
<table>
<thead>
<tr>
<th><strong>组成部分</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Pod 期待的副本数量</strong></td>
<td>指定希望运行的 Pod 副本数量（<code>replicas</code>）。</td>
</tr>
<tr>
<td><strong>Label Selector</strong></td>
<td>用于筛选目标 Pod 的标签选择器，RC 通过它来识别和管理属于它的 Pod。</td>
</tr>
<tr>
<td><strong>Pod 模板（template）</strong></td>
<td>当 Pod 副本数量不足时，RC 使用此模板创建新的 Pod。</td>
</tr>
</tbody></table>
<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
<hr>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><p>RC 通过以下机制确保 Pod 的副本数量始终符合预期：</p>
<ol>
<li><strong>监控 Pod 状态</strong>：<ul>
<li>RC 通过 Label Selector 持续监控系统中与其匹配的 Pod。</li>
</ul>
</li>
<li><strong>调整 Pod 数量</strong>：<ul>
<li>如果实际运行的 Pod 数量少于预期，RC 会根据 Pod 模板创建新的 Pod。</li>
<li>如果实际运行的 Pod 数量多于预期，RC 会删除多余的 Pod。</li>
</ul>
</li>
<li><strong>自我修复</strong>：<ul>
<li>如果某个 Pod 意外终止（如节点故障），RC 会自动创建新的 Pod 来替换它。</li>
</ul>
</li>
</ol>
<p> RC 的 YAML 定义示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-rc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 期望的 Pod 副本数量</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span>  <span class="hljs-comment"># 用于筛选 Pod 的标签选择器</span><br>  <span class="hljs-attr">template:</span>    <span class="hljs-comment"># Pod 模板</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span>  <span class="hljs-comment"># Pod 的标签，必须与 selector 匹配</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Replication Controller由于与Kubernetes代码中的模块Replication Controller同名，同时“Replication Controller”无法准确表达它的本意，所以在Kubernetes 1.2中，升级为另外一个新概念——Replica Set，官方解释其为“下一代的RC”。Replica Set与RC当前的唯一区别是，Replica Sets支持基于集合的Label selector（Set-based selector），而RC只支持基于等式的Label Selector（equality-based selector），这使得Replica Set的功能更强。</p>
</blockquote>
<h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>ReplicaSet是支持基于集合的标签选择器的下一代Replication Controller，它主要用作Deployment协调创建、删除和更新Pod，和Replication Controller唯一的区别是，ReplicaSet支持标签选择器。在实际应用中，虽然ReplicaSet可以单独使用，但是一般建议使用Deployment来自动管理ReplicaSet，除非自定义的Pod不需要更新或有其他编排等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-replicaset</span>  <span class="hljs-comment"># ReplicaSet 的名称</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span>           <span class="hljs-comment"># ReplicaSet 的标签</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">backend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>            <span class="hljs-comment"># 期望的 Pod 副本数量</span><br>  <span class="hljs-attr">selector:</span>              <span class="hljs-comment"># 用于选择 Pod 的标签选择器</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span>              <span class="hljs-comment"># Pod 模板</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span>       <span class="hljs-comment"># Pod 的标签，必须与 selector 匹配</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span>  <span class="hljs-comment"># 容器名称</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>           <span class="hljs-comment"># 容器镜像</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-comment"># 容器暴露的端口</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span>    <span class="hljs-comment"># 内存限制</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span>        <span class="hljs-comment"># CPU 限制</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span>     <span class="hljs-comment"># 内存请求</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span>        <span class="hljs-comment"># CPU 请求</span><br>        <span class="hljs-attr">livenessProbe:</span>         <span class="hljs-comment"># 存活探针</span><br>          <span class="hljs-attr">httpGet:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span>     <span class="hljs-comment"># 健康检查路径</span><br>            <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span>  <span class="hljs-comment"># 容器启动后延迟 10 秒开始检查</span><br>          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">5</span>         <span class="hljs-comment"># 每 5 秒检查一次</span><br></code></pre></td></tr></table></figure>

<p>Replication Controller和ReplicaSet的创建、删除和Pod并无太大区别，Replication Controller目前几乎已经不在生产环境中使用，ReplicaSet也很少单独被使用，都是使用更高级的资源Deployment、DaemonSet、StatefulSet管理Pod。</p>
<h2 id="无状态应用管理Deployment"><a href="#无状态应用管理Deployment" class="headerlink" title="无状态应用管理Deployment"></a>无状态应用管理Deployment</h2><p>前文提到的ReplicaSet可以确保在任何给定时间运行的Pod副本达到指定的数量，但是Deployment是一个更高级的概念，它管理ReplicaSet并为Pod和ReplicaSet提供声明性更新以及许多其他有用的功能，所以建议在生产环境下使用Deployment代替ReplicaSet。Deployment一般用于部署公司的无状态服务，这个也是最常用的控制器，因为企业内部现在都是以微服务为主，而微服务实现无状态化也是最佳实践，可以利用Deployment的高级功能做到无缝迁移、自动扩容缩容、自动灾难恢复、一键回滚等功能。</p>
<h3 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a><strong>创建 Deployment</strong></h3><h4 id="YAML-定义"><a href="#YAML-定义" class="headerlink" title="YAML 定义"></a><strong>YAML 定义</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-deployment.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>创建一个名为 <code>myapp-deployment</code> 的 Deployment。</li>
<li>使用 <code>nginx:1.14.2</code> 镜像，启动 3 个 Pod。</li>
<li>每个 Pod 暴露 80 端口。</li>
</ul>
<hr>
<h3 id="更新-Deployment"><a href="#更新-Deployment" class="headerlink" title="更新 Deployment"></a><strong>更新 Deployment</strong></h3><h4 id="更新镜像版本"><a href="#更新镜像版本" class="headerlink" title="更新镜像版本"></a><strong>更新镜像版本</strong></h4><p>假设我们需要将镜像从 <code>nginx:1.14.2</code> 更新到 <code>nginx:1.16.1</code>。</p>
<h4 id="命令行-1"><a href="#命令行-1" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image deployment/myapp-deployment myapp-container=nginx:1.16.1<br></code></pre></td></tr></table></figure>

<h4 id="YAML-更新"><a href="#YAML-更新" class="headerlink" title="YAML 更新"></a><strong>YAML 更新</strong></h4><p>修改 YAML 文件中的 <code>image</code> 字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.16.1</span><br></code></pre></td></tr></table></figure>
<p>然后重新应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-deployment.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>Kubernetes 会逐步替换旧的 Pod，创建新的 Pod，确保应用不中断。</li>
<li>可以通过以下命令查看更新状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout status deployment/myapp-deployment<br></code></pre></td></tr></table></figure>
<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="回滚-Deployment"><a href="#回滚-Deployment" class="headerlink" title="回滚 Deployment"></a><strong>回滚 Deployment</strong></h3><p>如果更新后发现问题，可以回滚到之前的版本。</p>
<h4 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a><strong>查看历史版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> deployment/myapp-deployment<br></code></pre></td></tr></table></figure>

<h4 id="回滚到上一个版本"><a href="#回滚到上一个版本" class="headerlink" title="回滚到上一个版本"></a><strong>回滚到上一个版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo deployment/myapp-deployment<br></code></pre></td></tr></table></figure>

<h4 id="回滚到指定版本"><a href="#回滚到指定版本" class="headerlink" title="回滚到指定版本"></a><strong>回滚到指定版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo deployment/myapp-deployment --to-revision=2<br></code></pre></td></tr></table></figure>

<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>Kubernetes 会记录每次 Deployment 的更新历史。</li>
<li>回滚操作会恢复到指定的历史版本。</li>
</ul>
<hr>
<h3 id="扩容-Deployment"><a href="#扩容-Deployment" class="headerlink" title="扩容 Deployment"></a><strong>扩容 Deployment</strong></h3><p>假设我们需要将 Pod 副本数量从 3 扩展到 5。</p>
<h4 id="命令行-2"><a href="#命令行-2" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl scale deployment myapp-deployment --replicas=5<br></code></pre></td></tr></table></figure>

<h4 id="YAML-更新-1"><a href="#YAML-更新-1" class="headerlink" title="YAML 更新"></a><strong>YAML 更新</strong></h4><p>修改 YAML 文件中的 <code>replicas</code> 字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">replicas:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>然后重新应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-deployment.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>Kubernetes 会自动创建新的 Pod，直到满足指定的副本数量。</li>
<li>可以通过以下命令查看 Pod 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods<br></code></pre></td></tr></table></figure>
<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="查看-Deployment-状态"><a href="#查看-Deployment-状态" class="headerlink" title="查看 Deployment 状态"></a><strong>查看 Deployment 状态</strong></h3><h4 id="查看-Deployment-详情"><a href="#查看-Deployment-详情" class="headerlink" title="查看 Deployment 详情"></a><strong>查看 Deployment 详情</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe deployment myapp-deployment<br></code></pre></td></tr></table></figure>

<h4 id="查看-Pod-状态"><a href="#查看-Pod-状态" class="headerlink" title="查看 Pod 状态"></a><strong>查看 Pod 状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l app=myapp<br></code></pre></td></tr></table></figure>

<h4 id="查看事件日志"><a href="#查看事件日志" class="headerlink" title="查看事件日志"></a><strong>查看事件日志</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get events<br></code></pre></td></tr></table></figure>

<h2 id="有状态应用管理StatefulSet"><a href="#有状态应用管理StatefulSet" class="headerlink" title="有状态应用管理StatefulSet"></a>有状态应用管理StatefulSet</h2><p>在Kubernetes系统中，Pod的管理对象RC、Deployment、DaemonSet和Job都面向无状态的服务。但现实中有很多服务是有状态的，特别是一些复杂的中间件集群，例如MySQL集群、MongoDB集群、Akka集群、ZooKeeper集群等，这些应用集群有4个共同点。</p>
<ul>
<li>每个节点都有固定的身份ID，通过这个ID，集群中的成员可以相互发现并通信。</li>
<li>集群的规模是比较固定的，集群规模不能随意变动。</li>
<li>集群中的每个节点都是有状态的，通常会持久化数据到永久存储中。</li>
<li>如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损。</li>
</ul>
<p>如果通过RC或Deployment控制Pod副本数量来实现上述有状态的集群，就会发现第1点是无法满足的，因为Pod的名称是随机产生的，Pod的IP地址也是在运行期才确定且可能有变动的，事先无法为每个Pod都确定唯一不变的ID。另外，为了能够在其他节点上恢复某个失败的节点，这种集群中的Pod需要挂接某种共享存储，为了解决这个问题，Kubernetes从1.4版本开始引入了PetSet这个新的资源对象，并且在1.5版本时更名为StatefulSet，StatefulSet从本质上来说，可以看作Deployment&#x2F;RC的一个特殊变种，它有如下特性。</p>
<p> StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名称为kafka，那么第1个Pod叫kafka-0，第2个叫kafka-1，以此类推。</p>
<ul>
<li>StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态。</li>
<li>StatefulSet里的Pod采用稳定的持久化存储卷，通过PV或PVC来实现，删除Pod时默认不会删除与StatefulSet相关的存储卷（为了保证数据的安全）。</li>
</ul>
<h3 id="创建-StatefulSet"><a href="#创建-StatefulSet" class="headerlink" title="创建 StatefulSet"></a><strong>创建 StatefulSet</strong></h3><h4 id="YAML-定义-1"><a href="#YAML-定义-1" class="headerlink" title="YAML 定义"></a><strong>YAML 定义</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-statefulset</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;myapp-service&quot;</span>  <span class="hljs-comment"># 关联的 Headless Service</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-storage</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span>  <span class="hljs-comment"># 持久化存储模板</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-storage</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure>

<h4 id="关联的-Headless-Service"><a href="#关联的-Headless-Service" class="headerlink" title="关联的 Headless Service"></a><strong>关联的 Headless Service</strong></h4><p>StatefulSet 需要与一个 <strong>Headless Service</strong> 关联，用于为每个 Pod 提供唯一的网络标识。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span>  <span class="hljs-comment"># Headless Service</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br></code></pre></td></tr></table></figure>

<h4 id="命令行-3"><a href="#命令行-3" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-service.yaml<br>kubectl apply -f myapp-statefulset.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>创建一个名为 <code>myapp-statefulset</code> 的 StatefulSet，包含 3 个 Pod。</li>
<li>每个 Pod 挂载一个独立的持久化存储卷（<code>myapp-storage</code>）。</li>
<li>使用 <code>nginx:1.14.2</code> 镜像，暴露 80 端口。</li>
</ul>
<hr>
<h3 id="更新-StatefulSet"><a href="#更新-StatefulSet" class="headerlink" title="更新 StatefulSet"></a><strong>更新 StatefulSet</strong></h3><h4 id="更新镜像版本-1"><a href="#更新镜像版本-1" class="headerlink" title="更新镜像版本"></a><strong>更新镜像版本</strong></h4><p>假设我们需要将镜像从 <code>nginx:1.14.2</code> 更新到 <code>nginx:1.16.1</code>。</p>
<h4 id="命令行-4"><a href="#命令行-4" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image statefulset/myapp-statefulset myapp-container=nginx:1.16.1<br></code></pre></td></tr></table></figure>

<h4 id="YAML-更新-2"><a href="#YAML-更新-2" class="headerlink" title="YAML 更新"></a><strong>YAML 更新</strong></h4><p>修改 YAML 文件中的 <code>image</code> 字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.16.1</span><br></code></pre></td></tr></table></figure>
<p>然后重新应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-statefulset.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>StatefulSet 会按顺序逐个更新 Pod，确保有状态应用的稳定性。</li>
<li>可以通过以下命令查看更新状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout status statefulset/myapp-statefulset<br></code></pre></td></tr></table></figure>
<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="回滚-StatefulSet"><a href="#回滚-StatefulSet" class="headerlink" title="回滚 StatefulSet"></a><strong>回滚 StatefulSet</strong></h3><p>如果更新后发现问题，可以回滚到之前的版本。</p>
<h4 id="查看历史版本-1"><a href="#查看历史版本-1" class="headerlink" title="查看历史版本"></a><strong>查看历史版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> statefulset/myapp-statefulset<br></code></pre></td></tr></table></figure>

<h4 id="回滚到上一个版本-1"><a href="#回滚到上一个版本-1" class="headerlink" title="回滚到上一个版本"></a><strong>回滚到上一个版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo statefulset/myapp-statefulset<br></code></pre></td></tr></table></figure>

<h4 id="回滚到指定版本-1"><a href="#回滚到指定版本-1" class="headerlink" title="回滚到指定版本"></a><strong>回滚到指定版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo statefulset/myapp-statefulset --to-revision=2<br></code></pre></td></tr></table></figure>

<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>StatefulSet 会按顺序逐个回滚 Pod，确保数据一致性。</li>
</ul>
<hr>
<h3 id="扩容-StatefulSet"><a href="#扩容-StatefulSet" class="headerlink" title="扩容 StatefulSet"></a><strong>扩容 StatefulSet</strong></h3><p>假设我们需要将 Pod 副本数量从 3 扩展到 5。</p>
<h4 id="命令行-5"><a href="#命令行-5" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl scale statefulset myapp-statefulset --replicas=5<br></code></pre></td></tr></table></figure>

<h4 id="YAML-更新-3"><a href="#YAML-更新-3" class="headerlink" title="YAML 更新"></a><strong>YAML 更新</strong></h4><p>修改 YAML 文件中的 <code>replicas</code> 字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">replicas:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>然后重新应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-statefulset.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>StatefulSet 会按顺序逐个创建新的 Pod，并为每个 Pod 分配独立的存储卷。</li>
<li>可以通过以下命令查看 Pod 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l app=myapp<br></code></pre></td></tr></table></figure>
<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="缩容-StatefulSet"><a href="#缩容-StatefulSet" class="headerlink" title="缩容 StatefulSet"></a><strong>缩容 StatefulSet</strong></h3><p>假设我们需要将 Pod 副本数量从 5 缩减到 3。</p>
<h4 id="命令行-6"><a href="#命令行-6" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl scale statefulset myapp-statefulset --replicas=3<br></code></pre></td></tr></table></figure>

<h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>StatefulSet 会按逆序逐个删除 Pod，确保数据安全。</li>
</ul>
<hr>
<h3 id="查看-StatefulSet-状态"><a href="#查看-StatefulSet-状态" class="headerlink" title="查看 StatefulSet 状态"></a><strong>查看 StatefulSet 状态</strong></h3><h4 id="查看-StatefulSet-详情"><a href="#查看-StatefulSet-详情" class="headerlink" title="查看 StatefulSet 详情"></a><strong>查看 StatefulSet 详情</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe statefulset myapp-statefulset<br></code></pre></td></tr></table></figure>

<h4 id="查看-Pod-状态-1"><a href="#查看-Pod-状态-1" class="headerlink" title="查看 Pod 状态"></a><strong>查看 Pod 状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l app=myapp<br></code></pre></td></tr></table></figure>

<h4 id="查看持久化存储卷"><a href="#查看持久化存储卷" class="headerlink" title="查看持久化存储卷"></a><strong>查看持久化存储卷</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pvc<br></code></pre></td></tr></table></figure>

<h2 id="守护进程集DaemonSet"><a href="#守护进程集DaemonSet" class="headerlink" title="守护进程集DaemonSet"></a>守护进程集DaemonSet</h2><p>DaemonSet（守护进程集，缩写为ds）和守护进程类似，它在符合匹配条件的节点上均部署一个Pod。</p>
<p>有时候我们需要在每个Kubernetes节点或符合条件的节点上都部署某个应用，那么就可以使用Kubernetes的DaemonSet调度Pod。DaemonSet确保全部（或者某些符合条件）节点上运行一个Pod副本。当有新节点加入集群时，也会为它们新增一个Pod，当节点从集群中移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod。</p>
<h3 id="创建-DaemonSet"><a href="#创建-DaemonSet" class="headerlink" title="创建 DaemonSet"></a><strong>创建 DaemonSet</strong></h3><h4 id="YAML-定义-2"><a href="#YAML-定义-2" class="headerlink" title="YAML 定义"></a><strong>YAML 定义</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-daemonset</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<h4 id="命令行-7"><a href="#命令行-7" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-daemonset.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>创建一个名为 <code>myapp-daemonset</code> 的 DaemonSet。</li>
<li>使用 <code>nginx:1.14.2</code> 镜像，在每个节点上运行一个 Pod。</li>
<li>每个 Pod 暴露 80 端口。<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="更新-DaemonSet"><a href="#更新-DaemonSet" class="headerlink" title="更新 DaemonSet"></a><strong>更新 DaemonSet</strong></h3><h4 id="更新镜像版本-2"><a href="#更新镜像版本-2" class="headerlink" title="更新镜像版本"></a><strong>更新镜像版本</strong></h4><p>假设我们需要将镜像从 <code>nginx:1.14.2</code> 更新到 <code>nginx:1.16.1</code>。</p>
<h4 id="命令行-8"><a href="#命令行-8" class="headerlink" title="命令行"></a><strong>命令行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image daemonset/myapp-daemonset myapp-container=nginx:1.16.1<br></code></pre></td></tr></table></figure>

<h4 id="YAML-更新-4"><a href="#YAML-更新-4" class="headerlink" title="YAML 更新"></a><strong>YAML 更新</strong></h4><p>修改 YAML 文件中的 <code>image</code> 字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.16.1</span><br></code></pre></td></tr></table></figure>
<p>然后重新应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f myapp-daemonset.yaml<br></code></pre></td></tr></table></figure>

<h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>DaemonSet 会逐步替换旧的 Pod，创建新的 Pod，确保每个节点上运行的是最新版本的镜像。</li>
<li>可以通过以下命令查看更新状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout status daemonset/myapp-daemonset<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="回滚-DaemonSet"><a href="#回滚-DaemonSet" class="headerlink" title="回滚 DaemonSet"></a><strong>回滚 DaemonSet</strong></h3><p>如果更新后发现问题，可以回滚到之前的版本。</p>
<h4 id="查看历史版本-2"><a href="#查看历史版本-2" class="headerlink" title="查看历史版本"></a><strong>查看历史版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> daemonset/myapp-daemonset<br></code></pre></td></tr></table></figure>

<h4 id="回滚到上一个版本-2"><a href="#回滚到上一个版本-2" class="headerlink" title="回滚到上一个版本"></a><strong>回滚到上一个版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo daemonset/myapp-daemonset<br></code></pre></td></tr></table></figure>

<h4 id="回滚到指定版本-2"><a href="#回滚到指定版本-2" class="headerlink" title="回滚到指定版本"></a><strong>回滚到指定版本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl rollout undo daemonset/myapp-daemonset --to-revision=2<br></code></pre></td></tr></table></figure>

<h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a><strong>说明</strong></h4><ul>
<li>DaemonSet 会逐步回滚 Pod，恢复到指定的历史版本。<ul>
<li>[全栈(数据采集处理), 后端, 云原生, Kubernetes]</li>
</ul>
</li>
</ul>
<hr>
<h3 id="节点调度"><a href="#节点调度" class="headerlink" title="节点调度"></a><strong>节点调度</strong></h3><p>DaemonSet 默认会在每个节点上运行一个 Pod，但可以通过节点选择器或污点&#x2F;容忍机制来控制 Pod 的调度。</p>
<h4 id="使用节点选择器"><a href="#使用节点选择器" class="headerlink" title="使用节点选择器"></a><strong>使用节点选择器</strong></h4><p>在 YAML 中指定 <code>nodeSelector</code>，只将 Pod 调度到具有特定标签的节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span>  <span class="hljs-comment"># 只调度到具有 disktype=ssd 标签的节点</span><br></code></pre></td></tr></table></figure>

<h4 id="使用污点和容忍"><a href="#使用污点和容忍" class="headerlink" title="使用污点和容忍"></a><strong>使用污点和容忍</strong></h4><p>如果节点上有污点（Taint），可以在 Pod 模板中定义容忍（Toleration），允许 Pod 调度到这些节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;key1&quot;</span><br>        <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>        <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;value1&quot;</span><br>        <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="查看-DaemonSet-状态"><a href="#查看-DaemonSet-状态" class="headerlink" title="查看 DaemonSet 状态"></a><strong>查看 DaemonSet 状态</strong></h3><h4 id="查看-DaemonSet-详情"><a href="#查看-DaemonSet-详情" class="headerlink" title="查看 DaemonSet 详情"></a><strong>查看 DaemonSet 详情</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe daemonset myapp-daemonset<br></code></pre></td></tr></table></figure>

<h4 id="查看-Pod-状态-2"><a href="#查看-Pod-状态-2" class="headerlink" title="查看 Pod 状态"></a><strong>查看 Pod 状态</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l app=myapp<br></code></pre></td></tr></table></figure>

<h4 id="查看节点上的-Pod-分布"><a href="#查看节点上的-Pod-分布" class="headerlink" title="查看节点上的 Pod 分布"></a><strong>查看节点上的 Pod 分布</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -o wide<br></code></pre></td></tr></table></figure>



<h1 id="Kubernetes-服务发布基础"><a href="#Kubernetes-服务发布基础" class="headerlink" title="Kubernetes 服务发布基础"></a>Kubernetes 服务发布基础</h1><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Label（标签）是Kubernetes系统中另外一个核心概念。一个Label是一个key&#x3D;value的键值对，其中key与value由用户自己指定。Label可以被附加到各种资源对象上，例如Node、Pod、Service、RC等，一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上。Label通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。我们可以通过给指定的资源对象捆绑一个或多个不同的Label来实现多维度的资源分组管理功能，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。例如，部署不同版本的应用到不同的环境中；监控和分析应用（日志记录、监控、告警）等。</p>
<p>使用Label可以给对象创建多组标签，Label和Label Selector共同构成了Kubernetes系统中核心的应用模型，使得被管理对象能够被精细地分组管理，同时实现了整个集群的高可用性。</p>
<p><img src="https://s2.loli.net/2025/02/13/ToIjLbOGruC5lWR.png" srcset="/img/loading.gif" lazyload alt="Label Selector的作用范围1"></p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>使用虚拟机或者裸容器部署应用时，程序之前的互相访问一般都是使用宿主机的IP地址和端口号进行访问的，因为宿主机的IP地址一般不会轻易改变，所以IP+端口的方式并没有什么大的问题。而使用Kubernetes的Pod部署应用时，Pod大部分都是随机地部署至最佳的节点上，并且经常被删除重建，所以Pod的IP地址并不是一成不变的，这样的话服务之前的访问就不能使用IP+端口的方式，所以Service应运而生。Service主要用于Pod之间的通信，对于Pod的IP地址而言，Service是提前定义好并且是不变的资源类型，在生产环境中最佳的实践方式就是每个应用互相调用时使用Service的名字进行连接，而非IP地址。</p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Kubernetes的Pod具有生命周期的概念，它可以被创建、删除、销毁，一旦被销毁就意味着生命周期的结束。通过ReplicaSet能够动态地创建和销毁Pod，例如进行扩缩容和执行滚动升级。每个Pod都会获取到它自己的IP地址，但是这些IP地址不总是稳定和可依赖的，这样就会导致一个问题：在Kubernetes集群中，如果一组Pod（比如后端的Pod）为其他Pod（比如前端的Pod）提供服务，那么如果它们之间使用Pod的IP地址进行通信，在Pod重建后，将无法再进行连接。</p>
<p>为了解决上述问题，Kubernetes引用了Service这样一种抽象概念：逻辑上的一组Pod，即一种可以访问Pod的策略，通常被称为微服务。这一组Pod能够被Service访问，通常是通过Label Selector（标签选择器）实现的，如图所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/F4wQ2vWxH8VOnSg.png" srcset="/img/loading.gif" lazyload alt="Service代理模式"></p>
<p>假设有一个用作图片处理的backend（后端），运行了3个副本，每个副本具有一个app&#x3D;backend的Label，这些副本是可互换（无状态）的，之后创建一个Service指定Selector为app&#x3D;backend，那么frontend（前端）即可通过这个Service的名称直接访问backend，所以frontend不需要关心它调用了哪个backend副本。即使组成这一组backend程序的Pod发生了变化，frontend也没有必要知道，而且也不需要跟踪这一组backend的状态，因为Service能够解耦这种关联。</p>
<h3 id="定义Service"><a href="#定义Service" class="headerlink" title="定义Service"></a>定义Service</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>             <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>              <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br><span class="hljs-attr">metadata:</span>                   <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>             <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span>       <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br><span class="hljs-attr">spec:</span>                        <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">selector:</span> []             <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>             <span class="hljs-string">//</span> <span class="hljs-string">Required</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-string">int</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-string">int</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-string">int</span><br>  <span class="hljs-attr">status:</span><br>    <span class="hljs-attr">loadBalancer:</span><br>      <span class="hljs-attr">ingress:</span><br>      <span class="hljs-attr">ip:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">hostname:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure>

<p>各属性的说明如表所示。</p>
<p><img src="https://s2.loli.net/2025/02/13/8o9EjrI4mFA6fGt.png" srcset="/img/loading.gif" lazyload alt="对Service的定义文件模板的各属性的说明"></p>
<p><img src="https://s2.loli.net/2025/02/13/c8DNv7pSnudxyRm.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<h3 id="Service的基本用法"><a href="#Service的基本用法" class="headerlink" title="Service的基本用法"></a>Service的基本用法</h3><p>对Service地址的访问被自动负载分发到了后端两个Pod之一。目前Kubernetes提供了两种负载分发策略：RoundRobin和SessionAffinity，具体说明如下。</p>
<ul>
<li>RoundRobin：轮询模式，即轮询将请求转发到后端的各个Pod上。</li>
<li>SessionAffinity：基于客户端IP地址进行会话保持的模式，即第1次将某个客户端发起的请求转发到后端的某个Pod上，之后从相同的客户端发起的请求都将被转发到后端相同的Pod上。</li>
</ul>
<p>在默认情况下，Kubernetes采用RoundRobin模式对客户端请求进行负载分发，但我们也可以通过设置service.spec.sessionAffinity&#x3D;ClientIP来启用SessionAffinity策略。这样，同一个客户端IP发来的请求就会被转发到后端固定的某个Pod上了。</p>
<h4 id="多端口Service"><a href="#多端口Service" class="headerlink" title="多端口Service"></a>多端口Service</h4><p>有时一个容器应用也可能提供多个端口的服务，那么在Service的定义中也可以相应地设置为将多个端口对应到多个应用服务。在下面的例子中，Service设置了两个端口号，并且为每个端口号都进行了命名：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8005</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8005</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">management</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br></code></pre></td></tr></table></figure>



<h4 id="外部服务Service"><a href="#外部服务Service" class="headerlink" title="外部服务Service"></a>外部服务Service</h4><p>在某些环境中，应用系统需要将一个外部数据库作为后端服务进行连接，或将另一个集群或Namespace中的服务作为服务的后端，这时可以通过创建一个无Label Selector的Service来实现：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>通过该定义创建的是一个不带标签选择器的Service，即无法选择后端的Pod，系统不会自动创建Endpoint，因此需要手动创建一个和该Service同名的Endpoint，用于指向实际的后端访问地址。创建Endpoint的配置文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">subsets:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">IP:</span> <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<p>如图所示，访问没有标签选择器的Service和带有标签选择器的Service一样，请求将会被路由到由用户手动定义的后端Endpoint上。</p>
<p><img src="https://s2.loli.net/2025/02/13/o6SHxC3jP5d8VUI.png" srcset="/img/loading.gif" lazyload alt=" Service指向外部服务"></p>
<h3 id="从集群外部访问Pod或Service"><a href="#从集群外部访问Pod或Service" class="headerlink" title="从集群外部访问Pod或Service"></a>从集群外部访问Pod或Service</h3><p>由于Pod和Service都是Kubernetes集群范围内的虚拟概念，所以集群外的客户端系统无法通过Pod的IP地址或者Service的虚拟IP地址和虚拟端口号访问它们。为了让外部客户端可以访问这些服务，可以将Pod或Service的端口号映射到宿主机，以使客户端应用能够通过物理机访问容器应用。</p>
<h4 id="将容器应用的端口号映射到物理机"><a href="#将容器应用的端口号映射到物理机" class="headerlink" title="将容器应用的端口号映射到物理机"></a>将容器应用的端口号映射到物理机</h4><p>（1）通过设置容器级别的hostPort，将容器应用的端口号映射到物理机上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pod-hostport.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure>

<p>（2）通过设置Pod级别的hostNetwork&#x3D;true，该Pod中所有容器的端口号都将被直接映射到物理机上。在设置hostNetwork&#x3D;true时需要注意，在容器的ports定义部分如果不指定hostPort，则默认hostPort等于containerPort，如果指定了hostPort，则hostPort必须等于containerPort的值：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pod-hostnetwork.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Never</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>



<h4 id="将Service的端口号映射到物理机"><a href="#将Service的端口号映射到物理机" class="headerlink" title="将Service的端口号映射到物理机"></a>将Service的端口号映射到物理机</h4><p>（1）通过设置nodePort映射到物理机，同时设置Service的类型为NodePort：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">8081</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">webapp</span><br></code></pre></td></tr></table></figure>

<p>（2）通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Service的场景。在下面的例子中，status.loadBalancer.ingress.ip设置的146.148.47.155为云服务商提供的负载均衡器的IP地址。对该Service的访问请求将会通过LoadBalancer转发到后端Pod上，负载分发的实现方式则依赖于云服务商提供的LoadBalancer的实现机制：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30061</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.171</span><span class="hljs-number">.239</span><br>  <span class="hljs-attr">loadBalancerIP:</span> <span class="hljs-number">78.11</span><span class="hljs-number">.24</span><span class="hljs-number">.19</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">loadBalancer:</span><br>    <span class="hljs-attr">ingress:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">146.148</span><span class="hljs-number">.47</span><span class="hljs-number">.155</span><br></code></pre></td></tr></table></figure>

<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>根据前面对Service的使用说明，我们知道Service的表现形式为IP:Port，即工作在TCP&#x2F;IP层。而对于基于HTTP的服务来说，不同的URL地址经常对应到不同的后端服务或者虚拟服务器（Virtual Host），这些应用层的转发机制仅通过Kubernetes的Service机制是无法实现的。从Kubernetes 1.1版本开始新增Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service，以实现HTTP层的业务路由机制。Kubernetes使用了一个Ingress策略定义和一个具体的Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。</p>
<p>使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，这样会跳过kube-proxy的转发功能，kube-proxy不再起作用。如果Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。</p>
<p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20250213171136005.png" srcset="/img/loading.gif" lazyload alt="典型的HTTP层路由"></p>
<p>通俗来讲，Ingress和之前提到的Service、Deployment等类似，也是一个Kubernetes的资源对象，Deployment是用来部署应用的，Ingress就是实现用域名的方式访问应用。Ingress实现的方式有很多，比如Nginx、HAProxy、Treafik等，就Nginx而言，和上述提到的传统服务架构用Nginx类似。Ingress控制器在每个符合条件的宿主机上部署一个Pod，这个Pod里面运行的就是Nginx进程，里面的实现逻辑和宿主机部署Nginx的方式并无太大区别，关键区别是宿主机部署的Nginx需要更改Nginx的配置文件配置域名，而Ingress则和其他Kubernetes资源文件一样，使用YAML文件进行配置，之后Ingress控制器根据YAML文件定义的内容自动生成对应的配置文件。</p>
<p><img src="https://s2.loli.net/2025/02/13/KmjzQnVbw7s6Euv.png" srcset="/img/loading.gif" lazyload alt="Ingress代理模式"></p>
<h3 id="创建一个Ingress"><a href="#创建一个Ingress" class="headerlink" title="创建一个Ingress"></a>创建一个Ingress</h3><p>创建Ingress和创建其他资源类似，也是使用YAML格式的文件。创建一个简单的Ingress代码如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mywebsite-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">mywebsite.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/demo</span><br>      <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">webapp</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<p>这个Ingress的定义，说明对目标地址<a target="_blank" rel="noopener" href="http://mywebsite.com/demo%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B0%86%E8%A2%AB%E8%BD%AC%E5%8F%91%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84Service">http://mywebsite.com/demo的访问将被转发到集群中的Service</a> webapp即webapp:8080&#x2F;demo上。在Ingress生效之前，需要先将webapp服务部署完成。同时需要注意Ingress中path的定义，需要与后端真实Service提供的path一致，否则将被转发到一个不存在的path上，引发错误。</p>
<h3 id="Ingress策略配置技巧"><a href="#Ingress策略配置技巧" class="headerlink" title="Ingress策略配置技巧"></a>Ingress策略配置技巧</h3><h4 id="转发到单个后端服务上"><a href="#转发到单个后端服务上" class="headerlink" title="转发到单个后端服务上"></a>转发到单个后端服务上</h4><p>基于这种设置，客户端到Ingress Controller的访问请求都将被转发到后端的唯一Service上，在这种情况下Ingress无须定义任何rule。通过如下所示的设置，对Ingress Controller的访问请求都将被转发到“myweb:8080”这个服务上。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">backend:</span><br>    <span class="hljs-attr">serviceName:</span> <span class="hljs-string">myweb</span><br>    <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<h4 id="同一域名下，不同的URL路径被转发到不同的服务上"><a href="#同一域名下，不同的URL路径被转发到不同的服务上" class="headerlink" title="同一域名下，不同的URL路径被转发到不同的服务上"></a>同一域名下，不同的URL路径被转发到不同的服务上</h4><p>这种配置常用于一个网站通过不同的路径提供不同的服务的场景，例如&#x2F;web表示访问Web页面，&#x2F;api表示访问API接口，对应到后端的两个服务，通过Ingress的设置很容易就能将基于URL路径的转发规则定义出来。通过如下所示的设置，对“mywebsite.com&#x2F;web”的访问请求将被转发到“web-service:80”服务上；对“mywebsite.com&#x2F;api”的访问请求将被转发到“api-service:80”服务上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">mywebsite.com</span><br>    <span class="hljs-attr">http:</span><br>    <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/web</span><br>      <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">web-service</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/api</span><br>      <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">api-service</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure>

<h4 id="不同的域名（虚拟主机名）被转发到不同的服务上"><a href="#不同的域名（虚拟主机名）被转发到不同的服务上" class="headerlink" title="不同的域名（虚拟主机名）被转发到不同的服务上"></a>不同的域名（虚拟主机名）被转发到不同的服务上</h4><p>这种配置常用于一个网站通过不同的域名或虚拟主机名提供不同服务的场景，例如foo.bar.com域名由service1提供服务，bar.foo.com域名由service2提供服务。通过如下所示的设置，对“foo.bar.com”的访问请求将被转发到“ service1:80”服务上，对“bar.foo.com”的访问请求将被转发到“service2:80”服务上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">foo.bar.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">service1</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">bar.foo.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">service2</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<h4 id="不使用域名的转发规则"><a href="#不使用域名的转发规则" class="headerlink" title="不使用域名的转发规则"></a>不使用域名的转发规则</h4><p>这种配置用于一个网站不使用域名直接提供服务的场景，此时通过任意一台运行ingress-controller的Node都能访问到后端的服务。以上节的后端服务webapp为例，下面的配置为将“<ingress-controller-ip>&#x2F;demo”的访问请求转发到“webapp:8080&#x2F;demo”服务上：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/demo</span><br>      <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">webapp</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<h3 id="Ingress的TLS安全设置"><a href="#Ingress的TLS安全设置" class="headerlink" title="Ingress的TLS安全设置"></a>Ingress的TLS安全设置</h3><p>为了Ingress提供HTTPS的安全访问，可以为Ingress中的域名进行TLS安全证书的设置。设置的步骤如下。</p>
<ol>
<li>创建自签名的密钥和SSL证书文件。</li>
<li>将证书保存到Kubernetes中的一个Secret资源对象上。</li>
<li>将该Secret对象设置到Ingress中。</li>
</ol>
<p>根据提供服务的网站域名是一个还是多个，可以使用不同的操作完成前两步SSL证书和Secret对象的创建，在只有一个域名的情况下设置相对简单。第3步对于这两种场景来说是相同的。对于只有一个域名的场景来说，可以通过OpenSSL工具直接生成密钥和证书文件，将命令行参数-subj中的&#x2F;CN设置为网站域名。</p>
<p>创建Ingress对象，在tls段引用刚刚创建好的Secret对象</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">mywebsite-ingress-tls.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mywebsite-ingress-tls</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mywebsite.com</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">mywebsite-ingress-secret</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">mywebsite.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/demo</span><br>      <span class="hljs-attr">backend:</span><br>        <span class="hljs-attr">serviceName:</span> <span class="hljs-string">myweb</span><br>        <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<h1 id="Kubernetes配置管理"><a href="#Kubernetes配置管理" class="headerlink" title="Kubernetes配置管理"></a>Kubernetes配置管理</h1><h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>传统架构中，配置文件往往被保存在宿主机上，程序启动时可以指定某个配置文件，但是使用容器部署时，容器所在的节点并不固定，所以不能使用这种方式，此处在构建镜像时，如果把配置文件也放在容器里面，那么配置文件一旦有更改的话，也是一件非常麻烦的事情。所以Kubernetes抽象了一个ConfigMap的概念，将配置与Pod和组件分开，这有助于保持工作负载的可移植性，使配置更易于更改和管理。比如在生产环境中，可以将Nginx、Redis等应用的配置文件存储在ConfigMap上，然后将其挂载即可使用。相对于Secret，ConfigMap更倾向于存储和共享非敏感、未加密的配置信息，假如是在集群中使用敏感信息，最好使用Secret。</p>
<h3 id="创建和使用ConfigMap"><a href="#创建和使用ConfigMap" class="headerlink" title="创建和使用ConfigMap"></a>创建和使用ConfigMap</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/larrydpk/p/14947993.html">Kubernetes ConfigMap详解，多种方式创建、多种方式使用 - 南瓜慢说 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangshenglu1/article/details/143979402">五种创建k8s的configMap的方式及configmap使用_kubectl通过目录创建configmap-CSDN博客</a></p>
<h3 id="挂载-ConfigMap"><a href="#挂载-ConfigMap" class="headerlink" title="挂载 ConfigMap"></a>挂载 ConfigMap</h3><h4 id="通过挂载为文件"><a href="#通过挂载为文件" class="headerlink" title="通过挂载为文件"></a>通过挂载为文件</h4><p>可以将 ConfigMap 中的每个键都作为一个文件挂载到容器中。每个键会变成一个文件，文件内容是对应的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/config</span>  <span class="hljs-comment"># 将 ConfigMap 挂载到容器中的目录</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>  <span class="hljs-comment"># 引用 ConfigMap</span><br></code></pre></td></tr></table></figure>

<p>此时，ConfigMap <code>my-config</code> 中的每个键会变成容器内 <code>/etc/config</code> 目录下的一个文件，文件内容为对应的值。例如，<code>key1</code> 会变成 <code>/etc/config/key1</code> 文件，内容为 <code>value1</code>。</p>
<h4 id="通过挂载为特定文件"><a href="#通过挂载为特定文件" class="headerlink" title="通过挂载为特定文件"></a><strong>通过挂载为特定文件</strong></h4><p>你还可以选择将 ConfigMap 中的某个键挂载为容器中的某个特定文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/config/key1</span>  <span class="hljs-comment"># 将特定键挂载为文件</span><br>      <span class="hljs-attr">subPath:</span> <span class="hljs-string">key1</span>  <span class="hljs-comment"># 使用 ConfigMap 中的 key1</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span><br></code></pre></td></tr></table></figure>

<p>此时，ConfigMap <code>my-config</code> 中的 <code>key1</code> 会被挂载为 <code>/etc/config/key1</code> 文件，文件内容为 <code>value1</code>。</p>
<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>上一节讲解的ConfigMap主要用于非安全的数据，与其对应的是Secret对象类型，用来保存敏感信息，例如密码、令牌和SSH Key，将这些信息放在Secret中比较安全和灵活。用户可以创建Secret并且引用到Pod中，比如使用Secret初始化Redis、MySQL密码等。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhanglianghhh/p/13743024.html">Kubernetes K8S之存储Secret详解 - 踏歌行666 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51964671/article/details/135485565">K8S Secret 一文详解, 全面覆盖 Secret 使用场景 | 全家桶-CSDN博客</a></p>
<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/" class="category-chain-item">全栈(数据采集处理)</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E5%90%8E%E7%AB%AF/%E4%BA%91%E5%8E%9F%E7%94%9F/" class="category-chain-item">云原生</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%A8%E6%A0%88-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86/%E5%90%8E%E7%AB%AF/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/" class="category-chain-item">Kubernetes</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="print-no-link">#软件工程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>K8s基础知识</div>
      <div>http://example.com/2025/05/09/全栈(数据采集处理)/后端/云原生/Kubernetes/K8s/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E5%90%8E%E7%AB%AF/%E4%BA%91%E5%8E%9F%E7%94%9F/Kubernetes/K8s%E8%BF%9B%E9%98%B6%E7%AF%87/" title="K8s存储和网络">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">K8s存储和网络</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/09/%E5%85%A8%E6%A0%88(%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%A4%84%E7%90%86)/%E5%90%8E%E7%AB%AF/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/%E4%BB%80%E4%B9%88%E6%98%AFDocker/" title="Docker技术原理浅析">
                        <span class="hidden-mobile">Docker技术原理浅析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
