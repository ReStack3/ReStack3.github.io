

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ling">
  <meta name="keywords" content="">
  
    <meta name="description" content="对象模型Redis 的 对象模型 是 Redis 内部用于管理数据的一种抽象机制。Redis 的所有数据（如字符串、列表、哈希表、集合、有序集合等）都被封装为 Redis 对象（Redis Object），并通过统一的对象模型进行管理。这种设计使得 Redis 能够高效地处理不同类型的数据，并提供丰富的功能和特性。 先来看正常情况下对Redis数据库进行的操作：    数据类型 操作 命令示例 R">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识(数据结构+线程模型+内存管理)">
<meta property="og:url" content="http://example.com/2025/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Redis/index.html">
<meta property="og:site_name" content="The Peak Tower">
<meta property="og:description" content="对象模型Redis 的 对象模型 是 Redis 内部用于管理数据的一种抽象机制。Redis 的所有数据（如字符串、列表、哈希表、集合、有序集合等）都被封装为 Redis 对象（Redis Object），并通过统一的对象模型进行管理。这种设计使得 Redis 能够高效地处理不同类型的数据，并提供丰富的功能和特性。 先来看正常情况下对Redis数据库进行的操作：    数据类型 操作 命令示例 R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/wQex21mqi4pnPAH.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/5DJEujVNdRbPAva.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/WXZ8wkm4raUJOoK.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/P74I2eQMcAXvbFx.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/7OjrIDkK125ZNYw.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/QzcqNtF1ZgwJ3Io.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/qZKYH2mak68sTie.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/OrnBQJhKvtjVp3S.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/ZdspeMYvUmIboXl.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/Mi6vglG9WNY8ReZ.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/wDmJNq1CnFV8aer.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/qpE2uZV1ixYRrMj.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/otZE71fJMAOW5NH.png">
<meta property="og:image" content="https://s2.loli.net/2025/01/08/YAcCskLvFjTy9rQ.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/5gK7Hi24GnIczwh.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/kPFWJHKx2R9NmXg.jpg">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/oASqrCilUsy68gj.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/izQRcMtw29VkZPg.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/cODY2Mbge1NE87Z.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/Mu4aF7imysngYJX.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/c8HIymthg6WxGru.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/ZjRkETzL59XoQb4.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/xmCVv4QokSfa5zH.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/19/zXxF6Jhi8RKknQO.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/18/CxUfeBjblgKdkAm.png">
<meta property="og:image" content="https://s2.loli.net/2025/03/18/P8otfJIsyp5u3Lw.png">
<meta property="article:published_time" content="2025-05-09T07:31:42.280Z">
<meta property="article:modified_time" content="2025-05-09T13:15:40.793Z">
<meta property="article:author" content="Ling">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2025/03/19/wQex21mqi4pnPAH.png">
  
  
  
  <title>基础知识(数据结构+线程模型+内存管理) - The Peak Tower</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7a4M5yfyGptX0OG18qvJppXQ-gzGzoHsz","app_key":"y6dZFtA8I8Lg1KVhHbujblfB","server_url":"https://7a4m5yfy.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="基础知识(数据结构+线程模型+内存管理)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          67 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">基础知识(数据结构+线程模型+内存管理)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h1><p>Redis 的 <strong>对象模型</strong> 是 Redis 内部用于管理数据的一种抽象机制。Redis 的所有数据（如字符串、列表、哈希表、集合、有序集合等）都被封装为 <strong>Redis 对象（Redis Object）</strong>，并通过统一的对象模型进行管理。这种设计使得 Redis 能够高效地处理不同类型的数据，并提供丰富的功能和特性。</p>
<p>先来看正常情况下对Redis数据库进行的操作：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>操作</strong></th>
<th><strong>命令示例</strong></th>
<th><strong>Redis 对象的创建与使用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符串（String）</strong></td>
<td>设置值</td>
<td><code>SET key value</code></td>
<td>创建一个字符串对象（<code>REDIS_STRING</code>），并将其存储在数据库中。</td>
</tr>
<tr>
<td></td>
<td>获取值</td>
<td><code>GET key</code></td>
<td>从数据库中获取对应的字符串对象，并返回其值。</td>
</tr>
<tr>
<td></td>
<td>删除值</td>
<td><code>DEL key</code></td>
<td>从数据库中删除对应的字符串对象，并释放内存。</td>
</tr>
<tr>
<td><strong>列表（List）</strong></td>
<td>左插入</td>
<td><code>LPUSH key value</code></td>
<td>创建一个列表对象（<code>REDIS_LIST</code>），并将值插入到列表中。如果列表不存在，先创建空列表对象。</td>
</tr>
<tr>
<td></td>
<td>右插入</td>
<td><code>RPUSH key value</code></td>
<td>同上。</td>
</tr>
<tr>
<td></td>
<td>获取范围</td>
<td><code>LRANGE key start stop</code></td>
<td>从数据库中获取对应的列表对象，并返回指定范围的元素。</td>
</tr>
<tr>
<td></td>
<td>删除元素</td>
<td><code>LPOP key</code> 或 <code>RPOP key</code></td>
<td>从列表中删除并返回第一个或最后一个元素。</td>
</tr>
<tr>
<td><strong>哈希表（Hash）</strong></td>
<td>设置字段值</td>
<td><code>HSET key field value</code></td>
<td>创建一个哈希表对象（<code>REDIS_HASH</code>），并将字段和值存储在哈希表中。如果哈希表不存在，先创建空哈希表对象。</td>
</tr>
<tr>
<td></td>
<td>获取字段值</td>
<td><code>HGET key field</code></td>
<td>从数据库中获取对应的哈希表对象，并返回指定字段的值。</td>
</tr>
<tr>
<td></td>
<td>删除字段</td>
<td><code>HDEL key field</code></td>
<td>从哈希表中删除指定字段。</td>
</tr>
<tr>
<td><strong>集合（Set）</strong></td>
<td>添加元素</td>
<td><code>SADD key member</code></td>
<td>创建一个集合对象（<code>REDIS_SET</code>），并将元素添加到集合中。如果集合不存在，先创建空集合对象。</td>
</tr>
<tr>
<td></td>
<td>获取所有元素</td>
<td><code>SMEMBERS key</code></td>
<td>从数据库中获取对应的集合对象，并返回所有元素。</td>
</tr>
<tr>
<td></td>
<td>删除元素</td>
<td><code>SREM key member</code></td>
<td>从集合中删除指定元素。</td>
</tr>
<tr>
<td><strong>有序集合（ZSet）</strong></td>
<td>添加元素</td>
<td><code>ZADD key score member</code></td>
<td>创建一个有序集合对象（<code>REDIS_ZSET</code>），并将元素和分值存储在有序集合中。如果有序集合不存在，先创建空有序集合对象。</td>
</tr>
<tr>
<td></td>
<td>获取范围</td>
<td><code>ZRANGE key start stop</code></td>
<td>从数据库中获取对应的有序集合对象，并返回指定范围的元素。</td>
</tr>
<tr>
<td></td>
<td>删除元素</td>
<td><code>ZREM key member</code></td>
<td>从有序集合中删除指定元素。</td>
</tr>
</tbody></table>
<p>可以看出：Redis 的所有操作都是基于 Redis 对象进行的。</p>
<blockquote>
<p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;        <span class="hljs-comment">// 对象的类型（如字符串、列表、哈希表等）</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 对象的编码方式（底层实现）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;  <span class="hljs-comment">// LRU 时间或 LFU 数据（用于内存淘汰策略）</span><br>    <span class="hljs-type">int</span> refcount;           <span class="hljs-comment">// 引用计数（用于内存管理）</span><br>    <span class="hljs-type">void</span> *ptr;              <span class="hljs-comment">// 指向实际数据的指针，指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</span><br>&#125; robj;<br></code></pre></td></tr></table></figure>

<p>其中最重要的是：<strong>类型（type）</strong> 和 <strong>编码（encoding）</strong></p>
<p>Redis 的所有操作（如插入、删除、查询等）都是基于这些对象进行的。例如：</p>
<ul>
<li>当执行 <code>SET key value</code> 时，Redis 会创建一个字符串对象，并将其存储在数据库中。</li>
<li>当执行 <code>LPUSH key value</code> 时，Redis 会创建一个列表对象，并将值插入到列表中。</li>
</ul>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a><strong><code>type</code></strong></h3><p>表示对象的类型，占 4 位。可能的取值：</p>
<img src="https://s2.loli.net/2025/03/19/wQex21mqi4pnPAH.png" srcset="/img/loading.gif" lazyload alt="image-20250319125355176" style="zoom:50%;" />

<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a><strong><code>encoding</code></strong></h3><p>表示对象的编码方式，占 4 位。编码方式决定了对象的底层实现数据结构。可能的取值：</p>
<p>对于字符串对象：</p>
<ul>
<li><code>REDIS_ENCODING_INT</code>：整数编码。</li>
<li><code>REDIS_ENCODING_EMBSTR</code>：嵌入式字符串编码。</li>
<li><code>REDIS_ENCODING_RAW</code>：原始字符串编码。</li>
</ul>
<p>对于列表对象：</p>
<ul>
<li><code>REDIS_ENCODING_ZIPLIST</code>：压缩列表编码。</li>
<li><code>REDIS_ENCODING_LINKEDLIST</code>：双向链表编码。</li>
</ul>
<p>对于哈希表对象：</p>
<ul>
<li><code>REDIS_ENCODING_ZIPLIST</code>：压缩列表编码。</li>
<li><code>REDIS_ENCODING_HT</code>：哈希表编码。</li>
</ul>
<p>对于集合对象：</p>
<ul>
<li><code>REDIS_ENCODING_INTSET</code>：整数集合编码。</li>
<li><code>REDIS_ENCODING_HT</code>：哈希表编码。</li>
</ul>
<p>对于有序集合对象：</p>
<ul>
<li><code>REDIS_ENCODING_ZIPLIST</code>：压缩列表编码。</li>
<li><code>REDIS_ENCODING_SKIPLIST</code>：跳跃表编码。</li>
</ul>
<p>整体结构如下：</p>
<p><img src="https://s2.loli.net/2025/03/19/5DJEujVNdRbPAva.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="使用-RedisObject-的好处"><a href="#使用-RedisObject-的好处" class="headerlink" title="使用 RedisObject 的好处"></a>使用 RedisObject 的好处</h2><ol>
<li>通过不同类型的对象，Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</li>
<li>RedisObject 中有一个 <code>lru</code> 字段，用于支持基于 LRU（最近最少使用）或 LFU（最不经常使用）的内存淘汰策略。</li>
<li>RedisObject 提供了一种统一的接口，使得 Redis 能够方便地支持新的数据类型和操作。<ul>
<li>所有 Redis 数据都被封装为 RedisObject，通过统一的接口进行管理。</li>
<li>当需要支持新的数据类型时，只需定义新的 <code>type</code> 和 <code>encoding</code>，并实现相应的操作函数。</li>
</ul>
</li>
<li>RedisObject 使用引用计数（<code>refcount</code>）来管理内存，确保对象在不再被引用时能够被正确释放。</li>
<li>可以针对不同的使用场景，为对象设置不同的实现，从而优化内存或查询速度。Redis 可以根据不同的使用场景，为对象设置不同的编码方式，从而优化内存使用或查询速度。<ul>
<li>Redis 对象中有一个 <code>encoding</code> 字段，用于标识对象的底层实现（如压缩列表、哈希表、跳跃表等）。</li>
<li>根据数据的大小和特点，Redis 会动态选择最合适的编码方式：<ul>
<li><strong>内存优化</strong>：对于小型数据，Redis 使用紧凑的编码方式（如压缩列表、整数集合），以减少内存占用。</li>
<li><strong>性能优化</strong>：对于大型数据，Redis 使用高效的编码方式（如哈希表、跳跃表），以提高查询和操作速度。</li>
</ul>
</li>
<li>这种多编码实现机制使得 Redis 能够在不同场景下提供最佳的性能和内存效率。</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/03/19/WXZ8wkm4raUJOoK.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="动态简单字符串"><a href="#动态简单字符串" class="headerlink" title="动态简单字符串"></a>动态简单字符串</h2><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><p><img src="https://s2.loli.net/2025/01/08/P74I2eQMcAXvbFx.png" srcset="/img/loading.gif" lazyload></p>
<p>SDS 不仅可以保存文本数据，还可以保存二进制数据</p>
<ul>
<li>因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据；</li>
<li>所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据；</li>
</ul>
<h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p>SDS 获取字符串长度的时间复杂度是 O(1)</p>
<p>因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>；</p>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p><strong>减少内存重分配的策略</strong>：</p>
<ul>
<li><strong>逐步增长</strong>：每次增加字符串长度时，SDS会选择适度增加内存而非立即扩展至精确所需的大小。通过这种“宽松”的增长策略，避免了每次修改都进行内存重分配。</li>
<li><strong>空闲空间复用</strong>：当缩短字符串时（比如执行<code>SDS</code>的<code>del</code>操作），SDS会适当地释放多余的空间，而不是立即重分配内存，这样可以避免不必要的内存分配。</li>
</ul>
<p><img src="https://s2.loli.net/2025/01/08/7OjrIDkK125ZNYw.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://s2.loli.net/2025/01/08/QzcqNtF1ZgwJ3Io.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题</p>
<p><img src="https://s2.loli.net/2025/01/08/qZKYH2mak68sTie.png" srcset="/img/loading.gif" lazyload alt="image-20250108102343775"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的基本知识请参考之前文章：<a target="_blank" rel="noopener" href="https://wangxiaobai08.github.io/2023/01/12/%E9%93%BE%E8%A1%A8/">链表 - The Peak Tower</a></p>
<h3 id="链表节点结构"><a href="#链表节点结构" class="headerlink" title="链表节点结构"></a>链表节点结构</h3><p><img src="https://s2.loli.net/2025/01/08/OrnBQJhKvtjVp3S.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="链表整体结构"><a href="#链表整体结构" class="headerlink" title="链表整体结构"></a>链表整体结构</h3><p><img src="https://s2.loli.net/2025/01/08/ZdspeMYvUmIboXl.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><img src="https://s2.loli.net/2025/01/08/Mi6vglG9WNY8ReZ.png" srcset="/img/loading.gif" lazyload alt="image-20250108103409751"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="https://s2.loli.net/2025/01/08/wDmJNq1CnFV8aer.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p><img src="https://s2.loli.net/2025/01/08/qpE2uZV1ixYRrMj.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h3><p><img src="https://s2.loli.net/2025/01/08/otZE71fJMAOW5NH.png" srcset="/img/loading.gif" lazyload alt="image-20250108104115162"></p>
<p><img src="https://s2.loli.net/2025/01/08/YAcCskLvFjTy9rQ.png" srcset="/img/loading.gif" lazyload alt="image-20250108104130623"></p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><blockquote>
<p>这篇文章Redis(2)——跳跃表 - 知乎](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109946103)%E8%AE%B2%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86">https://zhuanlan.zhihu.com/p/109946103)讲的比较详细</a></p>
</blockquote>
<h3 id="为什么使用跳表"><a href="#为什么使用跳表" class="headerlink" title="为什么使用跳表"></a>为什么使用跳表</h3><h4 id="同数组比较"><a href="#同数组比较" class="headerlink" title="同数组比较"></a>同数组比较</h4><p>有序集合需要支持高效的插入和删除操作，而数组在插入和删除时需要移动大量元素，效率较低。</p>
<p>而跳跃表通过多层链表实现，插入和删除操作只需要调整局部节点的指针，时间复杂度为 (O(log n))，效率非常高。</p>
<h4 id="同平衡树比较"><a href="#同平衡树比较" class="headerlink" title="同平衡树比较"></a>同平衡树比较</h4><p>平衡树（如红黑树、AVL 树）在高并发环境下，可能需要进行全局的重新平衡操作（如旋转），这会涉及整棵树，影响性能。而且平衡树的实现较为复杂，尤其是需要考虑各种旋转和平衡操作。</p>
<p>而跳跃表的插入和删除操作只需要调整局部节点的指针，不会涉及全局操作，因此在并发环境下性能更好。同时跳跃表的实现相对简单，易于理解和维护。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳跃表（Skip List）</th>
<th>平衡树（如红黑树）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时间复杂度</strong></td>
<td>查找、插入、删除均为 (O(\log n))</td>
<td>查找、插入、删除均为 (O(\log n))</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>简单，代码量少</td>
<td>复杂，需要考虑旋转和平衡</td>
</tr>
<tr>
<td><strong>并发性能</strong></td>
<td>局部调整，适合高并发</td>
<td>全局调整，并发性能较差</td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td>高效，天然支持</td>
<td>需要额外实现</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>略高于平衡树（多层指针）</td>
<td>较低</td>
</tr>
</tbody></table>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义跳跃表节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">// 节点存储的元素，使用SDS（简单动态字符串）表示</span><br>    sds ele;<br>    <span class="hljs-comment">// 节点的分值，用于排序和比较</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 后退指针，指向当前节点的前一个节点，用于从后向前遍历</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-comment">// 节点的层数组，每一层都有一个前进指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-comment">// 前进指针，指向当前层中的下一个节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br><br>        <span class="hljs-comment">// 跨度，表示当前节点到下一个节点之间的节点数量</span><br>        <span class="hljs-comment">// 用于快速计算节点在跳跃表中的排名</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];  <span class="hljs-comment">// 柔性数组，表示节点的层数是不固定的</span><br>&#125; zskiplistNode;<br><br><span class="hljs-comment">// 定义跳跃表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-comment">// 跳跃表的头节点指针，指向跳跃表的第一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>;</span><br>    <span class="hljs-comment">// 跳跃表的尾节点指针，指向跳跃表的最后一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-comment">// 跳跃表中节点的数量，表示跳跃表的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 跳跃表中层数最大的节点的层数，表示跳跃表的最大高度</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure>

<p>Redis 在 William Pugh 的跳跃表基础上做了一些优化：</p>
<ul>
<li><strong>支持双向遍历</strong>：Redis 的跳跃表节点中增加了 <code>backward</code> 指针，支持从后向前遍历。</li>
<li><strong>存储跨度（span）</strong>：每个节点的每一层都存储了跨度（<code>span</code>），用于快速计算元素的排名（rank）。</li>
<li><strong>随机层数</strong>：Redis 通过随机算法确定新节点的层数，保证跳跃表的平衡性。</li>
</ul>
<p><img src="https://s2.loli.net/2025/03/19/5gK7Hi24GnIczwh.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="跳表的设计思想"><a href="#跳表的设计思想" class="headerlink" title="跳表的设计思想"></a>跳表的设计思想</h3><p>一种基于概率的多层链表数据结构，它的设计灵感来源于多层链表结构，但通过引入随机化机制，避免了严格的多层节点数量比例关系，从而在保证高效查找的同时，简化了插入和删除操作。</p>
<p>跳跃表的核心思想是通过多层链表来加速查找过程：</p>
<ul>
<li><strong>多层链表</strong>：跳跃表由多层链表组成，每一层都是一个有序链表。</li>
<li><strong>上层链表是下层链表的“快车道”</strong>：上层链表的节点数量较少，可以快速跳过多个下层节点，从而加速查找。</li>
<li><strong>类似二分查找</strong>：如果每一层的节点数量是下一层的一半，那么查找过程就类似于二分查找，时间复杂度为 (O(\log n))。</li>
</ul>
<p>但如果严格按照每一层的节点数量是下一层的一半来构建多层链表，那么在插入和删除节点时会遇到以下问题：</p>
<ul>
<li><strong>插入问题</strong>：新插入一个节点后，会破坏上下两层链表节点数量的严格比例关系（如 2:1）。为了维持这种比例关系，需要调整新节点后面的所有节点，这会导致时间复杂度退化为 (O(n))。</li>
<li><strong>删除问题</strong>：删除节点时同样需要调整后续节点，以维持严格的节点数量比例关系。</li>
</ul>
<p>为了避免上述问题，跳跃表引入了随机化机制：</p>
<ul>
<li><strong>随机层数</strong>：每个节点在插入时，随机生成一个层数（level）。例如，一个节点的层数为 3，则它会加入到第 1 层到第 3 层的链表中。</li>
<li><strong>不严格的比例关系</strong>：跳跃表不要求上下两层链表的节点数量保持严格的比例关系，而是通过随机化来近似维持多层链表的平衡性。</li>
</ul>
<hr>
<h4 id="跳跃表的插入过程"><a href="#跳跃表的插入过程" class="headerlink" title="跳跃表的插入过程"></a><strong>跳跃表的插入过程</strong></h4><p><img src="https://s2.loli.net/2025/03/19/kPFWJHKx2R9NmXg.jpg" srcset="/img/loading.gif" lazyload></p>
<p>从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，<strong>插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整</strong>，这就降低了插入操作的复杂度。</p>
<p><img src="https://s2.loli.net/2025/03/19/oASqrCilUsy68gj.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="为什么要有压缩列表？"><a href="#为什么要有压缩列表？" class="headerlink" title="为什么要有压缩列表？"></a>为什么要有压缩列表？</h3><p>压缩列表（ziplist）是 Redis 为了优化内存使用而设计的一种紧凑的、内存高效的数据结构。它的主要目标是<strong>在存储小型列表或哈希表时，尽量减少内存占用</strong>。</p>
<p>总所周知，Redis 是一个内存数据库，内存是非常宝贵的资源。传统的数组,链表（如双向链表）或哈希表等在存储小型数据时，会浪费大量内存。</p>
<p>比如就拿数组来说：</p>
<blockquote>
<p>数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。</p>
</blockquote>
<p><img src="https://s2.loli.net/2025/03/19/izQRcMtw29VkZPg.png" srcset="/img/loading.gif" lazyload></p>
<p>而压缩列表通过紧凑的存储方式，减少了内存碎片和额外的指针开销，从而显著降低了内存占用。</p>
<p><img src="https://s2.loli.net/2025/03/19/cODY2Mbge1NE87Z.png" srcset="/img/loading.gif" lazyload></p>
<p>其中每个节点前的length属性，可以在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。</p>
<h4 id="压缩列表的优势"><a href="#压缩列表的优势" class="headerlink" title="压缩列表的优势"></a><strong>压缩列表的优势</strong></h4><ul>
<li><strong>紧凑存储</strong>：压缩列表将数据连续存储在一个字节数组中，避免了额外的指针开销。</li>
<li><strong>内存高效</strong>：对于小型数据，压缩列表的内存占用远低于其他数据结构。</li>
<li><strong>顺序访问快</strong>：由于数据是连续存储的，顺序访问的速度非常快。</li>
</ul>
<hr>
<h4 id="压缩列表的劣势"><a href="#压缩列表的劣势" class="headerlink" title="压缩列表的劣势"></a><strong>压缩列表的劣势</strong></h4><ul>
<li><strong>随机访问慢</strong>：由于数据是连续存储的，随机访问需要遍历数据，效率较低。</li>
<li><strong>插入&#x2F;删除效率低</strong>：插入和删除操作需要移动数据，效率较低。</li>
<li><strong>不适合大数据量</strong>：当数据量较大时，压缩列表的性能会下降，此时 Redis 会自动将其转换为其他数据结构（如双向链表或哈希表）。</li>
</ul>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="ziplist-布局"><a href="#ziplist-布局" class="headerlink" title="ziplist 布局"></a>ziplist 布局</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个空的 ziplist. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 计算 ziplist 的总字节数：</span><br>    <span class="hljs-comment">// ZIPLIST_HEADER_SIZE 是 ziplist 头部的大小，</span><br>    <span class="hljs-comment">// ZIPLIST_END_SIZE 是 ziplist 尾部标志的大小。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes = ZIPLIST_HEADER_SIZE + ZIPLIST_END_SIZE;<br><br>    <span class="hljs-comment">// 分配内存：使用 zmalloc 分配 bytes 大小的内存空间。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl = zmalloc(bytes);<br><br>    <span class="hljs-comment">// 设置 ziplist 的总字节数：</span><br>    <span class="hljs-comment">// ZIPLIST_BYTES(zl) 是一个宏，用于访问 ziplist 的头部字段，存储 ziplist 的总字节数。</span><br>    <span class="hljs-comment">// intrev32ifbe 是一个函数，用于将整数按小端序存储（如果需要）。</span><br>    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);<br><br>    <span class="hljs-comment">// 设置 ziplist 的尾节点偏移量：</span><br>    <span class="hljs-comment">// ZIPLIST_TAIL_OFFSET(zl) 是一个宏，用于访问 ziplist 的头部字段，存储尾节点的偏移量。</span><br>    <span class="hljs-comment">// 初始时，尾节点偏移量为 ZIPLIST_HEADER_SIZE，因为此时 ziplist 是空的，尾节点就是 ziplist 的结束标志。</span><br>    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);<br><br>    <span class="hljs-comment">// 设置 ziplist 的长度：</span><br>    <span class="hljs-comment">// ZIPLIST_LENGTH(zl) 是一个宏，用于访问 ziplist 的头部字段，存储 ziplist 中节点的数量。</span><br>    <span class="hljs-comment">// 初始时，ziplist 是空的，长度为 0。</span><br>    ZIPLIST_LENGTH(zl) = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 设置 ziplist 的结束标志：</span><br>    <span class="hljs-comment">// zl[bytes-1] 是 ziplist 的最后一个字节，存储结束标志 ZIP_END。</span><br>    zl[bytes - <span class="hljs-number">1</span>] = ZIP_END;<br><br>    <span class="hljs-comment">// 返回创建的 ziplist。</span><br>    <span class="hljs-keyword">return</span> zl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整体结构如下：</p>
<p><img src="https://s2.loli.net/2025/03/19/Mu4aF7imysngYJX.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="entry-节点"><a href="#entry-节点" class="headerlink" title="entry 节点"></a>entry 节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlensize; <span class="hljs-comment">/* 用于编码前一个节点长度的字节数 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen;     <span class="hljs-comment">/* 前一个节点的长度 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize;        <span class="hljs-comment">/* 用于编码当前节点类型/长度的字节数 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;            <span class="hljs-comment">/* 当前节点的实际长度 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize;     <span class="hljs-comment">/* 当前节点的头部大小（prevrawlensize + lensize） */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding;      <span class="hljs-comment">/* 当前节点的编码方式 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p;            <span class="hljs-comment">/* 指向当前节点的起始位置 */</span><br>&#125; zlentry;<br></code></pre></td></tr></table></figure>

<p>所以整体结构如下：</p>
<p><img src="https://s2.loli.net/2025/03/19/c8HIymthg6WxGru.png" srcset="/img/loading.gif" lazyload></p>
<p><code>zlentry</code> 结构体用于解析压缩列表中的节点信息。通过 <code>zlentry</code>，可以方便地获取节点的以下信息：</p>
<ul>
<li>前一个节点的长度。</li>
<li>当前节点的编码方式和长度。</li>
<li>当前节点的实际数据。</li>
</ul>
<h5 id="preleng作用"><a href="#preleng作用" class="headerlink" title="preleng作用"></a><em><strong>preleng作用</strong></em></h5><blockquote>
<p><strong>由于压缩列表中的数据以一种不规则的方式进行紧邻，无法通过后退指针来找到上一个元素，而通过保存上一个节点的长度，用当前的地址减去这个长度，就可以很容易的获取到了上一个节点的位置，通过一个一个节点向前回溯，来达到从表尾往表头遍历的操作</strong></p>
</blockquote>
<p><code>prevlen</code> 是 ziplist 中每个节点的一个字段，用于存储前一个节点的长度。</p>
<p><code>prevlen</code> 的长度可以是 1 字节或 5 字节：</p>
<ul>
<li>如果前一个节点的长度小于 254 字节，<code>prevlen</code> 使用 1 字节。</li>
<li>如果前一个节点的长度大于等于 254 字节，<code>prevlen</code> 使用 5 字节（第一个字节为 <code>0xFE</code>，后 4 字节存储实际长度）。</li>
</ul>
<h5 id="encoding作用"><a href="#encoding作用" class="headerlink" title="encoding作用"></a><em><strong>encoding作用</strong></em></h5><p>压缩列表需要支持存储不同类型的数据，例如<strong>字符串</strong>和<strong>整数</strong>。通过 <code>encoding</code>，可以明确区分当前节点是字符串还是整数，以及具体的编码方式。</p>
<p>针对不同的数据类型和值范围可以使用不同的编码方式，从而节省存储空间。</p>
<ul>
<li>对于小整数，可以使用 1 字节的编码。</li>
<li>对于短字符串，可以使用 1 或 2 字节的编码。</li>
<li>对于长字符串或大整数，可以使用更长的编码。</li>
</ul>
<p>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</p>
<p>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</p>
<blockquote>
<p><strong>其：区分不同类型的数据（字符串和整数）。根据数据的特点动态调整存储方式，节省内存。提高解析效率，快速确定如何读取节点的内容。支持灵活的数据存储，适应各种应用场景。</strong></p>
</blockquote>
<p><img src="https://s2.loli.net/2025/03/19/ZjRkETzL59XoQb4.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>content</strong></p>
<p><strong>content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。</strong></p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>连锁更新是 <strong>ziplist</strong> 的一个显著缺点，也是 Redis 在 7.0 版本中引入 <strong>listpack</strong> 替代 ziplist 的重要原因之一。</p>
<p><strong>连锁更新是指在对 ziplist 进行插入或更新操作时，由于某个节点的长度发生变化，导致后续节点的 <code>prevlen</code> 字段需要重新分配空间，从而引发一连串的节点更新操作。</strong></p>
<p>连锁更新通常发生在：</p>
<ol>
<li><strong>插入一个较大的节点</strong>：如果插入的节点长度大于等于 254 字节，会导致后续节点的 <code>prevlen</code> 从 1 字节扩展为 5 字节。</li>
<li><strong>更新一个节点使其长度增加</strong>：如果某个节点的长度从小于 254 字节增加到大于等于 254 字节，会导致后续节点的 <code>prevlen</code> 从 1 字节扩展为 5 字节。</li>
</ol>
<p>假设有一个 ziplist，每个节点的长度都是 253 字节，此时每个节点的 <code>prevlen</code> 都是 1 字节。现在插入一个长度大于等于 254 字节的新节点：</p>
<ol>
<li><p><strong>插入新节点</strong>：</p>
<ul>
<li>新节点的长度大于等于 254 字节，因此它的 <code>prevlen</code> 需要 5 字节。</li>
<li>新节点插入后，它的前一个节点的 <code>prevlen</code> 需要从 1 字节扩展为 5 字节。</li>
</ul>
</li>
<li><p><strong>更新前一个节点</strong>：</p>
<ul>
<li>前一个节点的 <code>prevlen</code> 扩展为 5 字节后，其总长度从 253 字节增加到 257 字节（253 + 4）。</li>
<li>由于前一个节点的长度现在大于等于 254 字节，它的下一个节点的 <code>prevlen</code> 也需要从 1 字节扩展为 5 字节。</li>
</ul>
</li>
<li><p><strong>连锁反应</strong>：</p>
<ul>
<li>每个节点的 <code>prevlen</code> 扩展都会导致下一个节点的 <code>prevlen</code> 也需要扩展，从而引发一连串的更新操作。</li>
<li>这种连锁反应会一直持续到 ziplist 的末尾。</li>
</ul>
</li>
</ol>
<p>这样的连锁更新会导致：</p>
<p>每个节点的 <code>prevlen</code> 扩展都需要重新分配内存，导致频繁的内存操作。连锁更新的时间复杂度为 (O(n^2))，其中 (n) 是 ziplist 的长度。在最坏情况下，每个节点都需要更新，导致性能急剧下降。当 ziplist 的长度较大时，连锁更新的性能问题会更加明显。</p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h3 id="为什么要有整数集合"><a href="#为什么要有整数集合" class="headerlink" title="为什么要有整数集合"></a>为什么要有整数集合</h3><p>Redis 设计 <strong>整数集合（intset）</strong> 是为了在存储整数类型的数据时，提供一种 <strong>内存高效</strong> 且 <strong>性能优越</strong> 的数据结构。整数集合专门用于存储 <strong>整数值</strong> 的集合，并且在特定条件下可以自动升级存储格式，以支持更大范围的整数。</p>
<ul>
<li>而整数集合通过紧凑的数组存储整数，避免了额外的内存开销。它直接存储整数值，而不是存储指针或其他元数据。</li>
<li>在通用的数据结构中，查找一个整数的时间复杂度可能较高（如哈希表的平均 O(1)，链表的 O(n)。而整数集合使用有序数组存储整数，支持二分查找，查找时间复杂度为 O(log⁡n)，性能非常高效。</li>
<li>某些场景需要集合中的元素是有序的，而通用数据结构（如哈希表）无法保证顺序。整数集合内部使用有序数组存储整数，天然支持有序性。</li>
</ul>
<p>当集合中的元素都是整数且数量较少时【<strong>小于512个</strong>】，整数集合的内存效率和性能优势非常明显。整数集合支持高效的集合操作（如并集、交集、差集），适合需要频繁进行集合操作的场景。</p>
<h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合中包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure>

<h4 id="encoding-1"><a href="#encoding-1" class="headerlink" title="encoding"></a><strong><code>encoding</code></strong></h4><p>表示整数集合的编码方式，决定了 <code>contents</code> 数组中每个元素的字节大小。可能的取值：</p>
<ul>
<li><code>INTSET_ENC_INT16</code>：每个元素占用 2 字节（16 位整数）。</li>
<li><code>INTSET_ENC_INT32</code>：每个元素占用 4 字节（32 位整数）。</li>
<li><code>INTSET_ENC_INT64</code>：每个元素占用 8 字节（64 位整数）。</li>
</ul>
<p>通过动态调整编码方式，整数集合可以灵活地支持不同范围的整数。</p>
<h4 id="length"><a href="#length" class="headerlink" title="length"></a><strong><code>length</code></strong></h4><p>表示整数集合中元素的数量。由于 <code>contents</code> 是一个柔性数组（动态数组），<code>length</code> 用于记录当前集合中实际存储的元素个数。</p>
<h4 id="contents"><a href="#contents" class="headerlink" title="contents"></a><strong><code>contents</code></strong></h4><p>是一个柔性数组（flexible array），用于存储集合中的整数。数组中的元素按照 <strong>从小到大</strong> 的顺序排列，这种有序性使得查找操作可以通过二分查找实现，时间复杂度为 O(log⁡n)。</p>
<p>数组的实际大小取决于 <code>encoding</code> 和 <code>length</code>：</p>
<ul>
<li>如果 <code>encoding</code> 是 <code>INTSET_ENC_INT16</code>，则每个元素占用 2 字节。</li>
<li>如果 <code>encoding</code> 是 <code>INTSET_ENC_INT32</code>，则每个元素占用 4 字节。</li>
<li>如果 <code>encoding</code> 是 <code>INTSET_ENC_INT64</code>，则每个元素占用 8 字节。</li>
</ul>
<p><img src="https://s2.loli.net/2025/03/19/xmCVv4QokSfa5zH.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="整数集合升级过程"><a href="#整数集合升级过程" class="headerlink" title="整数集合升级过程"></a>整数集合升级过程</h3><p><strong>整数集合（intset）</strong> 是 Redis 中用于存储唯一整数集合的数据结构。它的一个重要特性是支持 <strong>动态升级</strong>，即当插入的整数超出当前编码范围时，整数集合会自动升级到更大的编码方式，以支持更大范围的整数</p>
<p>从上文的介绍我们得知，整数集合支持以下三种编码方式：</p>
<p>**<code>INTSET_ENC_INT16</code>**：</p>
<ul>
<li>每个元素占用 2 字节（16 位整数）。</li>
<li>支持的整数范围：(-2^{15}) 到 (2^{15}-1)（即 -32768 到 32767）。</li>
</ul>
<p>**<code>INTSET_ENC_INT32</code>**：</p>
<ul>
<li>每个元素占用 4 字节（32 位整数）。</li>
<li>支持的整数范围：(-2^{31}) 到 (2^{31}-1)（即 -2147483648 到 2147483647）。</li>
</ul>
<p>**<code>INTSET_ENC_INT64</code>**：</p>
<ul>
<li>每个元素占用 8 字节（64 位整数）。</li>
<li>支持的整数范围：(-2^{63}) 到 (2^{63}-1)（即 -9223372036854775808 到 9223372036854775807）。</li>
</ul>
<p>而整数集合的升级发生在以下情况下：</p>
<p>当插入的整数超出当前编码范围时，整数集合会自动升级到更大的编码方式。</p>
<p>例如：</p>
<ul>
<li>如果当前编码是 <code>INTSET_ENC_INT16</code>，插入一个 32 位整数时，整数集合会升级到 <code>INTSET_ENC_INT32</code>。</li>
<li>如果当前编码是 <code>INTSET_ENC_INT32</code>，插入一个 64 位整数时，整数集合会升级到 <code>INTSET_ENC_INT64</code>。<ul>
<li>[计算机基础, 数据库, Redis]</li>
</ul>
</li>
</ul>
<hr>
<h4 id="升级的过程"><a href="#升级的过程" class="headerlink" title="升级的过程"></a><strong>升级的过程</strong></h4><p>整数集合的升级过程包括以下步骤：</p>
<h5 id="（1）确定新编码"><a href="#（1）确定新编码" class="headerlink" title="（1）确定新编码"></a>（1）<strong>确定新编码</strong></h5><p>根据插入的整数大小，确定新的编码方式。</p>
<p>例如：</p>
<ul>
<li>插入的整数是 32768（超出 16 位范围），则新编码为 <code>INTSET_ENC_INT32</code>。</li>
<li>插入的整数是 2147483648（超出 32 位范围），则新编码为 <code>INTSET_ENC_INT64</code>。</li>
</ul>
<h5 id="（2）分配新内存"><a href="#（2）分配新内存" class="headerlink" title="（2）分配新内存"></a>（2）<strong>分配新内存</strong></h5><p>根据新编码和元素数量，计算所需的内存大小。使用 <code>zrealloc</code> 重新分配内存。</p>
<h5 id="（3）数据迁移"><a href="#（3）数据迁移" class="headerlink" title="（3）数据迁移"></a>（3）<strong>数据迁移</strong></h5><p>将原有数据从旧编码转换为新编码，并存储到新分配的内存中。</p>
<p>例如：</p>
<ul>
<li>如果从 <code>INTSET_ENC_INT16</code> 升级到 <code>INTSET_ENC_INT32</code>，则将每个 16 位整数扩展为 32 位整数。</li>
</ul>
<h5 id="（4）插入新元素"><a href="#（4）插入新元素" class="headerlink" title="（4）插入新元素"></a>（4）<strong>插入新元素</strong></h5><p>将新元素插入到合适的位置，并保持数组的有序性。</p>
<h5 id="（5）更新元数据"><a href="#（5）更新元数据" class="headerlink" title="（5）更新元数据"></a>（5）<strong>更新元数据</strong></h5><p>更新整数集合的编码方式（<code>encoding</code>）。更新整数集合的长度（<code>length</code>）。</p>
<p>值得注意的是<strong>升级带来的的性能影响</strong></p>
<p><strong>时间复杂度</strong>：升级过程需要遍历所有元素并重新分配内存，时间复杂度为 (O(n))。</p>
<p><strong>空间复杂度</strong>：升级过程需要额外的内存空间，空间复杂度为 (O(n))。</p>
<p><img src="https://s2.loli.net/2025/03/19/zXxF6Jhi8RKknQO.png" srcset="/img/loading.gif" lazyload alt="整数集合的升级 "></p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>Redis 的线程模型是其高性能的关键之一。Redis 采用 <strong>单线程模型</strong> 来处理客户端请求，同时使用 <strong>多线程</strong> 来处理一些后台任务（如持久化、异步删除等）。以下详细解释 Redis 的线程模型及其设计思想。</p>
<p><img src="https://s2.loli.net/2025/03/18/CxUfeBjblgKdkAm.png" srcset="/img/loading.gif" lazyload></p>
<p>Redis 使用单线程处理客户端请求，包括读取、解析、执行命令和返回结果。</p>
<blockquote>
<p>单线程模型的优势：</p>
<ul>
<li><strong>简单高效</strong>：避免了多线程的上下文切换和锁竞争。</li>
<li><strong>原子性</strong>：所有命令都是原子执行的，无需额外的同步机制。</li>
<li><strong>高性能</strong>：在内存操作和网络 I&#x2F;O 的场景下，单线程的性能已经足够高。</li>
</ul>
</blockquote>
<p><strong>单线程的工作流程</strong>：</p>
<ol>
<li><strong>事件循环</strong>：Redis 使用事件驱动模型（基于 <code>epoll</code>、<code>kqueue</code> 或 <code>select</code>）监听客户端连接和请求。</li>
<li><strong>命令执行</strong>：<ul>
<li>读取客户端请求。</li>
<li>解析命令。</li>
<li>执行命令。</li>
<li>返回结果。</li>
</ul>
</li>
<li><strong>非阻塞 I&#x2F;O</strong>：Redis 使用非阻塞 I&#x2F;O，避免在读写网络数据时阻塞线程。</li>
</ol>
<p><strong>但是单线程无法充分利用多核 CPU。如果某个命令执行时间过长，会阻塞后续命令的执行。</strong></p>
<hr>
<p>为了克服单线程模型的局限性，Redis 从 6.0 版本开始引入了多线程支持</p>
<p><strong>网络 I&#x2F;O 多线程</strong></p>
<p>在高并发场景下，网络 I&#x2F;O 可能成为性能瓶颈。Redis 6.0 引入了多线程网络 I&#x2F;O，将读取请求和解析命令的工作分配给多个线程，但<strong>命令执行仍然是单线程</strong>的。</p>
<p><strong>配置</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">io-threads 4  <span class="hljs-comment"># 启用 4 个 I/O 线程</span><br>io-threads-do-reads <span class="hljs-built_in">yes</span>  <span class="hljs-comment"># 启用多线程读取</span><br></code></pre></td></tr></table></figure>

<p><strong>后台任务多线程</strong></p>
<p>某些后台任务（如持久化、异步删除）可能会占用大量 CPU 资源。</p>
<p>Redis 使用多线程处理这些后台任务，避免影响主线程的性能。</p>
<ul>
<li><strong>持久化</strong>：<code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 使用子进程或后台线程。</li>
<li><strong>异步删除</strong>：<code>UNLINK</code> 命令使用后台线程删除大键。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>单线程模型</th>
<th>多线程扩展</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td>单线程处理客户端请求</td>
<td>多线程处理网络 I&#x2F;O 和后台任务</td>
</tr>
<tr>
<td><strong>优势</strong></td>
<td>简单高效，避免锁竞争</td>
<td>提升网络 I&#x2F;O 和后台任务的性能</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>无法充分利用多核 CPU</td>
<td>命令执行仍然是单线程</td>
</tr>
<tr>
<td><strong>优化建议</strong></td>
<td>减少分点使用，使用 Pipeline 和 Lua 脚本</td>
<td>合理配置多线程和持久化</td>
</tr>
</tbody></table>
<p><img src="https://s2.loli.net/2025/03/18/P8otfJIsyp5u3Lw.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="过期删除策略和内存淘汰策略"><a href="#过期删除策略和内存淘汰策略" class="headerlink" title="过期删除策略和内存淘汰策略"></a>过期删除策略和内存淘汰策略</h1><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a><strong>过期删除策略</strong></h3><p>Redis 提供了两种过期删除策略，用于删除已过期的键：</p>
<h4 id="惰性删除（Lazy-Expiration）"><a href="#惰性删除（Lazy-Expiration）" class="headerlink" title="惰性删除（Lazy Expiration）"></a><strong>惰性删除（Lazy Expiration）</strong></h4><p>当客户端访问某个键时，Redis 会检查该键是否过期，如果过期则删除。</p>
<ul>
<li><strong>优点</strong>：节省 CPU 资源，只在访问时检查过期。</li>
<li><strong>缺点</strong>：如果过期键长时间不被访问，会占用内存。</li>
</ul>
<h4 id="定期删除（Periodic-Expiration）"><a href="#定期删除（Periodic-Expiration）" class="headerlink" title="定期删除（Periodic Expiration）"></a><strong>定期删除（Periodic Expiration）</strong></h4><p>Redis 定期随机检查一部分键，删除其中已过期的键。</p>
<ul>
<li><strong>优点</strong>：可以主动清理过期键，减少内存占用。</li>
<li><strong>缺点</strong>：占用一定的 CPU 资源，可能无法及时删除所有过期键。</li>
</ul>
<p>可以通过 <code>redis.conf</code> 配置文件调整定期删除的频率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hz 10  <span class="hljs-comment"># 默认每秒执行 10 次定期删除</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a><strong>内存淘汰策略</strong></h3><p>当 Redis 的内存使用达到上限时，会根据配置的内存淘汰策略删除部分键，以释放内存。</p>
<p>Redis 提供了以下几种内存淘汰策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>noeviction</strong></td>
<td>不淘汰数据，返回错误（默认策略）。</td>
</tr>
<tr>
<td><strong>allkeys-lru</strong></td>
<td>从所有键中淘汰最近最少使用（LRU）的键。</td>
</tr>
<tr>
<td><strong>volatile-lru</strong></td>
<td>从设置了过期时间的键中淘汰最近最少使用（LRU）的键。</td>
</tr>
<tr>
<td><strong>allkeys-random</strong></td>
<td>从所有键中随机淘汰键。</td>
</tr>
<tr>
<td><strong>volatile-random</strong></td>
<td>从设置了过期时间的键中随机淘汰键。</td>
</tr>
<tr>
<td><strong>allkeys-lfu</strong></td>
<td>从所有键中淘汰最不经常使用（LFU）的键。</td>
</tr>
<tr>
<td><strong>volatile-lfu</strong></td>
<td>从设置了过期时间的键中淘汰最不经常使用（LFU）的键。</td>
</tr>
<tr>
<td><strong>volatile-ttl</strong></td>
<td>从设置了过期时间的键中淘汰剩余生存时间（TTL）最短的键。</td>
</tr>
</tbody></table>
<p>可以通过 <code>redis.conf</code> 配置文件设置内存淘汰策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxmemory-policy allkeys-lru  <span class="hljs-comment"># 使用 LRU 淘汰策略</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
<th>优化建议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>过期删除策略</strong></td>
<td>惰性删除和定期删除，用于删除已过期的键</td>
<td>合理配置定期删除频率</td>
</tr>
<tr>
<td><strong>内存淘汰策略</strong></td>
<td>当内存达到上限时，根据策略删除部分键</td>
<td>根据业务需求选择合适的淘汰策略</td>
</tr>
</tbody></table>
<hr>
<p>参考博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzhcoder/article/details/122539972">Redis 跳跃表的原理和实现_redis跳表原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51504545/article/details/117391204">Redis - ziplist (压缩列表) 图文详解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375414918">redis 压缩列表ziplist、quicklist - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/11268067.html">Redis数据结构——整数集合 - 随心所于 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/118280266">【死磕 Redis】—– Redis 数据结构：对象（RedisObject）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wind-snow/p/11172832.html">Redis 学习笔记（篇五）：对象（RedisObject） - 风中抚雪 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389165715">Redis进阶 - 数据结构：对象机制详解，一文深入底层分析 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2447041">深入浅出Redis（一）：对象与数据结构-腾讯云开发者社区-腾讯云</a></p>
<p><a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">跳跃表 — Redis 设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/compress-datastruct/intset.html">整数集合 — Redis 设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1656744">多图解释Redis的整数集合intset升级过程-腾讯云开发者社区-腾讯云</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Shangxingya/article/details/111318472">Redis~集合类型(Set)的数据结构之整数集合和字典_set 集合的元素可以是字典吗-CSDN博客</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" class="category-chain-item">Redis</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="print-no-link">#数据库</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>基础知识(数据结构+线程模型+内存管理)</div>
      <div>http://example.com/2025/05/09/计算机基础/数据库/Redis/基础知识-Redis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ling</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E6%8C%81%E4%B9%85%E5%8C%96-Redis/" title="持久化">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">持久化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis/" title="分布式锁">
                        <span class="hidden-mobile">分布式锁</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
